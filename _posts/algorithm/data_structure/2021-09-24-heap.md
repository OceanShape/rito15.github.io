---
title: 자료구조 - 힙(Heap)
author: Rito15
date: 2021-09-24 21:03:00 +09:00
categories: [Algorithm, Data Structure]
tags: [algorithm, data structure, csharp]
math: true
mermaid: true
---

# 트리 자료 구조
---

<!-- =============================== 개념 설명, 특징 서술 =================================== -->

## **트리(Tree)**

- 재귀적 계층 구조
- 노드로 이루어져 있다.
- 최초의 루트 노드에서부터 시작하며, 하나의 부모 노드는 여러 개의 자식 노드를 가진다.

![image](https://user-images.githubusercontent.com/42164422/134674028-bf337bc1-18de-4593-bdd1-cc504e5b921b.png)

<br>

## **이진 트리(Binary Tree)**

- 각 노드가 최대 두 개의 자식만 가질 수 있는 트리 구조

![image](https://user-images.githubusercontent.com/42164422/134674052-d1cc7257-4bba-45bb-a028-08252c081d7a.png)

<br>

## **포화 이진 트리(Perfect Binary Tree)**

- 모든 잎 노드(Leaf Node : 자식이 없는 노드)가 같은 계층에 위치한 노드
- 완전한 삼각형 꼴을 이룬 이진 트리 구조를 의미한다.

![image](https://user-images.githubusercontent.com/42164422/134674072-20f37d25-da88-4a03-93af-2728382830a3.png)

<br>

## **완전 이진 트리(Complete Binary Tree)**

- 마지막 계층 이전까지의 계층이 포화 이진 트리를 이룬 구조
- 마지막 계층은 왼쪽에서부터 채워지는 구조
- 일차원 배열을 통해 표현될 수 있다.

![image](https://user-images.githubusercontent.com/42164422/134674095-146eab1f-e443-4982-a10b-dd6a99afd04c.png)

<br>

# 힙(Heap)
---

- 완전 이진 트리의 일종

- 최소 힙(Min Heap), 최대 힙(Max Heap)이 있다.

<br>

## **최소 힙(Min Heap)**

- 루트 노드에 언제나 트리 내의 최솟값이 위치한다.

- 부모 노드는 항상 자식 노드들보다 작은 값을 갖는다.

![image](https://user-images.githubusercontent.com/42164422/134676705-090003de-7ee7-455f-9dc3-6bd0e2689a69.png)

<br>

## **최대 힙(Max Heap)**

- 루트 노드에 언제나 트리 내의 최솟값이 위치한다.

- 부모 노드는 항상 자식 노드들보다 작은 값을 갖는다.

![image](https://user-images.githubusercontent.com/42164422/134678307-4911bca0-59f7-48a2-a899-a18089857f2f.png)

<br>


# 노드 삽입(예시 : 최소 힙)
---

## **삽입**

- 새로운 노드를 힙의 마지막 위치에 삽입한다.
- 힙의 요건을 충족할 수 있도록, 새롭게 추가한 노드와 그 부모 노드를 비교하여 부모 노드보다 값이 작으면 서로 바꾼다.
- 힙의 요건이 충족될 때까지 부모 노드들을 거슬러 올라가며 반복한다.

<br>

### **[1] 마지막 위치에 노드 2를 삽입한다.**

![image](https://user-images.githubusercontent.com/42164422/134680500-9c2b03fc-b6b4-4291-96d3-d8e4dd89f0d5.png)

### **[2] 부모 노드의 값인 6이 2보다 작으므로 서로 바꾼다.**

![image](https://user-images.githubusercontent.com/42164422/134680541-b51b2ade-7879-408a-97d0-9d277a9caa44.png)

### **[3] 부모 노드의 값인 3이 2보다 작으므로 서로 바꾼다.**

![image](https://user-images.githubusercontent.com/42164422/134680604-d9d5bdfe-2764-4fab-af8f-b39621b03e99.png)

<br>

## **삽입 최적화**

- 새로운 노드 삽입 이후 부모 노드와 비교하여 교환하는 동작은 (임시 변수에 A 할당 - A에 B 할당 - B에 임시 변수 할당)이라는 전통적인 `Swap(A, B)` 연산을 사용해, 3번의 초기화를 통해 구현해야 한다.
- 이를 최적화하여 미리 새로운 노드를 캐싱(저장)한 뒤 각 단계마다 부모를 자식 위치에 할당하기만 하고, 거슬러 올라가기를 멈춘 지점에 새로운 노드를 할당하는 방식으로 비용을 1/3 정도로 줄일 수 있다.
- 매 수행마다 캐싱된 노드가 위치할 인덱스를 저장하면서 진행하여, 진행을 멈췄을 때의 위치에 새로운 노드를 넣으면 된다.

### **[1] 새로운 노드 2를 삽입할 위치(마지막 위치)를 확보하고, 노드를 일단 따로 저장한다.**

![image](https://user-images.githubusercontent.com/42164422/134688649-9be5ac4b-7821-492d-9e3f-d8fff7c524a2.png)

### **[2] 새로운 노드 2보다 6이 크므로, 노드 6을 마지막 위치로 옮긴다.**

- 노드 6이 복제되며 원래 있던 자리에도 그대로 남아 있더라도, 일단 내버려 둔다.

![image](https://user-images.githubusercontent.com/42164422/134688643-68b598e1-a755-4d68-9467-d64d30dc9705.png)

### **[3] 새로운 노드 2보다 3이 크므로, 노드 6이 원래 있던 위치에 노드 3을 옮긴다.**

![image](https://user-images.githubusercontent.com/42164422/134688636-dbd32b28-1b37-4279-8c01-35bf69673854.png)

### **[4] 힙의 조건이 모두 충족되었으므로, 노드 3이 있던 위치에 노드 2를 삽입한다.**

![image](https://user-images.githubusercontent.com/42164422/134688621-45dc96c5-4e21-4d93-bfd4-cc28d2f9d9df.png)

<br>

# 노드 삭제(예시 : 최소 힙)
---

## **삭제**

- 기존의 노드를 삭제하고, 마지막 노드를 그 위치로 옮긴다.
- 옮긴 노드와 그 위치의 두 자식 노드를 비교하여, 가장 작은 자식보다 자신이 큰 경우 서로 바꾼다.
- 힙이 성립할 때까지 자식들과 비교하여 이를 반복한다.

<br>

### **[1] 노드 1을 삭제하고 마지막 노드인 6을 그 위치로 옮긴다.**

![image](https://user-images.githubusercontent.com/42164422/134685981-10803328-9795-4a1e-9a79-cdc264e08f0b.png)

### **[2] 두 자식 중 가장 작은 자식인 2보다 6이 크므로, 서로 바꾼다.**

![image](https://user-images.githubusercontent.com/42164422/134685973-05327cd5-29b7-4352-93e1-f0a39c7a0003.png)

### **[3] 다음 위치에서 가장 작은 자식인 3보다 6이 더 크므로, 서로 바꾼다.**

![image](https://user-images.githubusercontent.com/42164422/134685963-0b33be31-3bb2-492a-85ec-4cd2cb196d2a.png)

<br>

## **삭제 최적화**

- 삽입의 최적화와 동일한 방식을 사용한다.
- 미리 마지막 노드를 제거하여 캐싱(저장)해두고, 제거한 노드의 위치에서부터 캐싱된 노드와 해당 위치의 자식 노드들을 비교한다.
- 진행 중인 현재 위치에서 더 작은 자식 노드보다 캐싱된 노드의 값이 클 경우, 서로를 바꾸는 대신에 그냥 자식 노드만 부모 위치로 올린 뒤 해당 자식 위치에서 다음 비교을 이어나간다.
- 매 수행마다 캐싱된 노드가 위치할 인덱스를 저장하면서 진행하여, 진행을 멈췄을 때의 위치에 새로운 노드를 넣으면 된다.

### **[1] 마지막 노드 6을 제거하고, 따로 저장한다.**

- 제거될 노드 1은 삭제 연산의 반환 값이 필요하면 미리 따로 저장하고, 필요 없다면 그냥 둔다.

![image](https://user-images.githubusercontent.com/42164422/134689448-9e0275a7-e1a0-4e12-89e5-d285d74b2f19.png)

### **[2] 두 자식 노드 중 가장 작은 2가 6보다 작으므로, 노드 2를 부모 위치로 옮긴다.**

- 노드 2가 복제되며 원래 위치에도 남아 있을 수 있으나, 상관 없으니 그냥 둔다.

![image](https://user-images.githubusercontent.com/42164422/134689442-411a8ac6-b10c-4f42-8d17-04ea139fbcd9.png)

### **[3] 다음 두 자식 노드 중 가장 작은 3이 6보다 작으므로, 노드 3을 부모 위치로 옮긴다.**

![image](https://user-images.githubusercontent.com/42164422/134689434-5d1258cd-fea2-4865-83ae-2a1e2f122efd.png)

### **[4] 힙의 조건이 모두 충족되었으므로, 멈춘 위치에 노드 6을 삽입한다.**

![image](https://user-images.githubusercontent.com/42164422/134689425-5b157258-5848-484d-9155-3d05564f4e8d.png)



<br>

# 힙 정렬(Heap Sort)
---



<br>

# 최소 힙의 구현(C언어)
---

<details>
<summary markdown="span"> 
...
</summary>

{% include codeHeader.html %}
```c

```

</details>


<br>

# 최소 힙의 구현(C#)
---

<details>
<summary markdown="span"> 
...
</summary>

{% include codeHeader.html %}
```cs

```

</details>

<br>



# References
---




<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-08-26T04:48:35+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>유니티 에디터 GUI - 미끄러지는 On-Off 버튼</title>
    <link href="https://rito15.github.io/posts/unity-editor-sliding-onoff-button/" rel="alternate" type="text/html" title="유니티 에디터 GUI - 미끄러지는 On-Off 버튼" />
    <published>2021-08-26T03:45:00+09:00</published>
  
    <updated>2021-08-26T03:45:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-editor-sliding-onoff-button/</id>
    <content src="https://rito15.github.io/posts/unity-editor-sliding-onoff-button/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor Memo" />
    
  

  
    <summary>
      





      Memo




bool onOff = true;
bool onOffMoving = false;
float onOffPos = 0f;
string onOffStr = "On";

private void DrawMovingOnOffButton()
{
    const float LEFT = 15f;
    const float RIGHT = 52f;
    const float WIDTH = 40f;
    const float HEIGHT = 20f;
    const float MOVE_SPEED = 1f;

    Rect rect = GUILayoutUtility.GetRect(1f, HEIGHT);

    Rect bgRect = new Rect(rect);
    bgRect.x = LEFT...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 에디터 GUI의 특정 컨트롤 포커스 여부 확인하기</title>
    <link href="https://rito15.github.io/posts/unity-editor-check-focused/" rel="alternate" type="text/html" title="유니티 에디터 GUI의 특정 컨트롤 포커스 여부 확인하기" />
    <published>2021-08-26T03:45:00+09:00</published>
  
    <updated>2021-08-26T03:45:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-editor-check-focused/</id>
    <content src="https://rito15.github.io/posts/unity-editor-check-focused/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor Memo" />
    
  

  
    <summary>
      





      Memo


// 다음에 나올 GUI 컨트롤에 이름 부여
GUI.SetNextControlName("Foooooooocus");

// GUI 그리기
EditorGUI.TextArea(rect, value, inputStyle);

// 포커스 여부 확인
if(GUI.GetNameOfFocusedControl() == "Foooooooocus")
{
    // Do Something..
}


    </summary>
  

  </entry>

  
  <entry>
    <title>Screen Effect Controller(스크린 이펙트, 포스트 프로세싱)</title>
    <link href="https://rito15.github.io/posts/unity-screen-effect-controller/" rel="alternate" type="text/html" title="Screen Effect Controller(스크린 이펙트, 포스트 프로세싱)" />
    <published>2021-08-25T21:00:00+09:00</published>
  
    <updated>2021-08-25T21:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-screen-effect-controller/</id>
    <content src="https://rito15.github.io/posts/unity-screen-effect-controller/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor Utilities" />
    
  

  
    <summary>
      





      Summary


  유니티 기본 렌더 파이프라인(Built-in Render Pipeline)에서 사용할 수 있습니다.
    
      SRP, URP, HDRP에서는 사용할 수 없습니다.
    
  
  
    스크린 이펙트(포스트 프로세싱 이펙트)를 간단히 적용할 수 있습니다.
  
  
    게임 오브젝트의 단순 활성화/비활성화 방식으로 스크린 이펙트 적용/해제가 가능합니다.
  
  유니티 타임라인을 통해 편리하게 사용할 수 있습니다.




테스트 완료 에디터 버전


  2018.3.14f1
  2019.4.9f1
  2020.3.14f1
  2021.1.16f1




Preview




  



   
.


  2021_0825_Screen_Effect_Demo.zip

...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 에디터 GUI - 여러 개의 커브를 겹쳐 그리기</title>
    <link href="https://rito15.github.io/posts/unity-editor-draw-multiple-curves/" rel="alternate" type="text/html" title="유니티 에디터 GUI - 여러 개의 커브를 겹쳐 그리기" />
    <published>2021-08-25T03:00:00+09:00</published>
  
    <updated>2021-08-25T03:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-editor-draw-multiple-curves/</id>
    <content src="https://rito15.github.io/posts/unity-editor-draw-multiple-curves/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor Memo" />
    
  

  
    <summary>
      





      Note


EditorGUI.CurveField()를 통해 AnimationCurve를 에디터에 그릴 수 있다.

그런데 일반적인 방법으로는 하나의 커브 필드에 하나의 커브만 그려진다.

커브 필드에는 불투명한 배경 색상이 존재하기 때문이다.


  (0.337f, 0.337f, 0.337f, 1f)






따라서 이를 해결하기 위해서는, 리플렉션을 이용한 편법을 사용해야 한다.

private static FieldInfo fiCurveBGColor;
private static Color defaultCurveBGColor;

private void DrawSomeCurveField()
{
    // 리플렉션을 통해 배경 색상 필드 정보 참조
    if (fiCurveBGColor == nu...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 에디터의 특정 영역 마우스 클릭 방지하기</title>
    <link href="https://rito15.github.io/posts/unity-editor-block-mouse-click/" rel="alternate" type="text/html" title="유니티 에디터의 특정 영역 마우스 클릭 방지하기" />
    <published>2021-08-25T02:59:00+09:00</published>
  
    <updated>2021-08-25T02:59:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-editor-block-mouse-click/</id>
    <content src="https://rito15.github.io/posts/unity-editor-block-mouse-click/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor Memo" />
    
  

  
    <summary>
      





      Memo


Rect rect = ....; // 마우스 클릭 방지할 영역

if (rect.Contains(Event.current.mousePosition))
{
    if(Event.current.type == EventType.MouseDown)
        Event.current.Use();
}

// 이후 해당 영역에서의 모든 마우스 클릭은 무시(Button, Value Fields, ...)



  위의 방식을 이용해서, 컨트롤의 색상을 변경시키지 않는 DisabledGroup을 구현할 수 있다.


    </summary>
  

  </entry>

</feed>



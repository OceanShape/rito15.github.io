

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-02-12T05:30:57+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>텍스트 메쉬 프로(TMPro) 사용하기</title>
    <link href="https://rito15.github.io/posts/textmeshpro-usage/" rel="alternate" type="text/html" title="텍스트 메쉬 프로(TMPro) 사용하기" />
    <published>2021-02-12T02:09:00+09:00</published>
  
    <updated>2021-02-12T02:09:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/textmeshpro-usage/</id>
    <content src="https://rito15.github.io/posts/textmeshpro-usage/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      특징


  
    SDF(Signed Distance Field)를 이용하여 UGUI 텍스트보다 외곽선을 더 깔끔하게 표현한다.
  
  
    마테리얼을 이용하여 다양한 효과를 줄 수 있다.
  
  
    UGUI 텍스트에 비해 성능이 좋다.
  
  
    미리 고해상도의 Font Texture Atlas를 생성하여 사용하기 때문에 실시간으로 크기가 변경되어도 픽셀을 부드럽게 나타낼 수 있다.
  




폰트 애셋 생성하기


1. 필요 리소스 임포트


  [Window] - [TextMeshPro] - [Import Essential Resources] - [Import]




2. 폰트 준비


  
    한글을 지원하는 폰트 파일(.ttf)을 유니티 프로젝트로 가져온다.
  ...
    </summary>
  

  </entry>

  
  <entry>
    <title>OpenGL 공부 - 15 - View Projection Matrix</title>
    <link href="https://rito15.github.io/posts/opengl-study-15/" rel="alternate" type="text/html" title="OpenGL 공부 - 15 - View Projection Matrix" />
    <published>2021-02-11T17:05:00+09:00</published>
  
    <updated>2021-02-11T17:05:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/opengl-study-15/</id>
    <content src="https://rito15.github.io/posts/opengl-study-15/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="OpenGL" />
    
    <category term="OpenGL Study" />
    
  

  
    <summary>
      





      목표


  View, Projection 행렬 만들고 적용하기




공간 변환




공간 변환 과정을 간단히 설명하면 다음과 같다.

1. Model Transformation


  Model -&amp;gt; World


모델링의 피벗이 원점인 Local Space(Model Space 또는 Object Space)에 Model Matrix를 곱하면 월드의 특정 좌표가 원점인 World Space의 좌표로 변환된다.



2. View Transformation


  World -&amp;gt; View


카메라의 위치, 방향을 정의한 뒤 World Space에 View Matrix를 곱해주면 View Space로 변환된다.

View Space에서는 카메라의 좌표가 원점이며, 카메라를 통해 공간을 바...
    </summary>
  

  </entry>

  
  <entry>
    <title>OpenGL 공부 - 14</title>
    <link href="https://rito15.github.io/posts/opengl-study-14/" rel="alternate" type="text/html" title="OpenGL 공부 - 14" />
    <published>2021-02-10T15:20:00+09:00</published>
  
    <updated>2021-02-10T15:20:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/opengl-study-14/</id>
    <content src="https://rito15.github.io/posts/opengl-study-14/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="OpenGL" />
    
    <category term="OpenGL Study" />
    
  

  
    <summary>
      





      목표


  Model Matrix에 대한 이해
  이동, 회전, 크기 변경




공부 내용


공통

glm의 모델 매트릭스를 선언하는 것으로 시작한다.

glm::mat modelMatrix(1.0f);


openGL의 Transformation은 기본적으로 4x4 행렬과 vec3로 이루어진다.

4x4 행렬과 곱해지려면 벡터 또한 vec4여야 하므로, vec3를 전달하면 내부적으로 vec4(vec3, 1.)을 만들어 연산한다.

변환행렬은 서로 곱하여 하나의 변환행렬로 사용할 수 있다.

그런데 만약 이동행렬 뒤에 크기행렬을 곱하면 이동값 또한 크기가 변하기 때문에

이동, 회전, 크기 행렬을 곱하여 사용할 때는 크기, 회전, 이동 순서로 행렬을 곱하여 사용한다.



크기(Scale)



...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 에디터 종료 확인 다이얼로그 만들기</title>
    <link href="https://rito15.github.io/posts/unity-editor-exit-dialog/" rel="alternate" type="text/html" title="유니티 에디터 종료 확인 다이얼로그 만들기" />
    <published>2021-02-10T13:50:00+09:00</published>
  
    <updated>2021-02-10T13:50:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-editor-exit-dialog/</id>
    <content src="https://rito15.github.io/posts/unity-editor-exit-dialog/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      Memo


기본적으로 유니티 에디터를 종료할 때는 확인창이 뜨지 않고 바로 종료된다.

만약 실수로 닫기 버튼을 눌러버린다면 그대로 종료되어 버린다.

그런데 유니티 에디터는 에디터의 종료도 이벤트로 구분하여, 메소드를 추가할 수 있도록 구현해놓았기 때문에

이를 이용해 에디터의 종료를 시도할 경우 확인창을 띄우도록 할 수 있다.



[InitializeOnLoad]
public class EditorExitDialog
{
    static EditorExitDialog()
    {
        EditorApplication.wantsToQuit += 
            () =&amp;gt; EditorUtility.DisplayDialog("Unity Editor", "Are you sure...
    </summary>
  

  </entry>

  
  <entry>
    <title>OpenGL 공부 - 13 - Texture</title>
    <link href="https://rito15.github.io/posts/opengl-study-13/" rel="alternate" type="text/html" title="OpenGL 공부 - 13 - Texture" />
    <published>2021-02-10T01:30:00+09:00</published>
  
    <updated>2021-02-10T01:30:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/opengl-study-13/</id>
    <content src="https://rito15.github.io/posts/opengl-study-13/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="OpenGL" />
    
    <category term="OpenGL Study" />
    
  

  
    <summary>
      





      목표


  폴리곤에 텍스쳐 씌워보기(1장, 여러 장)




1. 텍스쳐 한 장 사용


이미지 준비

  프로젝트 디렉토리 내에 Images 폴더를 만들고 PNG 이미지 파일을 준비한다.




소스코드 작성


  위치 : VertexAttribPointer ~ Main Loop 사이



[1] 이미지 로드

int imageWidth = 0;
int imageHeight = 0;
unsigned char* image = SOIL_load_image("Images/MoonCat.png",
    &amp;amp;imageWidth, &amp;amp;imageHeight, NULL, SOIL_LOAD_RGBA);



[2] 텍스쳐 객체 생성 및 바인드

GLuint texture0; // Texture ID
...
    </summary>
  

  </entry>

</feed>



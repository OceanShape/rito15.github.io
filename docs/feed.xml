

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-06-14T02:26:18+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>스크립트로 콘솔 내용 지우기</title>
    <link href="https://rito15.github.io/posts/unity-clear-console-through-script/" rel="alternate" type="text/html" title="스크립트로 콘솔 내용 지우기" />
    <published>2021-06-14T02:22:00+09:00</published>
  
    <updated>2021-06-14T02:22:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-clear-console-through-script/</id>
    <content src="https://rito15.github.io/posts/unity-clear-console-through-script/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor Memo" />
    
  

  
    <summary>
      





      private static MethodInfo clearMethodInfo;
private static void ClearLog()
{
    if (clearMethodInfo == null)
    {
        var assembly = Assembly.GetAssembly(typeof(UnityEditor.Editor));
        var type = assembly.GetType("UnityEditor.LogEntries");
        clearMethodInfo = type.GetMethod("Clear");
    }
    clearMethodInfo.Invoke(new object(), null);
}




Reference


  https://www.codegrepp...
    </summary>
  

  </entry>

  
  <entry>
    <title>에디터 윈도우 관련 유용한 코드 모음</title>
    <link href="https://rito15.github.io/posts/unity-editor-window-codes/" rel="alternate" type="text/html" title="에디터 윈도우 관련 유용한 코드 모음" />
    <published>2021-06-14T01:50:00+09:00</published>
  
    <updated>2021-06-14T01:50:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-editor-window-codes/</id>
    <content src="https://rito15.github.io/posts/unity-editor-window-codes/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor" />
    
  

  
    <summary>
      





      Enum - EditorWindowType


[Flags]
private enum EditorWindowType
{
    Scene = 1,
    Game  = 2,
    Inspector = 4,
    Hierarchy = 8,
    Project   = 16,
    Console   = 32
}




특정 윈도우에 포커스하기


private static void FocusOnWindow(EditorWindowType windowType)
{
    EditorApplication.ExecuteMenuItem("Window/General/" + windowType.ToString());
}




현재 선택된 윈도우에 키 이벤트 발생시키기


/// &amp;lt;summary&amp;gt; 현재 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>커스텀 에디터(인스펙터)의 스크롤바를 고려한 너비 구하기</title>
    <link href="https://rito15.github.io/posts/unity-editor-view-width-considering-scroll/" rel="alternate" type="text/html" title="커스텀 에디터(인스펙터)의 스크롤바를 고려한 너비 구하기" />
    <published>2021-06-13T23:33:00+09:00</published>
  
    <updated>2021-06-13T23:33:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-editor-view-width-considering-scroll/</id>
    <content src="https://rito15.github.io/posts/unity-editor-view-width-considering-scroll/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor Memo" />
    
  

  
    <summary>
      





      Note


커스텀 에디터에서 EditorGUIUtility.currentViewWidth를 통해 현재 에디터의 너비를 구할 수 있지만,



위처럼 컴포넌트 창이 상하로 길어져 우측에 스크롤바가 생기는 경우

스크롤바가 컨트롤들을 가림에도 불구하고, currentViewWidth는 스크롤바를 포함한 너비를 알려주며

스크롤바를 제외한 너비를 구하는 API가 제공되지 않는다.

심지어 스크롤바의 존재 여부조차 스크립트를 통해서는 알 수 없다.

따라서 편법을 통해 구해야 한다.



How to


Layout API들을 통해 만들어진 Rect는 항상 에디터창의 우측 스크롤바의 너비를 제외한 영역에 만들어지므로,

이렇게 참조한 Rect의 너비는 스크롤바의 존재유무에 따라 유동적으로 변하게 된다.


...
    </summary>
  

  </entry>

  
  <entry>
    <title>Singleton Pattern(싱글톤 패턴)</title>
    <link href="https://rito15.github.io/posts/singleton-pattern/" rel="alternate" type="text/html" title="Singleton Pattern(싱글톤 패턴)" />
    <published>2021-06-11T17:17:00+09:00</published>
  
    <updated>2021-06-11T17:17:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/singleton-pattern/</id>
    <content src="https://rito15.github.io/posts/singleton-pattern/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Algorithm" />
    
    <category term="Design Pattern" />
    
  

  
    <summary>
      





      Singleton Pattern


특징

  정적 참조로부터 인스턴스 참조를 가져올 수 있다.
  특정 클래스에 단 한 개의 객체만 존재하도록 보장할 수 있다.


사용처

  프로그램 내에 반드시 하나만 존재해야 하는 클래스


고려사항

  싱글톤 객체 생성 타이밍을 고려해야 한다. (정적 or 동적)
  기본적으로 스레드 안전하지 않으므로, 추가적인 처리가 필요하다.




싱글톤 인스턴스를 통한 호출(공통)

class SingletonTest
{
    public static void Method()
    {
        // 클래스명.Instance.멤버참조
        SingletonClass.Instance.Method();
    }
}




Source Code


[1]...
    </summary>
  

  </entry>

  
  <entry>
    <title>마우스 커서가 UI 위에 있는지 검사하는 간단한 코드</title>
    <link href="https://rito15.github.io/posts/unity-check-cursor-over-ui/" rel="alternate" type="text/html" title="마우스 커서가 UI 위에 있는지 검사하는 간단한 코드" />
    <published>2021-06-10T02:22:00+09:00</published>
  
    <updated>2021-06-10T02:22:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-check-cursor-over-ui/</id>
    <content src="https://rito15.github.io/posts/unity-check-cursor-over-ui/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo - Shorts" />
    
  

  
    <summary>
      





      private static bool IsPointerOverUI()
    =&amp;gt; UnityEngine.EventSystems.EventSystem.current.IsPointerOverGameObject();


    </summary>
  

  </entry>

</feed>



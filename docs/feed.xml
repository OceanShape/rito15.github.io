

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-08-15T19:52:15+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>(Amplify) Electricity Shader</title>
    <link href="https://rito15.github.io/posts/unity-amplify-electricity-shader/" rel="alternate" type="text/html" title="(Amplify) Electricity Shader" />
    <published>2021-08-14T09:09:00+09:00</published>
  
    <updated>2021-08-15T02:57:49+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-amplify-electricity-shader/</id>
    <content src="https://rito15.github.io/posts/unity-amplify-electricity-shader/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Amplify Shader" />
    
  

  
    <summary>
      





      Summary



  표면에 전기가 맴도는 효과




Note



  
    포스트프로세싱 Bloom을 넣어 주는 것이 좋다.
  
  
    최적화를 위해서는 Noise Generator 노드 대신 노이즈 텍스쳐를 사용해야 한다.
  




Preview








Properties






Settings


General

  Light Model : Unlit
  Cast Shadows, Receive Shadows 체크 해제


Blend Mode

  Masked




Nodes






Download



  2021_0814_Electricity.zip



    </summary>
  

  </entry>

  
  <entry>
    <title>C# String, StringBuilder, ZString</title>
    <link href="https://rito15.github.io/posts/cs-string-stringbuilder-and-zstring/" rel="alternate" type="text/html" title="C# String, StringBuilder, ZString" />
    <published>2021-08-11T17:17:00+09:00</published>
  
    <updated>2021-08-11T17:17:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-string-stringbuilder-and-zstring/</id>
    <content src="https://rito15.github.io/posts/cs-string-stringbuilder-and-zstring/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Study" />
    
  

  
    <summary>
      





      String 포맷팅의 문제점


$"IntValue : {123}, BoolValue : {true}";


또는

string.Format("IntValue {0}, BoolValue : {1}", 123, true);


이런 방식의 스트링 포맷팅을 쓰는 경우가 정말 많다.



정말 편리하긴 하지만,

StringBuilder와 비교하면 성능도 좋지 않고

심지어 가비지도 더 많이 발생시킨다.

그렇다고 StringBuilder를 쓰려니 가독성이 좋지 않고 불편하다는 단점이 있다.



ZString



  https://github.com/Cysharp/ZString




ZString.Format("IntValue {0}, BoolValue : {1}", 123, true);


strin...
    </summary>
  

  </entry>

  
  <entry>
    <title>Snow Pile &amp;amp; Clear (Plane에 눈 쌓기, 지우기)</title>
    <link href="https://rito15.github.io/posts/unity-snow-pile-and-clear/" rel="alternate" type="text/html" title="Snow Pile &amp;amp; Clear (Plane에 눈 쌓기, 지우기)" />
    <published>2021-08-10T23:23:00+09:00</published>
  
    <updated>2021-08-10T23:23:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-snow-pile-and-clear/</id>
    <content src="https://rito15.github.io/posts/unity-snow-pile-and-clear/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Toys" />
    
  

  
    <summary>
      





      Summary


  
    파티클이 닿는 지점에 눈 쌓기
  
  
    쌓인 눈 지우기
  




Preview


[1] 쌓기






[2] 지우기






Details


[1] Ground 쉐이더


  
    메인 텍스쳐의 색상을 그대로 최종 색상으로 출력한다.
  
  
    메인 텍스쳐의 rgb 값 중 하나를 Height Map으로 사용하여, 버텍스 Y 위치값에 더해준다.
  
  
    마테리얼을 생성하여 Plane에 적용한다.
  




[2] 렌더 텍스쳐


  
    게임 시작 시 렌더 텍스쳐를 하나 생성한다.
  
  
    Ground 마테리얼의 메인 텍스쳐에 렌더 텍스쳐를 넣어준다.
  




[3] 브러시 텍스쳐


  
    마치 Default ...
    </summary>
  

  </entry>

  
  <entry>
    <title>(Amplify) Shockwave Shader</title>
    <link href="https://rito15.github.io/posts/unity-amplify-shockwave-shader/" rel="alternate" type="text/html" title="(Amplify) Shockwave Shader" />
    <published>2021-08-10T20:10:00+09:00</published>
  
    <updated>2021-08-10T20:10:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-amplify-shockwave-shader/</id>
    <content src="https://rito15.github.io/posts/unity-amplify-shockwave-shader/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Amplify Shader" />
    
  

  
    <summary>
      





      Summary



  Quad 기반 Shockwave 쉐이더




Preview








Properties




Progress 값이 증가함에 따라 Shockwave가 퍼져나간다.

(범위 : 0 ~ 1)



Settings


General

  Light Model : Unlit


Blend Mode

  Transparent




Nodes






Download



  2021_0810_Shockwave.zip



    </summary>
  

  </entry>

  
  <entry>
    <title>C# If vs. try-catch 성능</title>
    <link href="https://rito15.github.io/posts/cs-if-vs-try-performance/" rel="alternate" type="text/html" title="C# If vs. try-catch 성능" />
    <published>2021-08-09T14:41:00+09:00</published>
  
    <updated>2021-08-09T14:41:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-if-vs-try-performance/</id>
    <content src="https://rito15.github.io/posts/cs-if-vs-try-performance/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Study" />
    
  

  
    <summary>
      





      Note


개발을 하다보면 고민되는 경우가 많다.

예외 조건을 처리할 때 if로 예외를 회피할지, try-catch로 처리할지,

실제 성능은 어떻게 될지도 궁금한 부분이다.



try-catch는 예외가 발생하지 않으면 성능 소모가 없다고도 하고,

성능 소모가 있지만 O(1)이라고도 하고,

찾아보면 다양한 주장들을 확인해볼 수 있다.



대신 공통적인 사실은

try-catch를 통해 예외를 핸들링하게 되면

무조건 if보다 성능 소모가 크다는 점이다.

try-catch는 예외 발생 지점의 스택을 거슬러 올라가서

모두 추적하고 기록하게 되는데,

이 과정에서 성능 소모가 크게 발생한다는 것이다.



이제 몇가지 테스트 케이스를 통해서 성능을 테스트하고,

if와 try-catch 선택...
    </summary>
  

  </entry>

</feed>



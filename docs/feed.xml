

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-10-10T04:26:36+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Sphere Cast to Sphere</title>
    <link href="https://rito15.github.io/posts/sphere-cast-to-sphere/" rel="alternate" type="text/html" title="Sphere Cast to Sphere" />
    <published>2021-10-09T18:26:00+09:00</published>
  
    <updated>2021-10-10T04:24:11+09:00</updated>
  
    <id>https://rito15.github.io/posts/sphere-cast-to-sphere/</id>
    <content src="https://rito15.github.io/posts/sphere-cast-to-sphere/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Algorithm" />
    
    <category term="Algorithms" />
    
  

  
    <summary>
      





      Sphere Cast



  
    공간 상의 한 점에서부터 목표 지점까지 구체를 전진시켜, 구체 표면에 닿는 물체 표면을 검출한다.
  
  
    레이캐스트와는 달리 구체의 반지름을 고려해야 한다.
  




Sphere Cast to Sphere



  
    대상 물체가 구체인 경우에 대해서만 검사한다.
  
  
    충돌 여부와 충돌 지점을 알아내는 것이 목표이다.
  




[1] 충돌 여부 판정

충돌 지점을 계산하기 전에, 우선 충돌 여부를 판정할 필요가 있다.


  
    A : 캐스트 시작 지점
    B : 캐스트 종료 지점
    S : 검사 대상 구체의 중심 위치
    r1 : 캐스트 구체의 반지름
    r2 : 구체 S의 반지름
    d : 점 S에서 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 쉐이더 - 실수 타입들</title>
    <link href="https://rito15.github.io/posts/unity-shader-real-number-types/" rel="alternate" type="text/html" title="유니티 쉐이더 - 실수 타입들" />
    <published>2021-10-07T00:48:00+09:00</published>
  
    <updated>2021-10-07T00:48:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-shader-real-number-types/</id>
    <content src="https://rito15.github.io/posts/unity-shader-real-number-types/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Shader Memo" />
    
  

  
    <summary>
      





      Memo


[1] float

  32비트
  
    유효 숫자 : 6자리
  
  실수 중 정확도가 가장 높다.
  실수 중 연산이 가장 느리다.
  
    정확해야 하는 경우, 대개 사용된다.
  
  예시 : 정점 위치, UV, 복합 스칼라 연산




[2] half

  16비트
  유효 숫자 : 3자리
  
    표현 범위 : -60,000.0 ~ +60,000.0
  
  예시 : 방향 벡터, HDR 색상




[3] fixed

  11비트
  정밀도 : 1/256
  
    표현 범위 : -2.0 ~ +2.0
  
  연산이 가장 빠르다.
  
    작은 범위에서 한정된 LDR 색상 등에 사용된다.
  
  예시 : Albedo, Emission, Normal




Ref...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 - Vert/Frag 쉐이더에서 Receive Shadow, Cast Shadow 구현하기</title>
    <link href="https://rito15.github.io/posts/unity-shader-receive-and-cast-shadow/" rel="alternate" type="text/html" title="유니티 - Vert/Frag 쉐이더에서 Receive Shadow, Cast Shadow 구현하기" />
    <published>2021-10-07T00:01:00+09:00</published>
  
    <updated>2021-10-07T00:01:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-shader-receive-and-cast-shadow/</id>
    <content src="https://rito15.github.io/posts/unity-shader-receive-and-cast-shadow/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Shader Study" />
    
  

  
    <summary>
      





      Surface Shader


  쉐이더를 빠르게 작성할 수 있도록 다양한 편의를 제공한다.
  Surface 쉐이더 함수는 #pragma surface Surface쉐이더함수명으로 등록한다.
  미리 만들어진 라이팅을 간편히 적용할 수 있다.
  커스텀 라이트를 작성하는 것도 어렵지 않다.
  Receive Shadow, Cast Shadow는 자동으로 적용된다.
  Surface 쉐이더 함수는 기본적으로 Fragment 쉐이더 함수에 대응되며, 필요하다면 Vertex 쉐이더 함수를 따로 추가할 수 있다.





   
Surface Shader Example


  Shader "Custom/BasicSurfaceShader"
{
    Properties
    {
        _Color (...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# 배열에 같은 값을 넣으면서 선언하기</title>
    <link href="https://rito15.github.io/posts/cs-memo-linq/" rel="alternate" type="text/html" title="C# 배열에 같은 값을 넣으면서 선언하기" />
    <published>2021-10-06T22:00:00+09:00</published>
  
    <updated>2021-10-06T22:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-memo-linq/</id>
    <content src="https://rito15.github.io/posts/cs-memo-linq/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      Memo


// 인덱스 0부터 99까지 정수 1로 채우기
int[] arr = Enumerable.Repeat(1, 100).ToArray();


물론 LINQ를 쓰는 만큼, 중간 버퍼의 가비지는 감안해야 한다.



.NET 5.0 버전이라면 Array.Fill() 메소드를 사용하면 된다.

int[] arr = new int[100];
Array.Fill(arr, 1); // 배열 전체에 1로 채우기


    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 - 컴퓨트 버퍼를 통한 GPU 인스턴싱</title>
    <link href="https://rito15.github.io/posts/unity-compute-buffer-gpu-instancing/" rel="alternate" type="text/html" title="유니티 - 컴퓨트 버퍼를 통한 GPU 인스턴싱" />
    <published>2021-10-06T15:15:00+09:00</published>
  
    <updated>2021-10-07T01:08:09+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-compute-buffer-gpu-instancing/</id>
    <content src="https://rito15.github.io/posts/unity-compute-buffer-gpu-instancing/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Shader Study" />
    
  

  
    <summary>
      





      GPU Instancing


[1] 컴퓨트 버퍼 - 메시 데이터

  그려낼 메시의 정보를 컴퓨트 버퍼에 저장한다.
  컴퓨트 버퍼의 stride는 4 byte(sizeof(uint))이다.
  컴퓨트 버퍼의 크기는 20 byte(uint 5개)이며, 각각의 데이터는 메시에 대한 정보를 담고 있다.


Mesh mesh;                     // 그려낼 메시
int subMeshIndex = 0;          // 기본 : 0
int instanceCount = 100_000;   // 생성할 인스턴스의 개수
uint[] argsData = new uint[5]; // 메시 데이터

argsData[0] = (uint)mesh.GetIndexCount(subMeshIndex);
a...
    </summary>
  

  </entry>

</feed>



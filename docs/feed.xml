

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-10-21T16:11:27+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>게임 수학 - 벡터의 내적과 외적</title>
    <link href="https://rito15.github.io/posts/game-math-dot-cross/" rel="alternate" type="text/html" title="게임 수학 - 벡터의 내적과 외적" />
    <published>2021-10-21T16:00:00+09:00</published>
  
    <updated>2021-10-21T16:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/game-math-dot-cross/</id>
    <content src="https://rito15.github.io/posts/game-math-dot-cross/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Memo" />
    
    <category term="Game Mathematics" />
    
  

  
    <summary>
      





      내적


특징


  내적은 벡터의 차원에 관계 없이, 동일한 차원의 벡터끼리 가능하다.




주어진 벡터

\[A = (a_{x}, a_{y}, a_{z})\]

\[B = (b_{x}, b_{y}, b_{z})\]



내적 연산

\[A\cdotB = a_{x}\cdotBb_{x} + a_{y}\cdotBb_{y} + a_{z}\cdotBb_{z}\]



내적의 활용


[1] 두 벡터의 각도 관계 판별



[2] 두 벡터의 사잇각 계산



[3] 투영 벡터 계산



외적


특징


  벡터의 외적은 3차원 벡터끼리만 가능하다.




주어진 벡터

\[A = (a_{x}, a_{y}, a_{z})\]

\[B = (b_{x}, b_{y}, b_{z})\]



외적 연산

\[A X ...
    </summary>
  

  </entry>

  
  <entry>
    <title>게임 수학 - 선과 평면, 정점 보간</title>
    <link href="https://rito15.github.io/posts/game-math-line-plane-vertex/" rel="alternate" type="text/html" title="게임 수학 - 선과 평면, 정점 보간" />
    <published>2021-10-20T21:00:00+09:00</published>
  
    <updated>2021-10-20T21:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/game-math-line-plane-vertex/</id>
    <content src="https://rito15.github.io/posts/game-math-line-plane-vertex/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Memo" />
    
    <category term="Game Mathematics" />
    
  

  
    <summary>
      





      3D 게임 공간의 확장


  벡터 공간 : 이동 벡터를 표현(w가 항상 0)
  아핀 공간 : 위치 벡터를 표현(w가 항상 1)




특징

  벡터와 벡터는 더할 수 있다.
  벡터와 점을 더하면 w = 1이므로 점이 된다.
  점과 점을 더하면 w = 2가 되어 아핀 공간을 벗어나므로, 더할 수 없다.




아핀 조합(Affine Combination)


\[a + b = 1\]

\[P = aP_{1} + bP_{2}\]

\[P = aP_{1} + (1 - a)P_{2}\]


  점 P는 (x, y, z, 1)인 아핀 공간의 위치 벡터
  아핀 조합 : 아핀 공간의 두 점을 더했을 때의 결과가 아핀 공간의 점(w = 1)이 됨을 보장하는 공식




두 개의 점을 이용해 선 표현하기

...
    </summary>
  

  </entry>

  
  <entry>
    <title>Raycast to AABB</title>
    <link href="https://rito15.github.io/posts/raycast-to-aabb/" rel="alternate" type="text/html" title="Raycast to AABB" />
    <published>2021-10-19T03:00:00+09:00</published>
  
    <updated>2021-10-20T17:49:46+09:00</updated>
  
    <id>https://rito15.github.io/posts/raycast-to-aabb/</id>
    <content src="https://rito15.github.io/posts/raycast-to-aabb/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Algorithm" />
    
    <category term="Algorithms" />
    
  

  
    <summary>
      





      레이캐스트(Raycast)



  공간 상의 한 점에서부터 목표 지점까지 가상의 광선을 발사하여, 광선에 닿는 물체의 표면을 검출한다.




AABB



  
    Axis-Aligned Bounding Box
  
  
    여섯 면이 모두 각각 X, Y, Z 축에 정렬된 형태의 육면체
  
  
    중심 좌표(Vector3)와 각 축의 크기(Vector3) 또는
최소 좌표(Vector3)와 최대 좌표(Vector3)를 통해 정의할 수 있다.
  




Raycast to AAP



  AAP : Axis-Aligned Plane




육면체는 6개의 평면으로 이루어져 있다.

AABB 역시 6개의 평면으로 이루어져 있는데,

Axis-Aligned라는 특성 덕분에 각 평면에 대한 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 - 한 번씩만 실행되는 메소드들 순서 정리</title>
    <link href="https://rito15.github.io/posts/unity-initialization-methods/" rel="alternate" type="text/html" title="유니티 - 한 번씩만 실행되는 메소드들 순서 정리" />
    <published>2021-10-16T00:01:00+09:00</published>
  
    <updated>2021-10-21T02:57:10+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-initialization-methods/</id>
    <content src="https://rito15.github.io/posts/unity-initialization-methods/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo - Shorts" />
    
  

  
    <summary>
      





      Note


  실행되는 순서대로 작성




Methods


[1] [InitializeOnEnterPlayMode]

  
    Docs
  
  namespace UnityEditor
  메소드 애트리뷰트
  
    정적 메소드에 사용할 수 있다.
  
  플레이 모드에 진입하고, Awake()가 호출되기 전에 딱 1회 실행된다.
    
      씬을 재시작할 때는 실행되지 않는다.
    
  
  컴포넌트로 넣지 않고, 스크립트로만 존재해도 실행된다.


[InitializeOnEnterPlayMode]
private static void Method()
{
    // ...
}




[2] [InitializeOnLoad]

  
    Docs
  
  namespace Uni...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 - 에디터에서 스크립트로 태그, 레이어 추가하기</title>
    <link href="https://rito15.github.io/posts/unity-add-tag-or-layer-in-script/" rel="alternate" type="text/html" title="유니티 - 에디터에서 스크립트로 태그, 레이어 추가하기" />
    <published>2021-10-15T17:00:00+09:00</published>
  
    <updated>2021-10-15T17:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-add-tag-or-layer-in-script/</id>
    <content src="https://rito15.github.io/posts/unity-add-tag-or-layer-in-script/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor Memo" />
    
  

  
    <summary>
      





      Note


프로젝트의 일부를 다른 프로젝트로 옮기는 경우,

특정 씬에서만 사용하는 태그 또는 레이어가 존재할 수 있다.

그런데 옮긴 프로젝트에서 해당 태그 또는 레이어가 존재하지 않으면

직접 추가해줘야 하므로 번거롭다.

따라서 아래 소스 코드를 통해 이를 자동화할 수 있다.



Source Code


using UnityEngine;
using UnityEditor;

public static class EditorTagLayerHelper
{
    /// &amp;lt;summary&amp;gt; 태그 중복 확인 및 추가 &amp;lt;/summary&amp;gt;
    [System.Diagnostics.Conditional("UNITY_EDITOR")]
    public static void AddNewTa...
    </summary>
  

  </entry>

</feed>



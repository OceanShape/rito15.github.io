

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-02-11T05:20:25+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>OpenGL 공부 - 14</title>
    <link href="https://rito15.github.io/posts/opengl-study-14/" rel="alternate" type="text/html" title="OpenGL 공부 - 14" />
    <published>2021-02-10T15:20:00+09:00</published>
  
    <updated>2021-02-10T15:20:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/opengl-study-14/</id>
    <content src="https://rito15.github.io/posts/opengl-study-14/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="OpenGL" />
    
    <category term="OpenGL Study" />
    
  

  
    <summary>
      





      목표


  Model Matrix에 대한 이해
  이동, 회전, 크기 변경




공부 내용


공통

glm의 모델 매트릭스를 선언하는 것으로 시작한다.

glm::mat modelMatrix(1.0f);


openGL의 Transformation은 기본적으로 4x4 행렬과 vec3로 이루어진다.

4x4 행렬과 곱해지려면 벡터 또한 vec4여야 하므로, vec3를 전달하면 내부적으로 vec4(vec3, 1.)을 만들어 연산한다.

변환행렬은 서로 곱하여 하나의 변환행렬로 사용할 수 있다.

그런데 만약 이동행렬 뒤에 크기행렬을 곱하면 이동값 또한 크기가 변하기 때문에

이동, 회전, 크기 행렬을 곱하여 사용할 때는 크기, 회전, 이동 순서로 행렬을 곱하여 사용한다.



크기(Scale)



...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 에디터 종료 확인 다이얼로그 만들기</title>
    <link href="https://rito15.github.io/posts/unity-editor-exit-dialog/" rel="alternate" type="text/html" title="유니티 에디터 종료 확인 다이얼로그 만들기" />
    <published>2021-02-10T13:50:00+09:00</published>
  
    <updated>2021-02-10T13:50:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-editor-exit-dialog/</id>
    <content src="https://rito15.github.io/posts/unity-editor-exit-dialog/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      Memo


기본적으로 유니티 에디터를 종료할 때는 확인창이 뜨지 않고 바로 종료된다.

만약 실수로 닫기 버튼을 눌러버린다면 그대로 종료되어 버린다.

그런데 유니티 에디터는 에디터의 종료도 이벤트로 구분하여, 메소드를 추가할 수 있도록 구현해놓았기 때문에

이를 이용해 에디터의 종료를 시도할 경우 확인창을 띄우도록 할 수 있다.



[InitializeOnLoad]
public class EditorExitDialog
{
    static EditorExitDialog()
    {
        EditorApplication.wantsToQuit += 
            () =&amp;gt; EditorUtility.DisplayDialog("Unity Editor", "Are you sure...
    </summary>
  

  </entry>

  
  <entry>
    <title>OpenGL 공부 - 13 - Texture</title>
    <link href="https://rito15.github.io/posts/opengl-study-13/" rel="alternate" type="text/html" title="OpenGL 공부 - 13 - Texture" />
    <published>2021-02-10T01:30:00+09:00</published>
  
    <updated>2021-02-10T01:30:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/opengl-study-13/</id>
    <content src="https://rito15.github.io/posts/opengl-study-13/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="OpenGL" />
    
    <category term="OpenGL Study" />
    
  

  
    <summary>
      





      목표


  폴리곤에 텍스쳐 씌워보기(1장, 여러 장)




1. 텍스쳐 한 장 사용


이미지 준비

  프로젝트 디렉토리 내에 Images 폴더를 만들고 PNG 이미지 파일을 준비한다.




소스코드 작성


  위치 : VertexAttribPointer ~ Main Loop 사이



[1] 이미지 로드

int imageWidth = 0;
int imageHeight = 0;
unsigned char* image = SOIL_load_image("Images/MoonCat.png",
    &amp;amp;imageWidth, &amp;amp;imageHeight, NULL, SOIL_LOAD_RGBA);



[2] 텍스쳐 객체 생성 및 바인드

GLuint texture0; // Texture ID
...
    </summary>
  

  </entry>

  
  <entry>
    <title>Custom Mouse Events</title>
    <link href="https://rito15.github.io/posts/unity-custom-mouse-events/" rel="alternate" type="text/html" title="Custom Mouse Events" />
    <published>2021-02-08T21:54:00+09:00</published>
  
    <updated>2021-02-08T21:54:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-custom-mouse-events/</id>
    <content src="https://rito15.github.io/posts/unity-custom-mouse-events/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Toys" />
    
  

  
    <summary>
      





      구현 동기

유니티 모노비헤이비어는 OnMouse로 시작하는 이벤트 메소드들을 작성하여 사용할 수 있습니다.

이 이벤트 메소드들은 레이캐스트 기반으로 동작하며, 해당 마우스 동작이 발생하면 메소드가 호출됩니다.

하지만 여러가지 단점들이 있습니다.


  마우스 좌클릭에 대해서만 동작합니다.
  이벤트 메소드 작성 시, 비워놓거나 해당 이벤트가 발생하지 않는 상황에도 성능을 소모합니다.
  컴포넌트를 비활성화하거나, 심지어 게임오브젝트를 비활성화해도 성능을 소모합니다.
  마우스가 닿은 정확한 위치를 알 수 없습니다.
  대상을 레이어로 필터링할 수 없습니다.


이런 단점들을 극복하고자 새롭게 구현하였습니다.



동작 원리



  MouseEventCaller 컴포넌트가 매 프레임 마우스 위치에...
    </summary>
  

  </entry>

  
  <entry>
    <title>OpenGL 공부 - 12 - New Beginning 3</title>
    <link href="https://rito15.github.io/posts/opengl-study-12/" rel="alternate" type="text/html" title="OpenGL 공부 - 12 - New Beginning 3" />
    <published>2021-02-08T16:12:00+09:00</published>
  
    <updated>2021-02-10T03:35:04+09:00</updated>
  
    <id>https://rito15.github.io/posts/opengl-study-12/</id>
    <content src="https://rito15.github.io/posts/opengl-study-12/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="OpenGL" />
    
    <category term="OpenGL Study" />
    
  

  
    <summary>
      





      목표


  기본 렌더링 세팅
  기본 도형 렌더링




공부 내용


테스트를 위해 렌더링 옵션들 설정

// main.cpp - in main()

glEnable(GL_DEPTH_TEST);

glEnable(GL_CULL_FACE);
glCullFace(GL_BACK);
glFrontFace(GL_CCW); // 시계 반대 방향으로 구성된 폴리곤을 전면으로 설정

// 픽셀 블렌딩 연산 지정
glEnable(GL_BLEND);
glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

// GL_LINE : 폴리곤을 선으로 그리기
// GL_FILL : 폴리곤을 색상으로 채우기
glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);



...
    </summary>
  

  </entry>

</feed>



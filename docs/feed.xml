

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-06-19T20:16:41+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>런타임에 큰 성능 저하 없이 텍스쳐에 그림 그리기</title>
    <link href="https://rito15.github.io/posts/unity-how-to-paint-texture/" rel="alternate" type="text/html" title="런타임에 큰 성능 저하 없이 텍스쳐에 그림 그리기" />
    <published>2021-06-19T17:17:00+09:00</published>
  
    <updated>2021-06-19T17:17:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-how-to-paint-texture/</id>
    <content src="https://rito15.github.io/posts/unity-how-to-paint-texture/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      텍스쳐의 특정 픽셀 색상 변경하기


텍스쳐의 특정 픽셀 색상을 변경하는건 매우 간단하다.



[1] 텍스쳐의 Read/Write Enabled를 체크한다.

[2] 대상 마테리얼에서 텍스쳐를 가져온다.

[3] SetPixel() 메소드로 원하는 픽셀의 색상을 변경한다.

[4] Apply() 메소드로 적용한다.



하지만 메모리에 적재된 텍스쳐를 저렇게 직접 수정하는건

CPU 입장에서 매우 부담되는 일이므로 성능 저하가 막심하다.



렌더 텍스쳐를 거쳐 색상 변경하기


위와 같은 큰 성능 저하 없이 런타임에 텍스쳐 픽셀을 수정하려면,

렌더 텍스쳐를 거쳐야 한다.



[1] 렌더 텍스쳐를 준비하거나 새로 생성한다.

[2] 대상 마테리얼의 텍스쳐 타입 프로퍼티에 렌더 텍스쳐를 적용한다.
...
    </summary>
  

  </entry>

  
  <entry>
    <title>Texture Painter(텍스쳐에 그림 그리기)</title>
    <link href="https://rito15.github.io/posts/unity-texture-painter/" rel="alternate" type="text/html" title="Texture Painter(텍스쳐에 그림 그리기)" />
    <published>2021-06-19T04:32:00+09:00</published>
  
    <updated>2021-06-19T04:32:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-texture-painter/</id>
    <content src="https://rito15.github.io/posts/unity-texture-painter/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Toys" />
    
  

  
    <summary>
      





      Summary


  실시간으로 마우스 클릭, 드래그를 통해 게임 오브젝트의 텍스쳐에 그림 그리기




How To Use


그림 그려질 대상 게임오브젝트


  
    알맞은 콜라이더를 넣는다.
  
  
    Rito/PaintTexture 쉐이더로 생성한 마테리얼을 적용한다.
  
  
    TexturePaintTarget 컴포넌트를 추가는다.
  




브러시


  
    씬에 빈 게임오브젝트를 생성하고 TexturePaintBrush 컴포넌트를 추가는다.
  
  
    Brush Size로 브러시의 크기를 조절할 수 있다.
  
  
    Brush Texture로 브러시의 모양으로 사용할 텍스쳐를 등록할 수 있다.
등록하지 않은 경우, 기본 브러시로 자동 초기화된다.
 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>Strategy Pattern(전략 패턴)</title>
    <link href="https://rito15.github.io/posts/strategy-pattern/" rel="alternate" type="text/html" title="Strategy Pattern(전략 패턴)" />
    <published>2021-06-17T21:12:00+09:00</published>
  
    <updated>2021-06-19T00:34:25+09:00</updated>
  
    <id>https://rito15.github.io/posts/strategy-pattern/</id>
    <content src="https://rito15.github.io/posts/strategy-pattern/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Algorithm" />
    
    <category term="Design Pattern" />
    
  

  
    <summary>
      





      Strategy Pattern(전략 패턴)


설명


  
    행동 패턴(Behaviour Pattern)의 일종
  
  
    알고리즘을 클래스화하여, 실행 중에 알고리즘(전략)을 통째로 교체하며 사용한다. (핵심)
  
  
    if-else 또는 switch-case 구문을 통해 어떤 기준에 따라 분기로 작성하던 기능을 각각 클래스화시킨다.
  
  
    베이스 클래스를 각각 상속받는 전략 클래스들과 이를 교체하며 사용하는 클래스로 이루어진다.
  
  
    각 전략 클래스는 베이스 클래스를 통해 통일된 행동을 기반으로 구현해야 한다. (중요)
  
  
    필요에 따라 각 전략 클래스를 싱글톤화하여 재사용할 수 있다.
  
  
    전략 클래스 내부에서 컨텍스트의 상태...
    </summary>
  

  </entry>

  
  <entry>
    <title>CIL 코드 뜯어보기</title>
    <link href="https://rito15.github.io/posts/cs-memo-show-cil/" rel="alternate" type="text/html" title="CIL 코드 뜯어보기" />
    <published>2021-06-15T20:00:00+09:00</published>
  
    <updated>2021-06-15T20:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-memo-show-cil/</id>
    <content src="https://rito15.github.io/posts/cs-memo-show-cil/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      1. 소스코드 컴파일


  컴파일을 완료하고 .exe 또는 .dll 파일을 생성한다.




2. 디스어셈블러 실행


C:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.8 Tools


이런 경로로 들어가서

ildasm.exe 파일을 찾아 실행한다.

경로는 버전마다 조금씩 차이가 있다.



3. 대상 어셈블리 열기


파일 - 열기를 통해 앞서 컴파일 완료한 파일을 열어준다.





4. CIL 코드 확인


3에서 원하는 메소드를 찾아 더블클릭한다.





주의사항



  디스어셈블러에서 특정 어셈블리를 열어둔 상태에서는 해당 어셈블리를 컴파일 할 수 없으므로, 다시 컴파일하고 싶다면 디스어셈블러를 꺼야 한다.



    </summary>
  

  </entry>

  
  <entry>
    <title>Jekyll 블로그 만들기 간단 메모</title>
    <link href="https://rito15.github.io/posts/memo-init-jekyll-blog/" rel="alternate" type="text/html" title="Jekyll 블로그 만들기 간단 메모" />
    <published>2021-06-15T14:55:00+09:00</published>
  
    <updated>2021-06-16T17:11:21+09:00</updated>
  
    <id>https://rito15.github.io/posts/memo-init-jekyll-blog/</id>
    <content src="https://rito15.github.io/posts/memo-init-jekyll-blog/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Memo" />
    
  

  
    <summary>
      





      Start Jekyll Blog


1. Ruby 설치


  https://rubyinstaller.org/downloads/
  2.7.3




2. Jekyll Bundler 설치


  cmd 켰을 때 나오는 사용자 기본 경로에 설치


gem install jekyll bundler




3. 블로그용 깃헙 원격 리포 준비


  리포 이름은 닉네임.github.io




4. 로컬 리포 준비


  원격 리포랑 연결


git init
git add .
git commit -m "init"
git branch -M main
git remote add origin [깃헙 원격 리포 주소]
git push -u origin main




5. Jekyll 테마 다운로드


  
    h...
    </summary>
  

  </entry>

</feed>





<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-02-21T04:39:00+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>깃 로컬 리포지토리 초기 세팅하기</title>
    <link href="https://rito15.github.io/posts/memo-git-local-repo-initialization/" rel="alternate" type="text/html" title="깃 로컬 리포지토리 초기 세팅하기" />
    <published>2021-02-21T00:00:00+09:00</published>
  
    <updated>2021-02-21T00:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/memo-git-local-repo-initialization/</id>
    <content src="https://rito15.github.io/posts/memo-git-local-repo-initialization/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Memo" />
    
  

  
    <summary>
      





      조건



  
    깃헙 리포지토리를 새로 생성하는 경우
  
  
    아무런 파일도 만들지 않고 순수한 상태로 리포지토리를 만든 경우 1번에 해당하며,
  
  
    Readme.md, LICENCE, .gitignore 등의 파일을 만들었다면 2번에 해당한다.
  




1. 깃헙에 빈 리포지토리를 생성한 경우



  로컬 리포지토리로 사용할 디렉토리에는 다른 파일들 존재한다고 가정한다.



깃 로컬 리포지토리로 사용하겠다고 선언한다. (.git 폴더 생성)

git init



업로드할 파일들을 등록한다.

git add .



커밋을 등록한다.

git commit -m "내용"



원격 브랜치 이름을 main으로 지정한다.

git branch -M main



로컬 브...
    </summary>
  

  </entry>

  
  <entry>
    <title>스크립터블 오브젝트</title>
    <link href="https://rito15.github.io/posts/memo-modifiable-scriptable-object/" rel="alternate" type="text/html" title="스크립터블 오브젝트" />
    <published>2021-02-20T02:02:00+09:00</published>
  
    <updated>2021-02-20T02:02:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/memo-modifiable-scriptable-object/</id>
    <content src="https://rito15.github.io/posts/memo-modifiable-scriptable-object/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      형태


[CreateAssetMenu(fileName = "TestSO", menuName = "ScriptableObjects/Test", order = 1)]
public class TestScriptableObject : ScriptableObject
{
    public int value = 0;
}



  상단의 메뉴에서 [Assets] - [Create] - [ScriptableObjects] - [Test] 를 통해 생성 할 수 있게 된다.
  프로젝트 윈도우에서 우클릭하면 동일한 메뉴를 확인할 수 있다.




특징



  스크립터블 오브젝트를 참조하게 되면 동일한 값의 필드를 각각의 객체에서 중복된 형태로 사용하게 되는 것을 방지할 수 있다.
    
      예시 : 공통으로...
    </summary>
  

  </entry>

  
  <entry>
    <title>OpenGL 공부 - 23 - Mesh, GameObject Class, Multiple Objects</title>
    <link href="https://rito15.github.io/posts/opengl-study-23/" rel="alternate" type="text/html" title="OpenGL 공부 - 23 - Mesh, GameObject Class, Multiple Objects" />
    <published>2021-02-19T16:27:00+09:00</published>
  
    <updated>2021-02-19T16:27:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/opengl-study-23/</id>
    <content src="https://rito15.github.io/posts/opengl-study-23/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="OpenGL" />
    
    <category term="OpenGL Study" />
    
  

  
    <summary>
      





      목표


  프래그먼트 쉐이더 수정
  Mesh 클래스 작성
  GameObject 클래스 작성
  여러 개의 게임오브젝트 렌더링




1. 프래그먼트 쉐이더 수정


  
    각각의 계산이 독립적이고 순차적으로 수행될 수 있도록 변경한다.
  
  
    바뀐 구조
    
      
        1. 색상 계산(텍스쳐, 버텍스 컬러 등)
      
      
        2. 라이트 계산(디퓨즈, 스페큘러, 앰비언트 독립적으로)
      
      
        3. 최종 색상 조립(디퓨즈, 스페큘러, 앰비언트 독립적)
      
    
  




소스코드

// fragment_core.glsl

#version 440

#define saturate(x) clamp(x...
    </summary>
  

  </entry>

  
  <entry>
    <title>레이캐스트 성능 체크</title>
    <link href="https://rito15.github.io/posts/memo-raycast-performance/" rel="alternate" type="text/html" title="레이캐스트 성능 체크" />
    <published>2021-02-19T16:18:00+09:00</published>
  
    <updated>2021-02-19T16:18:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/memo-raycast-performance/</id>
    <content src="https://rito15.github.io/posts/memo-raycast-performance/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      조건

고정

  레이캐스트 시작점
  레이캐스트 방향
  반복 횟수 : 10만 회


변동

  레이캐스트 종류
  레이어마스크
  레이캐스트 거리
  레이캐스트 도형 크기(Sphere, Box)
  레이캐스트 히트 여부


결과




결론

성능에 영향을 주는 것

  레이캐스트 종류
  레이캐스트 히트 여부


성능에 영향을 주지 않는 것

  레이어마스크
  레이캐스트 거리
  레이캐스트 도형 크기(Sphere, Box)




추가 - Rigidbody.SweepTest


SweepTest ?

  콜라이더 표면으로부터 지정한 방향으로 일정 거리 이내에 다른 콜라이더가 존재하는지 검사하는 것


검사 조건

  
    검사 주체 콜라이더 : Sphere, Capsule, Box

    ...
    </summary>
  

  </entry>

  
  <entry>
    <title>커스텀 애트리뷰트</title>
    <link href="https://rito15.github.io/posts/memo-custom-attribute/" rel="alternate" type="text/html" title="커스텀 애트리뷰트" />
    <published>2021-02-19T03:55:00+09:00</published>
  
    <updated>2021-02-19T05:12:32+09:00</updated>
  
    <id>https://rito15.github.io/posts/memo-custom-attribute/</id>
    <content src="https://rito15.github.io/posts/memo-custom-attribute/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Csharp" />
    
    <category term="Csharp Memo" />
    
  

  
    <summary>
      





      필요 네임스페이스

using System;
using System.Linq;


1. 애트리뷰트 클래스 작성

[System.AttributeUsage(System.AttributeTargets.Method)]
public class CustomAttribute : System.Attribute
{
    public string Title { get; }

    public CustomAttribute(string t) =&amp;gt; Title = t;
}


2. 타겟 메소드에 애트리뷰트 장착

public class TargetClass
{
    [CustomAttribute("Title String")]
    public void TargetMethod()
    {

    }
}


3....
    </summary>
  

  </entry>

</feed>



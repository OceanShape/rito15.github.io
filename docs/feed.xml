

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-06-06T17:05:53+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>유니티 이벤트 함수는 어떻게 실행되는 것일까?</title>
    <link href="https://rito15.github.io/posts/unity-event-functions/" rel="alternate" type="text/html" title="유니티 이벤트 함수는 어떻게 실행되는 것일까?" />
    <published>2021-06-06T05:05:00+09:00</published>
  
    <updated>2021-06-06T05:05:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-event-functions/</id>
    <content src="https://rito15.github.io/posts/unity-event-functions/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      Unity Event Functions


유니티엔진에서 ‘스크립트’를 작성한다고 하면, 보통 MonoBahaviour를 상속받는 클래스의 스크립트를 작성하는 것을 떠올릴 것이다.

그리고 자연스럽게 이 클래스 내에 Awake(), Start(), Update() 등의 메소드를 작성하게 된다.

심지어 비주얼 스튜디오 같은 개발 환경에서는 이런 메소드들에 대해 자동 완성도 해주고, 메소드 위에는 Unity 메시지라는 글자도 띄워준다.

이런 메소드들은 ‘Unity Event Function’, ‘Unity Message’ 또는 ‘Magic Method’라고 불린다.



그런데 생각해보면 이 메소드들은 MonoBehaviour 또는 그 부모 클래스로부터 상속받은 메소드도 아닌데,

어떻게 유니티가 알아...
    </summary>
  

  </entry>

  
  <entry>
    <title>.NET 환경의 컴파일 - CLR, CIL, JIT, AOT</title>
    <link href="https://rito15.github.io/posts/cs-dotnet-compile/" rel="alternate" type="text/html" title=".NET 환경의 컴파일 - CLR, CIL, JIT, AOT" />
    <published>2021-06-06T04:43:00+09:00</published>
  
    <updated>2021-06-06T05:35:33+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-dotnet-compile/</id>
    <content src="https://rito15.github.io/posts/cs-dotnet-compile/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      닷넷 환경의 컴파일 과정


예전의 C, C++의 경우 개별 환경이 프로그램의 실행 시간에 영향을 미치는 문제가 있었다.

하지만 Java가 나오면서 컴파일된 바이트코드는 윈도우, 리눅스, 그 어떤 실행환경이든 JVM만 실행 가능하다면 실행할 수 있다는 장점을 통해 인기를 끌었고,

마이크로소프트는 이를 이용해 기존 문제를 해결할 수 있도록 .NET 환경에 가상 머신을 만들어서

.NET 환경의 언어로 개발된 IL(Intermediate Language, 중간 언어) 코드들은 .NET Framework가 설치된 어떠한 환경에서도 실행할 수 있도록 하였다.

CLR(Common Language Runtime, 공통 언어 런타임)은 이 가상머신의 구성요소 중 하나이며,

CIL(Common Intermid...
    </summary>
  

  </entry>

  
  <entry>
    <title>Method Chaining &amp; Generic</title>
    <link href="https://rito15.github.io/posts/method-chaning-pattern/" rel="alternate" type="text/html" title="Method Chaining &amp; Generic" />
    <published>2021-05-28T22:02:00+09:00</published>
  
    <updated>2021-05-30T18:51:30+09:00</updated>
  
    <id>https://rito15.github.io/posts/method-chaning-pattern/</id>
    <content src="https://rito15.github.io/posts/method-chaning-pattern/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Algorithm" />
    
    <category term="Design Pattern" />
    
  

  
    <summary>
      





      메소드 체이닝 패턴


특징

  메소드가 객체를 반환하는 형태로 작성한다.
  문장을 마치지 않고 메소드 호출을 이어나갈 수 있다.
  가독성을 향상시킬 수 있다.




주의사항

  한 문장에 여러번의 메소드 호출이 존재할 수 있으므로, 에러가 발생할 경우 정확한 지점을 한 번에 찾기 힘들다.
  C# 구조체의 메소드를 체이닝으로 구현할 경우, 매 번 구조체 전체의 복제가 발생하므로 바람직하지 않다.




예시

class Box
{
    private float width;
    private float height;

    public Box SetWidth(float width)
    {
        this.width = width;
        return this;
    ...
    </summary>
  

  </entry>

  
  <entry>
    <title>FBX Exporter</title>
    <link href="https://rito15.github.io/posts/unity-fbx-exporter/" rel="alternate" type="text/html" title="FBX Exporter" />
    <published>2021-05-27T17:02:00+09:00</published>
  
    <updated>2021-05-27T17:02:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-fbx-exporter/</id>
    <content src="https://rito15.github.io/posts/unity-fbx-exporter/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      Summary


  유니티 내에 존재하는 메시를 .fbx 파일로 추출해주는 애셋




Import



  
    [Window] - [Package Manager]
  
  
    좌측 상단 [Unity Registry] 설정
  
  
    FBX Exporter 검색 및 Install
  






How to Use



  
    하이라키에서 내보낼 게임오브젝트에 우클릭 후 Export To FBX 클릭
  
  
    Export Name, Export Path 설정 후 Export
  






Old Version



  https://github.com/unity3d-jp/FbxExporter
  FbxExporter.zip



    </summary>
  

  </entry>

  
  <entry>
    <title>에디터 GUI 이벤트 모음</title>
    <link href="https://rito15.github.io/posts/unity-editor-gui-events/" rel="alternate" type="text/html" title="에디터 GUI 이벤트 모음" />
    <published>2021-05-25T02:22:00+09:00</published>
  
    <updated>2021-05-25T02:22:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-editor-gui-events/</id>
    <content src="https://rito15.github.io/posts/unity-editor-gui-events/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor" />
    
  

  
    <summary>
      





      Mouse Over Control



  특정 컨트롤에 마우스가 위치해 있는지 확인


[1] Layout 요소가 아닌 경우

Rect rect = /* Set Rect */;

EditorGUI.LabelField(rect, "Label"); // Draw Field Control

bool mouseOver = rect.Contains(Event.current.mousePosition);


[2] Layout 요소인 경우

EditorGUILayout.TextField("Text");

bool mouseOver = GUILayoutUtility.GetLastRect()
                .Contains(Event.current.mousePosition);




Mouse Down...
    </summary>
  

  </entry>

</feed>



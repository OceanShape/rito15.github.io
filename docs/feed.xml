

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-03-08T18:47:18+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Regex (정규표현식)</title>
    <link href="https://rito15.github.io/posts/csharp-memo-regex/" rel="alternate" type="text/html" title="Regex (정규표현식)" />
    <published>2021-03-08T17:42:00+09:00</published>
  
    <updated>2021-03-08T17:42:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/csharp-memo-regex/</id>
    <content src="https://rito15.github.io/posts/csharp-memo-regex/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Csharp" />
    
    <category term="Csharp Memo" />
    
  

  
    <summary>
      





      Memo


Using

using System.Text.RegularExpressions;




스트링의 오른쪽에서부터 탐색

Regex.Match(string, pattern, RegexOptions.RightToLeft)




찾은 문자열 주변을 변경 (그룹 사용)

string strExample = "&amp;lt;12&amp;gt; GameObject [23]  ";
string pattern = @"[\s\[\{\(\&amp;lt;]+" + @"([0-9]+)" + @"[\s\]\}\)\&amp;gt;]+";
string replacement = @"($1)";
string result = Regex.Replace(strExample, pattern, replacement);



  
    패턴에서 “( ~ )...
    </summary>
  

  </entry>

  
  <entry>
    <title>컴파일, 게임 시작 시 실행되는 애트리뷰트 정리</title>
    <link href="https://rito15.github.io/posts/unity-memo-init-events/" rel="alternate" type="text/html" title="컴파일, 게임 시작 시 실행되는 애트리뷰트 정리" />
    <published>2021-03-08T03:03:00+09:00</published>
  
    <updated>2021-03-08T03:03:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-memo-init-events/</id>
    <content src="https://rito15.github.io/posts/unity-memo-init-events/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      공통 특징



  
    클래스 또는 메소드 상단에 애트리뷰트를 명시한다.
  
  
    컴포넌트로 넣지 않고, 스크립트로만 존재해도 실행된다.
  
  
    정적 클래스나 상속에 관계 없이 동작한다.
  
  
    메소드 애트리뷰트는 정적 메소드에만 동작한다.
  




컴파일, 플레이모드 진입 시 실행


Note

  EditorApplication.isPlaying으로 현재 에디터 모드를 구분하여 활용할 수 있다.




[InitializeOnLoad]


  
    using UnityEditor;
  
  
    클래스 애트리뷰트
  
  
    정적 생성자가 호출되므로, 정적 생성자에 원하는 코드를 작성한다.
  
  
    실행 타이밍 : 컴파일, 플레이모드 진입...
    </summary>
  

  </entry>

  
  <entry>
    <title>Scene Auto Saver (현재 씬 자동 저장)</title>
    <link href="https://rito15.github.io/posts/unity-toy-scene-auto-saver/" rel="alternate" type="text/html" title="Scene Auto Saver (현재 씬 자동 저장)" />
    <published>2021-03-08T02:22:00+09:00</published>
  
    <updated>2021-03-08T16:48:55+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-toy-scene-auto-saver/</id>
    <content src="https://rito15.github.io/posts/unity-toy-scene-auto-saver/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Toys" />
    
  

  
    <summary>
      





      Note


  
    일정 시간 주기로 현재 활성화된 씬을 자동 저장한다.
  
  
    씬이 저장되지 않은 상태일 때만 타이머가 동작한다.
  


How To Use


  스크립트 2개를 모두 다운로드 받아 유니티 프로젝트에 넣는다.
  
    [Window] - [Rito] - [Scene Auto Saver]를 통해 윈도우를 연다.
  
  On에 체크/해제하여 기능 실행 여부를 설정할 수 있다.
  Show Log 옵션으로 자동 저장 시 로그 출력 여부를 설정할 수 있다.
  Save Cycle 옵션으로 저장 주기를 설정할 수 있다. (기본 : 10초, 최소 : 5초)




Preview




Download


  Scene Auto Saver.zip


Source Code
...
    </summary>
  

  </entry>

  
  <entry>
    <title>커스텀 에디터 윈도우</title>
    <link href="https://rito15.github.io/posts/unity-memo-custom-editor-window/" rel="alternate" type="text/html" title="커스텀 에디터 윈도우" />
    <published>2021-03-08T00:00:00+09:00</published>
  
    <updated>2021-03-08T00:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-memo-custom-editor-window/</id>
    <content src="https://rito15.github.io/posts/unity-memo-custom-editor-window/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      Note


  에디터 윈도우를 직접 만들어 사용할 수 있다.


Preview






Source Code Example


#if UNITY_EDITOR

using UnityEngine;
using UnityEditor;

public class ExampleWindow : EditorWindow
{
    private bool boolValue;
    private float floatValue;
    private Vector3 vector3Value;

    [MenuItem("Window/Rito/Example Window")] // 메뉴 등록
    private static void Init()
    {
        // 현재 활성화된 윈도우 가져오며, 없으면 새로 생성
...
    </summary>
  

  </entry>

  
  <entry>
    <title>bool 타입 필드를 인스펙터에서 버튼처럼 사용하기</title>
    <link href="https://rito15.github.io/posts/unity-memo-bool-as-a-button/" rel="alternate" type="text/html" title="bool 타입 필드를 인스펙터에서 버튼처럼 사용하기" />
    <published>2021-03-07T01:33:00+09:00</published>
  
    <updated>2021-03-08T03:55:02+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-memo-bool-as-a-button/</id>
    <content src="https://rito15.github.io/posts/unity-memo-bool-as-a-button/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      인스펙터의 버튼


컴포넌트의 인스펙터에서 버튼을 사용하고 싶을 때가 있다.

예를 들면 플레이 모드로 진입하지 않고 에디터 모드에서 메소드를 바로 호출 하고 싶을 때.

그리고 실제로 커스텀 에디터를 이용해 버튼을 만들 수도 있다.



하지만 잠깐 테스트용으로 쓰려는데 스크립트 하나 더 만들고, 커스텀 에디터 선언하고, …

심지어 에디터 GUI좀 쓰려면 EditorGUI, EditorUtility, EditorGUILayout, GUIUtility, GUILayout, … 뭐가 이렇게 다양하고 헷갈리게 만들어 놨는지..

어쨌든 커스텀 에디터 만들어서 if(GUILayout.Button()){} 으로 버튼 하나 달아서 사용할 수 있지만,

가끔씩 이게 참 번거롭다.



bool 필드를 버튼처럼 ...
    </summary>
  

  </entry>

</feed>



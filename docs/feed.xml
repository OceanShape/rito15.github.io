

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-10-03T23:18:40+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>레이캐스트 - 평면(Plane)</title>
    <link href="https://rito15.github.io/posts/raycast-to-plane/" rel="alternate" type="text/html" title="레이캐스트 - 평면(Plane)" />
    <published>2021-10-03T22:22:00+09:00</published>
  
    <updated>2021-10-03T22:22:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/raycast-to-plane/</id>
    <content src="https://rito15.github.io/posts/raycast-to-plane/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Algorithm" />
    
    <category term="Algorithms" />
    
  

  
    <summary>
      





      레이캐스트(Raycast)



  공간 상의 한 점에서부터 목표 지점까지 가상의 광선을 발사하여, 광선에 닿는 물체의 표면을 검출한다.




평면(Plane)




평면 위의 점 P와 평면의 법선 벡터 N을 알고 있으면 평면을 정의할 수 있으며,

평면 위의 임의의 점 X를 가정하여 dot(N, P - X) = 0을 통해 평면의 방정식을 정의할 수 있다.



직선과 평면의 교차점 찾기


점 A에서 점 B를 향해 광선을 발사하여, 광선과 평면이 만나는 지점을 찾는다.



위와 같이 A, B, P, N이 주어졌을 때,

길이 d를 알아내고 이를 통해 직선과 평면의 교차점 C를 알아내야 한다.



평면의 정의에 의해 다음과 같은 식을 얻을 수 있다.

\[dot(N, P - C) = 0\]


...
    </summary>
  

  </entry>

  
  <entry>
    <title>레이캐스트 - 구체(Sphere)</title>
    <link href="https://rito15.github.io/posts/raycast-to-sphere/" rel="alternate" type="text/html" title="레이캐스트 - 구체(Sphere)" />
    <published>2021-10-02T02:02:00+09:00</published>
  
    <updated>2021-10-03T23:16:22+09:00</updated>
  
    <id>https://rito15.github.io/posts/raycast-to-sphere/</id>
    <content src="https://rito15.github.io/posts/raycast-to-sphere/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Algorithm" />
    
    <category term="Algorithms" />
    
  

  
    <summary>
      





      레이캐스트(Raycast)



  공간 상의 한 점에서부터 목표 지점까지 가상의 광선을 발사하여, 광선에 닿는 물체의 표면을 검출한다.




직선과 구체 표면의 교차점 찾기



  시작 지점에서부터 목표 지점으로 광선을 발사하여, 그 사이에서 광선과 교차하는 구체의 표면 지점을 찾아낸다.
  3차원에서 수행하면 구체, 2차원에서 수행하면 원(Circle)의 표면을 검출할 수 있다.




먼저, 주어진 조건은 다음과 같다.


  
    A : 레이캐스트 시작 위치
    B : 레이캐스트 종료 위치
    S : 구체 중심 위치
    r : 구체 반지름 길이
  






다음과 같은 공간상의 지점 C, D를 가정할 수 있다.


  
    C : 점 S에서 직선 AB에 내린 수선의 발
...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# 바이트 버퍼를 읽어서 구조체로 변환하기</title>
    <link href="https://rito15.github.io/posts/cs-byte-buffer-to-struct/" rel="alternate" type="text/html" title="C# 바이트 버퍼를 읽어서 구조체로 변환하기" />
    <published>2021-10-01T00:01:00+09:00</published>
  
    <updated>2021-10-01T03:36:11+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-byte-buffer-to-struct/</id>
    <content src="https://rito15.github.io/posts/cs-byte-buffer-to-struct/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      소스 코드


메소드




  


/// &amp;lt;summary&amp;gt; 바이트 버퍼를 읽어서 구조체로 변환하기 &amp;lt;/summary&amp;gt;
public static T? ByteBufferToStruct&amp;lt;T&amp;gt;(byte[] buffer, int offset) where T : struct
{
    int size = Marshal.SizeOf(typeof(T));

    if (buffer.Length - offset &amp;lt; size)
        return null;

    // Unmanaged Heap에 size만큼 메모리 할당
    IntPtr ptr = Marshal.AllocHGlobal(size);

    // buffer[offset]부터 size만큼 읽어서 p...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 쉐이더 - 빌보드(Vert/Frag)</title>
    <link href="https://rito15.github.io/posts/unity-shader-billboard/" rel="alternate" type="text/html" title="유니티 쉐이더 - 빌보드(Vert/Frag)" />
    <published>2021-09-30T21:00:00+09:00</published>
  
    <updated>2021-09-30T21:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-shader-billboard/</id>
    <content src="https://rito15.github.io/posts/unity-shader-billboard/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Shader Memo" />
    
  

  
    <summary>
      





      1. 일반


struct appdata
{
    float4 vertex : POSITION;
    float2 uv : TEXCOORD0;
};

struct v2f
{
    float4 vertex : SV_POSITION;
    float2 uv : TEXCOORD0;
};

float4 Billboard(float4 vertex)
{
    float3 camUpVec      =  normalize( UNITY_MATRIX_V._m10_m11_m12 );
    float3 camForwardVec = -normalize( UNITY_MATRIX_V._m20_m21_m22 );
    float3 camRightVec   =  normalize( UNITY_MATRIX_V._m00_m...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# Nullable</title>
    <link href="https://rito15.github.io/posts/cs-nullable/" rel="alternate" type="text/html" title="C# Nullable" />
    <published>2021-09-30T00:11:00+09:00</published>
  
    <updated>2021-09-30T00:11:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-nullable/</id>
    <content src="https://rito15.github.io/posts/cs-nullable/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Grammar" />
    
  

  
    <summary>
      





      null 허용 값 타입



  
    .Net Framework 2.0 버전부터 사용할 수 있다.
  
  
    Nullable&amp;lt;T&amp;gt; 또는 T? 꼴로 사용할 수 있다.
  
  
    null 값의 초기화를 허용한다.
  
  
    null을 허용한다고 해서 참조형이 되는 것은 아니고, 값 타입은 그대로 값 타입이다.
  
  
    힙에 할당되지 않고, 스택에 할당되는 것은 동일하다.
  




Nullable 클래스


  
    정적 클래스이다.
  
  
    변수를 선언할 수 없다.
  
  
    Nullable&amp;lt;T&amp;gt;와는 엄연히 다른 타입이며, 관련 API를 제공하기 위해 존재한다.
  




Nullable&amp;lt;T&amp;gt; 구조체


  
   ...
    </summary>
  

  </entry>

</feed>





<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-03-12T04:22:29+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>컴포넌트의 인스펙터 내 순서를 맨 위로 올리기</title>
    <link href="https://rito15.github.io/posts/unity-editor-component-on-top/" rel="alternate" type="text/html" title="컴포넌트의 인스펙터 내 순서를 맨 위로 올리기" />
    <published>2021-03-12T04:04:00+09:00</published>
  
    <updated>2021-03-12T04:04:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-editor-component-on-top/</id>
    <content src="https://rito15.github.io/posts/unity-editor-component-on-top/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      bool flag = true;
while (flag)
{
    flag = UnityEditorInternal.ComponentUtility.MoveComponentUp(this);
    // 맨 위로 올라갔을 경우 false 리턴
}


    </summary>
  

  </entry>

  
  <entry>
    <title>메소드 호출과 메소드, 람다식 콜백 호출의 오버헤드</title>
    <link href="https://rito15.github.io/posts/unity-memo-callback-overhead/" rel="alternate" type="text/html" title="메소드 호출과 메소드, 람다식 콜백 호출의 오버헤드" />
    <published>2021-03-11T18:11:00+09:00</published>
  
    <updated>2021-03-11T18:11:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-memo-callback-overhead/</id>
    <content src="https://rito15.github.io/posts/unity-memo-callback-overhead/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      테스트 대상


[1] 문장(계산식)

private static void TestInline()
{
    for (int i = 0; i &amp;lt; count; i++)
    {
        _ = Math.Round(2.3f) * Math.Sin(2.5f);
        _ = Math.Floor(4.4f) * Math.Log10(6.34f);
        _ = Math.Acos(5.5f) * Math.Tan(34.4f);
    }
}


[2] 동일한 문장들을 각각 메소드화하여 호출

private static void MethodA()
{
    _ = Math.Round(2.3f) * Math.Sin(2.5f);
}
private static void MethodB()
{
    _...
    </summary>
  

  </entry>

  
  <entry>
    <title>플레이모드 상태 변경에 따른 동작 구현하기</title>
    <link href="https://rito15.github.io/posts/unity-editor-playmode-state-change/" rel="alternate" type="text/html" title="플레이모드 상태 변경에 따른 동작 구현하기" />
    <published>2021-03-11T03:33:00+09:00</published>
  
    <updated>2021-03-11T03:33:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-editor-playmode-state-change/</id>
    <content src="https://rito15.github.io/posts/unity-editor-playmode-state-change/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor" />
    
  

  
    <summary>
      





      #if UNITY_EDITOR

using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;

namespace Rito
{
    [InitializeOnLoad]
    public class PlayModeStateChangeHandler
    {
        public static event Action OnExitEditMode;
        public static event Action OnEnterPlayMode;
        public static event Action OnExitPlayMode;
        public static ...
    </summary>
  

  </entry>

  
  <entry>
    <title>Custom Transform Editor</title>
    <link href="https://rito15.github.io/posts/unity-toy-transform-custom-editor/" rel="alternate" type="text/html" title="Custom Transform Editor" />
    <published>2021-03-10T15:15:00+09:00</published>
  
    <updated>2021-03-10T15:15:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-toy-transform-custom-editor/</id>
    <content src="https://rito15.github.io/posts/unity-toy-transform-custom-editor/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Toys" />
    
  

  
    <summary>
      





      Note


  
    트랜스폼의 커스텀 에디터
  
  
    트랜스폼의 로컬 정보 뿐만 아니라, 글로벌 위치, 회전, 크기 값을 확인 및 조작할 수 있다.
  
  
    총 8개의 리셋 버튼으로 트랜스폼의 로컬, 글로벌 값들을 초기화할 수 있다.
  




Preview







  Global - Reset 버튼을 누를 경우







  Global Position - Reset 버튼을 누를 경우







  Global Rotation - Reset 버튼을 누를 경우







  Global Scale - Reset 버튼을 누를 경우






Download


  CustomTransformEditor.zip




Source Code


  https://githu...
    </summary>
  

  </entry>

  
  <entry>
    <title>Weighted Random Picker (가중치 랜덤 뽑기)</title>
    <link href="https://rito15.github.io/posts/unity-toy-weighted-random-picker/" rel="alternate" type="text/html" title="Weighted Random Picker (가중치 랜덤 뽑기)" />
    <published>2021-03-09T03:22:00+09:00</published>
  
    <updated>2021-03-09T03:22:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-toy-weighted-random-picker/</id>
    <content src="https://rito15.github.io/posts/unity-toy-weighted-random-picker/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Toys" />
    
  

  
    <summary>
      





      Note


  
    게임에서 각각 n% 확률로 존재하는 요소들의 뽑기를 수행할 때, 단순히 Random.Range()를 통해서는 계산할 수 없다.
  
  
    이 때, ‘가중치 랜덤 뽑기’를 이용한다.
  
  
    제네릭을 활용하여, 아이템들과 가중치의 목록을 넣으면 간단히 뽑기를 수행할 수 있도록 작성하였다.
  
  
    아이템은 중복되게 추가할 수 없다.
  
  
    내부적으로 System.Random을 사용한다.
  




가중치 랜덤 뽑기?




  
    각각의 요소에 가중치(Weight)를 부여한다.
  
  
    뽑기를 수행했을 때 각각의 요소가 뽑힐 확률은 (가중치) / (전체 가중치 합)이 된다.
  




How To Use


1. 객체 생성

...
    </summary>
  

  </entry>

</feed>



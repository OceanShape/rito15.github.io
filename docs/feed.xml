

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-08-03T03:48:39+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>TCP 비동기 소켓으로 간단한 콘솔 채팅 구현하기</title>
    <link href="https://rito15.github.io/posts/cs-tcp-async-socket-chatting/" rel="alternate" type="text/html" title="TCP 비동기 소켓으로 간단한 콘솔 채팅 구현하기" />
    <published>2021-08-03T03:33:00+09:00</published>
  
    <updated>2021-08-03T03:33:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-tcp-async-socket-chatting/</id>
    <content src="https://rito15.github.io/posts/cs-tcp-async-socket-chatting/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Socket" />
    
  

  
    <summary>
      





      
  이전 포스팅에서 이어집니다.




1. 채팅을 위한 패킷 설계


[1] ChattingCommand 열거형


  전달하는 패킷의 명령어를 미리 열거형으로 정의한다.
  명령어의 종류는 크게 공통, 클라이언트의 요청, 서버의 통지 3가지로 나뉜다.





   
ChattingCommand.cs


  /// &amp;lt;summary&amp;gt; 채팅 명령어 &amp;lt;/summary&amp;gt;
public enum ChattingCommand
{
    /* [1] 공통 */
    /// &amp;lt;summary&amp;gt; 일반 채팅 &amp;lt;/summary&amp;gt;
    Chat,

    /* [2] 클라이언트 -&amp;gt; 서버 */
    /// &amp;lt;summary&amp;gt; 닉네임 변경 요청 &amp;lt;/summ...
    </summary>
  

  </entry>

  
  <entry>
    <title>TCP 비동기 소켓 서버, 클라이언트 - 패킷 고려하기</title>
    <link href="https://rito15.github.io/posts/06-cs-tcp-async-socket-with-packet.md/" rel="alternate" type="text/html" title="TCP 비동기 소켓 서버, 클라이언트 - 패킷 고려하기" />
    <published>2021-08-02T00:06:00+09:00</published>
  
    <updated>2021-08-02T00:06:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/06-cs-tcp-async-socket-with-packet.md/</id>
    <content src="https://rito15.github.io/posts/06-cs-tcp-async-socket-with-packet.md/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Socket" />
    
  

  
    <summary>
      





      
  이전 포스팅에서 이어집니다.




ReceiveBuffer, SendBuffer



  소켓 통신을 통한 데이터 전달 시 단순히 byte[]를 주고 받는 것에서 그치지 않고, 정말로 ‘패킷’을 주고 받기 위해 필요하다.




ReceiveBuffer 클래스



  
    각 세션마다 하나의 ReceiveBuffer 객체를 갖는다.
  
  
    TCP 소켓 통신을 통해 수신한 패킷이 완전하지 않을 경우를 대비해 사용된다.
  
  
    패킷을 수신하자마자 이를 완전히 처리하는 것이 아니라, ReceiveBuffer에 차례로 저장한다.
  
  
    ReceiveBuffer 앞부분부터 패킷의 헤더를 확인하여, 지정된 길이만큼 패킷이 완전히 도착한 것이 확인된 경우에만 해당 패킷을...
    </summary>
  

  </entry>

  
  <entry>
    <title>TCP 비동기 소켓 서버, 클라이언트 기본</title>
    <link href="https://rito15.github.io/posts/05-cs-tcp-async-socket-basic.md/" rel="alternate" type="text/html" title="TCP 비동기 소켓 서버, 클라이언트 기본" />
    <published>2021-08-02T00:05:00+09:00</published>
  
    <updated>2021-08-02T00:05:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/05-cs-tcp-async-socket-basic.md/</id>
    <content src="https://rito15.github.io/posts/05-cs-tcp-async-socket-basic.md/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Socket" />
    
  

  
    <summary>
      





      비동기 소켓 통신 방식


Socket 객체에는 ~Async() 형태로 명명된 비동기 메소드들이 존재한다.


  AcceptAsync(SocketAsyncEventArgs)
  ConnectAsync(SocketAsyncEventArgs)
  DisconnectAsync(SocketAsyncEventArgs)
  ConnectAsync(SocketAsyncEventArgs)
  ReceiveAsync(SocketAsyncEventArgs)
  ReceiveFromAsync(SocketAsyncEventArgs)
  SendAsync(SocketAsyncEventArgs)
  SendToAsync(SocketAsyncEventArgs)


이런 비동기 메소드들은 모두 내부적으로 워커 스레드에서 동작한다...
    </summary>
  

  </entry>

  
  <entry>
    <title>UDP 소켓 서버, 클라이언트 기본</title>
    <link href="https://rito15.github.io/posts/04-cs-udp-socket-server-client-basic.md/" rel="alternate" type="text/html" title="UDP 소켓 서버, 클라이언트 기본" />
    <published>2021-08-02T00:04:00+09:00</published>
  
    <updated>2021-08-02T00:04:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/04-cs-udp-socket-server-client-basic.md/</id>
    <content src="https://rito15.github.io/posts/04-cs-udp-socket-server-client-basic.md/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Socket" />
    
  

  
    <summary>
      





      UDP 소켓 통신의 특징



  서버와 클라이언트 간의 1:1 연결이 생성되지 않는다.
  리스너 소켓이 필요하지 않다.
  Listen(), Connect() 과정이 없다.
  소켓의 .ReceiveFrom(), .SendTo() 메소드를 통해 엔드포인트와 데이터를 주고 받는다.




소켓 통신 과정


서버

  서버 IP 주소, 포트를 통해 서버 엔드포인트 생성
  서버 소켓 객체 생성
  Bind(서버 엔드포인트 정보를 서버 소켓에 연동)
  클라이언트에 대응할 리모트 엔드포인트 생성
  Send =&amp;gt; 리모트 엔드포인트
  Receive &amp;lt;= 리모트 엔드포인트
  Close


클라이언트

  서버 IP 주소, 포트를 통해 서버 엔드포인트 생성
  클라이언트 소켓 객체 생성
  리...
    </summary>
  

  </entry>

  
  <entry>
    <title>TCP 소켓 서버, 클라이언트 기본</title>
    <link href="https://rito15.github.io/posts/03-cs-tcp-socket-server-client-basic.md/" rel="alternate" type="text/html" title="TCP 소켓 서버, 클라이언트 기본" />
    <published>2021-08-02T00:03:00+09:00</published>
  
    <updated>2021-08-02T00:03:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/03-cs-tcp-socket-server-client-basic.md/</id>
    <content src="https://rito15.github.io/posts/03-cs-tcp-socket-server-client-basic.md/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Socket" />
    
  

  
    <summary>
      





      소켓 정의


프로토콜

  데이터 전송을 위한 규약이며, 대표적으로 TCP와 UDP가 있다.


IP

  컴퓨터에 부여된 논리적 식별 주소


Port

  네트워크 상에서 통신하기 위해 호스트 내부적으로 프로세스가 할당받는 고유 번호
  같은 컴퓨터 내에서 프로세스를 식별하기 위한 번호




소켓 통신 과정


서버

  서버 IP 주소, 포트를 통해 서버 엔드포인트 생성
  Listener 소켓 객체 생성
  Bind(서버 엔드포인트 정보를 Listener 소켓에 연동)
  Listen(클라이언트 대기열 생성)
  Accept(클라이언트 연결 수용)
  Send, Receive(데이터 송수신)
  Close


클라이언트

  서버 IP 주소, 포트를 통해 서버 엔드포인트 생성
  클라이언트 ...
    </summary>
  

  </entry>

</feed>



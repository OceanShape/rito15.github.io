

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-05-14T23:40:14+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Magical Orb</title>
    <link href="https://rito15.github.io/posts/unity-urp-sg-magical-orb/" rel="alternate" type="text/html" title="Magical Orb" />
    <published>2021-05-14T02:00:00+09:00</published>
  
    <updated>2021-05-14T02:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-urp-sg-magical-orb/</id>
    <content src="https://rito15.github.io/posts/unity-urp-sg-magical-orb/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="URP Shader Graph" />
    
  

  
    <summary>
      





      Summary



  
    꿀렁이며 움직이는 구체 쉐이더
  
  
    Scene Color 노드를 사용하므로, Render Pipeline Asset에서 Opaque Texture에 체크해야 한다.
  
  
    마스터 노드의 Surface를 Transparent로 설정해야 한다.
  


Preview








Options



  
    
      프로퍼티
      설명
    
  
  
    
      Pattern Texture
      구체 표면의 패턴 텍스쳐(반복 연결되어야 함)
    
    
      Tiling X
      텍스쳐의 X 타일링
    
    
      Tiling Y
      텍스쳐의 Y 타일링
    
    
      C...
    </summary>
  

  </entry>

  
  <entry>
    <title>UI(RectTransform)의 스크린 픽셀 크기 계산하기</title>
    <link href="https://rito15.github.io/posts/unity-calculate-ui-pixel-size/" rel="alternate" type="text/html" title="UI(RectTransform)의 스크린 픽셀 크기 계산하기" />
    <published>2021-05-10T18:00:00+09:00</published>
  
    <updated>2021-05-10T18:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-calculate-ui-pixel-size/</id>
    <content src="https://rito15.github.io/posts/unity-calculate-ui-pixel-size/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      Note


모든 UGUI 요소는 RectTransform을 통해 크기를 결정한다.

그리고 RectTransform.rect로 크기를 참조할 수 있다.

그런데 이 크기는 해상도가 변해도 항상 같은 값을 반환한다.

따라서 해상도를 기반으로 하는 드래그 등의 기능을 구현할 때

마우스 변위를 해상도 값으로 가져오고, 이를 RectTransform에 적용하면

해상도가 달라졌을 때 원치 않는 동작을 하게 된다.

CanvasScaler를 이용하면 현재 스크린에 따른 실제 픽셀 크기를 계산할 수 있다.



크기 계산



  CanvasScaler의 [UI Scale Mode]가 Scale With Screen Size일 경우에만 해당한다.




CanvasScaler는 Reference Resolu...
    </summary>
  

  </entry>

  
  <entry>
    <title>unsafe와 fixed 구문을 통해 주솟값 확인하기</title>
    <link href="https://rito15.github.io/posts/cs-get-address/" rel="alternate" type="text/html" title="unsafe와 fixed 구문을 통해 주솟값 확인하기" />
    <published>2021-05-10T14:14:00+09:00</published>
  
    <updated>2021-05-10T14:14:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-get-address/</id>
    <content src="https://rito15.github.io/posts/cs-get-address/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      safe(안전한 코드)



  
    C#에서 일반적인 코드는 “확인할 수 있는 안전한 코드”이다.
  
  
    .NET에서 코드가 안전한지 확인할 수 있음을 의미한다.
  
  
    메모리를 직접 할당하지 않고, 관리형 개체를 만든다.
  




unsafe


  
    unsafe 컨텍스트 내에서는 "”확인할 수 없는 안전하지 않은 코드”“를 작성할 수 있다.
  
  
    안전하지 않은 코드란, 위험한 것이 아니라 CLR에서 안전을 확인할 수 없다는 것을 의미한다.
  


허용되는 것들

  포인터 사용
  메모리 블록 할당 및 해제
  함수 포인터를 사용하여 메소드 호출


unsafe가 필요한 경우

  포인터가 필요한 네이티브 함수를 호출하는 경우
  메모리 직접 접근...
    </summary>
  

  </entry>

  
  <entry>
    <title>스트링 포맷 정리</title>
    <link href="https://rito15.github.io/posts/cs-string-format/" rel="alternate" type="text/html" title="스트링 포맷 정리" />
    <published>2021-05-09T21:00:00+09:00</published>
  
    <updated>2021-05-09T21:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-string-format/</id>
    <content src="https://rito15.github.io/posts/cs-string-format/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      NOTE



  , : 스트링의 범위(공간) 설정
  : : 출력 포맷 설정




좌우 정렬


$"{value, 10}"



  10칸 범위 내에서 우측 정렬




$"{value, -10}"



  10칸 범위 내에서 좌측 정렬




숫자 왼쪽에 공백 삽입하기


$"{value :   0}"



  :, 0 사이의 공백 크기만큼 고정된 공백을 삽입
  값의 왼쪽에 공백 3칸을 항상 삽입
  오른쪽은 설정 불가




자리수 설정


$"{value :000}"



  세 번째 자리까지 채워서 표현(빈 칸은 0으로 채움)
  실수일 경우, 소수점 첫째자리에서 반올림하여 정수로 표현




$"{value :0.00}"



  정수부는 첫째 자리까지 반드시 표현(빈칸 0으로 채움)
 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>마우스 이벤트를 통과시킬 수 있는 컨트롤 만들기</title>
    <link href="https://rito15.github.io/posts/cs-winform-pass-through-mouse-events/" rel="alternate" type="text/html" title="마우스 이벤트를 통과시킬 수 있는 컨트롤 만들기" />
    <published>2021-05-09T01:30:00+09:00</published>
  
    <updated>2021-05-09T01:30:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-winform-pass-through-mouse-events/</id>
    <content src="https://rito15.github.io/posts/cs-winform-pass-through-mouse-events/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Winform" />
    
  

  
    <summary>
      





      목표



  마우스 이벤트를 모두 무시할 수 있는 컨트롤(버튼, 레이블 등) 만들기




방법



  
    특정 컨트롤 클래스(Button, Label, …)를 상속받는 클래스를 작성한다.
  
  
    아래와 같이 프로퍼티와 메소드를 작성한다.
  


public bool Ignored { get; set; } = false;

protected override void WndProc(ref Message m)
{
    const int WM_NCHITTEST = 0x0084;
    const int HTTRANSPARENT = (-1);

    if (Ignored &amp;amp;&amp;amp; m.Msg == WM_NCHITTEST)
    {
        m.Result = (IntP...
    </summary>
  

  </entry>

</feed>



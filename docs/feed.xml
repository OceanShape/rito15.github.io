

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-10-02T02:43:53+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>레이캐스트 - 구체(Sphere)</title>
    <link href="https://rito15.github.io/posts/raycast-to-sphere/" rel="alternate" type="text/html" title="레이캐스트 - 구체(Sphere)" />
    <published>2021-10-02T02:02:00+09:00</published>
  
    <updated>2021-10-02T02:02:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/raycast-to-sphere/</id>
    <content src="https://rito15.github.io/posts/raycast-to-sphere/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Algorithm" />
    
    <category term="Algorithms" />
    
  

  
    <summary>
      





      Raycast(레이캐스트)



  공간 상의 한 점에서부터 목표 지점까지 가상의 광선을 발사하여, 광선에 닿는 물체의 표면을 검출한다.




구체 표면 교차점 찾기



  시작 지점에서부터 목표 지점으로 광선을 발사하여, 그 사이에서 광선과 교차하는 구체의 표면 지점을 찾아낸다.
  3차원에서 수행하면 구체, 2차원에서 수행하면 원(Circle)의 표면을 검출할 수 있다.




먼저, 주어진 조건은 다음과 같다.


  
    A : 레이캐스트 시작 위치
    B : 레이캐스트 종료 위치
    S : 구체 중심 위치
    r : 구체 반지름 길이
  






다음과 같은 공간상의 지점 C, D를 가정할 수 있다.


  
    C : 점 S에서 직선 AB에 내린 수선의 발
    D...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# 바이트 버퍼를 읽어서 구조체로 변환하기</title>
    <link href="https://rito15.github.io/posts/cs-byte-buffer-to-struct/" rel="alternate" type="text/html" title="C# 바이트 버퍼를 읽어서 구조체로 변환하기" />
    <published>2021-10-01T00:01:00+09:00</published>
  
    <updated>2021-10-01T03:36:11+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-byte-buffer-to-struct/</id>
    <content src="https://rito15.github.io/posts/cs-byte-buffer-to-struct/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      소스 코드


메소드




  


/// &amp;lt;summary&amp;gt; 바이트 버퍼를 읽어서 구조체로 변환하기 &amp;lt;/summary&amp;gt;
public static T? ByteBufferToStruct&amp;lt;T&amp;gt;(byte[] buffer, int offset) where T : struct
{
    int size = Marshal.SizeOf(typeof(T));

    if (buffer.Length - offset &amp;lt; size)
        return null;

    // Unmanaged Heap에 size만큼 메모리 할당
    IntPtr ptr = Marshal.AllocHGlobal(size);

    // buffer[offset]부터 size만큼 읽어서 p...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 쉐이더 - 빌보드(Vert/Frag)</title>
    <link href="https://rito15.github.io/posts/unity-shader-billboard/" rel="alternate" type="text/html" title="유니티 쉐이더 - 빌보드(Vert/Frag)" />
    <published>2021-09-30T21:00:00+09:00</published>
  
    <updated>2021-09-30T21:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-shader-billboard/</id>
    <content src="https://rito15.github.io/posts/unity-shader-billboard/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Shader Memo" />
    
  

  
    <summary>
      





      1. 일반


struct appdata
{
    float4 vertex : POSITION;
    float2 uv : TEXCOORD0;
};

struct v2f
{
    float4 vertex : SV_POSITION;
    float2 uv : TEXCOORD0;
};

float4 Billboard(float4 vertex)
{
    float3 camUpVec      =  normalize( UNITY_MATRIX_V._m10_m11_m12 );
    float3 camForwardVec = -normalize( UNITY_MATRIX_V._m20_m21_m22 );
    float3 camRightVec   =  normalize( UNITY_MATRIX_V._m00_m...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# Nullable</title>
    <link href="https://rito15.github.io/posts/cs-nullable/" rel="alternate" type="text/html" title="C# Nullable" />
    <published>2021-09-30T00:11:00+09:00</published>
  
    <updated>2021-09-30T00:11:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-nullable/</id>
    <content src="https://rito15.github.io/posts/cs-nullable/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Grammar" />
    
  

  
    <summary>
      





      null 허용 값 타입



  
    .Net Framework 2.0 버전부터 사용할 수 있다.
  
  
    Nullable&amp;lt;T&amp;gt; 또는 T? 꼴로 사용할 수 있다.
  
  
    null 값의 초기화를 허용한다.
  
  
    null을 허용한다고 해서 참조형이 되는 것은 아니고, 값 타입은 그대로 값 타입이다.
  
  
    힙에 할당되지 않고, 스택에 할당되는 것은 동일하다.
  




Nullable 클래스


  
    정적 클래스이다.
  
  
    변수를 선언할 수 없다.
  
  
    Nullable&amp;lt;T&amp;gt;와는 엄연히 다른 타입이며, 관련 API를 제공하기 위해 존재한다.
  




Nullable&amp;lt;T&amp;gt; 구조체


  
   ...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 - sRGB, Linear, Gamma 컬러 스페이스</title>
    <link href="https://rito15.github.io/posts/unity-srgb-linear-gamma-color-space/" rel="alternate" type="text/html" title="유니티 - sRGB, Linear, Gamma 컬러 스페이스" />
    <published>2021-09-29T03:21:00+09:00</published>
  
    <updated>2021-09-29T03:21:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-srgb-linear-gamma-color-space/</id>
    <content src="https://rito15.github.io/posts/unity-srgb-linear-gamma-color-space/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      모니터의 색상 변환


  모니터는 디스크에 저장된 이미지를 화면에 출력할 때 Pow(color, 2.2) 연산을 적용해서 더 어둡게 출력한다.





  이유?
    
      베버의 법칙(Weber’s law)
      사람의 시각은 어두운 부분의 밝기 변화를 부드럽지 않고 단절되게 감지한다.
      그래서 어두운 부분의 화질이 떨어져 보이는 현상이 발생한다.
      따라서 이를 부드럽게 감지하도록 하려면 어두운 부분을 더 풍부하게 표현할 필요가 있다.
      따라서 모니터 하드웨어적으로 이런 변환을 해준다.
    
  
  Pow(color, 2.2)이면 감마(Gamma)가 2.2라고 한다.




Gamma Correction(감마 보정)이란?


  이미지를 디스크에 저장할...
    </summary>
  

  </entry>

</feed>



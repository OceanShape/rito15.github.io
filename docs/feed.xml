

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-02-17T01:52:07+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>매개변수 한정자 ref, in의 성능</title>
    <link href="https://rito15.github.io/posts/ref-in-performance/" rel="alternate" type="text/html" title="매개변수 한정자 ref, in의 성능" />
    <published>2021-02-16T23:20:00+09:00</published>
  
    <updated>2021-02-16T23:20:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/ref-in-performance/</id>
    <content src="https://rito15.github.io/posts/ref-in-performance/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Csharp" />
    
    <category term="Csharp Memo" />
    
  

  
    <summary>
      





      목표


  값타입을 매개변수로 전달할 때 매개변수 한정자 사용에 따른 성능 알아보기


(string은 참조타입이지만 매개변수로 전달하면 복제되므로 함께 테스트)



비교군


public struct StructA
{
    public long a,b,c,d,e,f,g;

    public StructA(long value)
    {
        a = b = c = d = e = f = g = value;
    }
}

public readonly struct StructB
{
    public readonly long a,b,c,d,e,f,g;

    public StructB(long value)
    {
        a = b = c = d = e = f = g = valu...
    </summary>
  

  </entry>

  
  <entry>
    <title>OpenGL 공부 - 20 - Texture Class</title>
    <link href="https://rito15.github.io/posts/opengl-study-20/" rel="alternate" type="text/html" title="OpenGL 공부 - 20 - Texture Class" />
    <published>2021-02-16T22:22:00+09:00</published>
  
    <updated>2021-02-16T22:22:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/opengl-study-20/</id>
    <content src="https://rito15.github.io/posts/opengl-study-20/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="OpenGL" />
    
    <category term="OpenGL Study" />
    
  

  
    <summary>
      





      목표


  텍스쳐 클래스화하기




텍스쳐 클래스 작성


기존에 메소드화하여 사용하던 텍스쳐를 클래스화하려고 한다.

function.hpp 파일에 LoadTextureImage() 메소드에 작성했던 내용을 클래스로 옮겨 작성한다.

class Texture
{
private:
    GLuint id;
    GLenum type;
    int width;
    int height;

public:
    Texture(const char* fileName, GLenum type);
    ~Texture();

    inline const GLuint&amp;amp; GetID();
    void Bind(const GLint&amp;amp; index);
    void Release();
    ...
    </summary>
  

  </entry>

  
  <entry>
    <title>쉐이더그래프로 물 쉐이더 만들기 [작성중]</title>
    <link href="https://rito15.github.io/posts/shadergraph-water/" rel="alternate" type="text/html" title="쉐이더그래프로 물 쉐이더 만들기 [작성중]" />
    <published>2021-02-16T03:00:00+09:00</published>
  
    <updated>2021-02-16T03:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/shadergraph-water/</id>
    <content src="https://rito15.github.io/posts/shadergraph-water/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="URP Shader Study" />
    
  

  
    <summary>
      





      Preview


1. 단순 색상



2. 큐브맵 매핑





References


  https://www.youtube.com/watch?v=gRq-IdShxpU&amp;amp;ab_channel=Unity


Download


  2021_0214_Water.zip


    </summary>
  

  </entry>

  
  <entry>
    <title>URP에서 쉐이더 코딩하기 [작성 중]</title>
    <link href="https://rito15.github.io/posts/unity-urp-shader-coding/" rel="alternate" type="text/html" title="URP에서 쉐이더 코딩하기 [작성 중]" />
    <published>2021-02-15T18:07:00+09:00</published>
  
    <updated>2021-02-15T18:07:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-urp-shader-coding/</id>
    <content src="https://rito15.github.io/posts/unity-urp-shader-coding/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="URP Shader Study" />
    
  

  
    <summary>
      





      기본 구조


  


Starting Point


Shader "RitoURP/VertexFragmentStartPoint"
{
    Properties
    {
        _MainTex ("Main Map", 2D) = "white" {}
        _BumpMap ("Normal Map", 2D) = "bump" {}
    }
    SubShader
    {
        Tags 
        {
            "RenderPipeline"="UniversalPipeline"
            "RenderType"="Opaque"
        }

        Pass
        {
            HLSLPROGRAM
            #pra...
    </summary>
  

  </entry>

  
  <entry>
    <title>OpenGL 공부 - 19 - Shader, Transform Class</title>
    <link href="https://rito15.github.io/posts/opengl-study-19/" rel="alternate" type="text/html" title="OpenGL 공부 - 19 - Shader, Transform Class" />
    <published>2021-02-15T15:30:00+09:00</published>
  
    <updated>2021-02-15T15:30:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/opengl-study-19/</id>
    <content src="https://rito15.github.io/posts/opengl-study-19/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="OpenGL" />
    
    <category term="OpenGL Study" />
    
  

  
    <summary>
      





      목표


  쉐이더, 트랜스폼 클래스화하기




1. 쉐이더의 클래스화


shader.hpp 작성

shader.hpp 파일에 Shader 클래스를 작성한다.

기존에 functions.hpp와 main.cpp에서 사용하던 쉐이더 부분을 모두 Shader 클래스로 옮겨준다.

// shader.hpp

class Shader
{
private:
    GLuint id;

    GLuint CompileShader(const GLenum&amp;amp; shaderType, const char* fileDir);
    void LinkProgram(const GLuint&amp;amp; vertexShader, const GLuint&amp;amp; fragmentShader, const GLuint&amp;amp; geo...
    </summary>
  

  </entry>

</feed>



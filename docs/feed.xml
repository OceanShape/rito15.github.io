

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-02-05T04:26:48+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Unity Script Optimization</title>
    <link href="https://rito15.github.io/posts/unity-script-optimization/" rel="alternate" type="text/html" title="Unity Script Optimization" />
    <published>2021-02-04T19:30:00+09:00</published>
  
    <updated>2021-02-04T19:30:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-script-optimization/</id>
    <content src="https://rito15.github.io/posts/unity-script-optimization/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Study" />
    
  

  
    <summary>
      





      Tips


1. GetComponent(), Find() 메소드 반복 호출하지 않기

너무나 기본적인 것이라 간단히 짚고 넘어가지만,
매 프레임, 혹은 주기적으로 Get, Find류의 메소드를 호출하는 것은 매우 좋지 않다.
항상 처음에만 Get, Find로 필드에 담아놓고 사용해야 한다.



2. 필요하지 않은 경우, new로 생성하지 않기

클래스 타입으로 생성한 객체는 항상 GC의 먹이가 된다.
따라서 가능하면 한 번만 생성하고 이후에는 재사용 하는 방식을 선택해야 한다.

데이터 클래스의 경우, 대신 구조체를 사용하는 것도 좋다.



3. 구조체 사용하기


  http://clarkkromenaker.com/post/csharp-structs/


동일한 데이터를 하나는 구조체, 하나는 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>Unity Profiling</title>
    <link href="https://rito15.github.io/posts/unity-profiling/" rel="alternate" type="text/html" title="Unity Profiling" />
    <published>2021-02-04T19:30:00+09:00</published>
  
    <updated>2021-02-05T03:35:32+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-profiling/</id>
    <content src="https://rito15.github.io/posts/unity-profiling/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Study" />
    
  

  
    <summary>
      





      Note


  프로파일링은 1차적으로 에디터에서 수행하지만, 타겟 디바이스에서 실제로 실행하며 진행하는 프로파일링이 가장 중요하다.
  [Edit - Project Settings - Quliaty - Other]에서 VSync가 설정되어 있는지 확인한다.
  Application.targetFrameRate가 설정되어 있는지 확인한다(미설정 시 -1)
  병목을 확인할 때 CPU 바운드인지 GPU 바운드인지 꼭 짚고 시작한다.
  모바일 기기라면 프로파일링 순간이 쓰로틀링 상황인지 확인해야 한다.



Tools


1. Unity Editor

Unity Profiler

  [Window - Analysis - Profiler (Ctrl+7)]
  https://docs.unity3d.com/k...
    </summary>
  

  </entry>

  
  <entry>
    <title>Unity Profiler Window</title>
    <link href="https://rito15.github.io/posts/unity-profiler-window/" rel="alternate" type="text/html" title="Unity Profiler Window" />
    <published>2021-02-04T17:50:00+09:00</published>
  
    <updated>2021-02-05T03:01:58+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-profiler-window/</id>
    <content src="https://rito15.github.io/posts/unity-profiler-window/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Study" />
    
  

  
    <summary>
      





      유니티 프로파일러

[Window] - [Analysis] - [Profiler]를 통해 프로파일러 윈도우를 열 수 있다.



CPU, GPU(Rendering), Memory 등등 다양한 지표들을 통해 현재 유니티 프로젝트에서 측정되는 성능을 확인할 수 있다.

선택된 탭의 구체적인 내용들은 윈도우 하단에 나타난다.

프로젝트 실행 후 그래프의 한 부분을 클릭할 경우, 유니티 프로젝트의 실행이 일시정지되며 해당 프레임의 정보를 확인할 수 있다.

Note

  좌측 상단의 [Profiler Modules]를 통해 측정할 지표들을 선택할 수 있으며, 필요하지 않은 지표들은 불필요하게 성능을 소모하므로 체크 해제하는 것이 좋다.




CPU Usage

프로파일러에서 주로 확인하게 되는 부분으로, 해...
    </summary>
  

  </entry>

  
  <entry>
    <title>C++ Smart Debugging</title>
    <link href="https://rito15.github.io/posts/cpp-smart-debugging/" rel="alternate" type="text/html" title="C++ Smart Debugging" />
    <published>2021-02-04T16:56:00+09:00</published>
  
    <updated>2021-02-04T16:56:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cpp-smart-debugging/</id>
    <content src="https://rito15.github.io/posts/cpp-smart-debugging/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C++" />
    
    <category term="C++ Memo" />
    
  

  
    <summary>
      





      Note

C++에는 미리 정의된 동적 매크로가 있다.

__FILE__

  해당 위치의 소스파일 경로를 문자열로 가져온다.


__LINE__

  해당 위치의 줄 번호를 정수로 가져온다.



그리고 매크로의 매개변수를 무조건 스트링으로 변환하여 가져올 수 있는 방법이 존재한다.

#define MACRO(x) #x

  x에 위치한 코드를 문자열로 변환하여 가져온다.




이를 이용하면 해당 소스코드와 실행 위치 정보를 간단히 출력할 수 있다.

#include &amp;lt;iostream&amp;gt;
using namespace std;

#define ShowCodeInfo(x) cout &amp;lt;&amp;lt; "Code : " &amp;lt;&amp;lt; #x &amp;lt;&amp;lt; endl\
	&amp;lt;&amp;lt; "Line :...
    </summary>
  

  </entry>

  
  <entry>
    <title>OpenGL 공부 - 08</title>
    <link href="https://rito15.github.io/posts/opengl-study-08/" rel="alternate" type="text/html" title="OpenGL 공부 - 08" />
    <published>2021-02-04T15:45:00+09:00</published>
  
    <updated>2021-02-04T15:45:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/opengl-study-08/</id>
    <content src="https://rito15.github.io/posts/opengl-study-08/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="OpenGL" />
    
    <category term="OpenGL Study" />
    
  

  
    <summary>
      





      목표


  OpenGL 내에서 디버깅하기




공부 내용


  OpenGL 내에서 에러가 발생하거나 코드를 잘못 작성한 경우, 친절한 에러 메시지보다는 그저 검은 화면을 볼 가능성이 높다.





  그래서 디버깅을 하려면, OpenGL에서 제공하는 몇몇 메소드와 매크로를 활용해야 한다.




  
    glGetError
    
      에러가 발생한 경우 에러 플래그를 리턴한다.
    
  



  
    
      return GLenum
      에러 플래그 - GL_NO_ERROR - GL_INVALID_ENUM - GL_INVALID_VALUE - GL_INVALID_OPERATION - GL_INVALID_FRAMEBUFFER_OPERATION - GL_OUT_OF_...
    </summary>
  

  </entry>

</feed>



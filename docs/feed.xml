

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-09-11T16:28:22+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>C# Tuple, ValueTuple</title>
    <link href="https://rito15.github.io/posts/cs-tuple-and-value-tuple/" rel="alternate" type="text/html" title="C# Tuple, ValueTuple" />
    <published>2021-09-11T03:45:00+09:00</published>
  
    <updated>2021-09-11T03:45:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-tuple-and-value-tuple/</id>
    <content src="https://rito15.github.io/posts/cs-tuple-and-value-tuple/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Grammar" />
    
  

  
    <summary>
      





      Note


Tuple, ValueTuple은 C# 7.0에 처음 도입되었다.

두 개 이상의 타입을 함께 묶어 사용할 때,

클래스나 구조체를 따로 정의하지 않고 곧바로 사용할 수 있게 해준다.



Tuple


클래스 튜플 타입.

클래스 타입이므로 전달할 때 복사가 발생하지 않고, 참조를 전달한다.

Tuple&amp;lt;T1, T2&amp;gt; 같이 명시적으로 타입명을 작성해야 한다.



Tuple&amp;lt;int, float&amp;gt; tuple = (10, 20f); // 불가능


아쉽게도 위와 같은 편리한 생성은 안되고,

Tuple&amp;lt;int, float&amp;gt; tuple = new Tuple&amp;lt;int, float&amp;gt;(10, 20f);


이렇게 명시적으로 생성자를 호출하여 생성해야 한다.
...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# 타입별 GetHashCode() 성능</title>
    <link href="https://rito15.github.io/posts/cs-gethashcode-cost-by-types/" rel="alternate" type="text/html" title="C# 타입별 GetHashCode() 성능" />
    <published>2021-09-11T00:30:00+09:00</published>
  
    <updated>2021-09-11T03:05:19+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-gethashcode-cost-by-types/</id>
    <content src="https://rito15.github.io/posts/cs-gethashcode-cost-by-types/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      Curiosity


타입별로 GetHashCode()의 성능 비용이 얼마나 달라지는지 간단히 확인해본다.

사용자 정의 타입은 GetHashCode() 메소드를 임의로 오버라이드 하지 않고 확인한다.



사용자 정의 타입

public struct Struct1 { }
public struct Struct2
{
    public int a, b, c, d, e, f, g;
    public long A, B, C, D, E, F, G, H;
}
public struct Struct3
{
    public int i1, i2, i3, i4, i5, i6, i7, i8;
    public long l1, l2, l3, l4, l5, l6, l7, l8;
    public double d1, d...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# Dictionary 탐색 성능 - 선형 탐색과 비교</title>
    <link href="https://rito15.github.io/posts/cs-dictionary-search-cost/" rel="alternate" type="text/html" title="C# Dictionary 탐색 성능 - 선형 탐색과 비교" />
    <published>2021-09-11T00:01:00+09:00</published>
  
    <updated>2021-09-11T00:01:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-dictionary-search-cost/</id>
    <content src="https://rito15.github.io/posts/cs-dictionary-search-cost/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      Curiosity


Dictionary&amp;lt;TKey, TValue&amp;gt;는 해시 테이블 자료구조의 제네릭 구현 클래스로서,

Key-Value 꼴로 데이터를 저장하고

Key에 대한 해시 계산을 통해 Value를 탐색할 수 있다.

그렇다면 Key-Value를 저장하는 배열의 선형 탐색과 비교했을 때,

Dictionary의 탐색 성능은 어느 정도일까?



Benchmark


Benchmark DotNet을 이용하여

&amp;lt;TKey, TValue&amp;gt; 꼴의 딕셔너리, 이를 페어로 저장하는 배열을 비교한다.

TKey와 TValue는 임의의 클래스 타입을 사용한다.

public class Data { } // 임의의 클래스 타입

public class Pair
{
    public Dat...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# Span 사용하여 문자열의 첫 문자만 대소문자 변경하기</title>
    <link href="https://rito15.github.io/posts/cs-string-first-char-to-lower-or-upper/" rel="alternate" type="text/html" title="C# Span 사용하여 문자열의 첫 문자만 대소문자 변경하기" />
    <published>2021-09-10T17:51:00+09:00</published>
  
    <updated>2021-09-10T17:51:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-string-first-char-to-lower-or-upper/</id>
    <content src="https://rito15.github.io/posts/cs-string-first-char-to-lower-or-upper/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      첫 문자만 간단히 대소문자 변경하기


string의 API만 사용하면 아주 간단히 첫 문자만 대소문자를 변경할 수 있다.

private static string FirstCharToLower(string str)
{
    return str[0].ToString().ToLower() + str.Substring(1);
}


하지만 이렇게 되면 여기서 힙 할당이 너무 많이 발생한다.

str[0].ToString()에서 한 번,

.ToLower()에서 한 번,

str.Substring(1)에서 한 번,

_ + _에서 한 번.

총 네 번의 힙 할당이 이루어진다.



힙 할당 최소화하여 변환하기


힙 할당을 최소화하려면 역시 Span, ReadOnlySpan을 사용해야 한다.

Span이 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 - 컴퓨트 쉐이더(Compute Shader)</title>
    <link href="https://rito15.github.io/posts/unity-compute-shader/" rel="alternate" type="text/html" title="유니티 - 컴퓨트 쉐이더(Compute Shader)" />
    <published>2021-09-10T02:01:00+09:00</published>
  
    <updated>2021-09-10T15:39:28+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-compute-shader/</id>
    <content src="https://rito15.github.io/posts/unity-compute-shader/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      Compute Shader


개념

  GPU를 CPU의 영역인 응용 프로그램 계산에 사용하는 GPGPU(General-Purpose computing on GPU)와는 개념이 유사하지만 다르다.
  GPGPU를 사용하는 CUDA, OpenCL은 독립 API이고 OpenGL의 Compute Shader, DirectX의 DirectCompute는 그래픽스API에 종속되어 동작한다.
  동시에 수많은 대상(수십만, 수백만 단위 가능)에 대해 동일한 연산(함수)을 처리해야 할 때 사용한다.
  VFX Graph도 컴퓨트 쉐이더를 연산에 사용한다고 한다.
  확장자는 .compute이다.


커널(Kernal)

  GPU에서 동작하는 함수를 의미한다.
  함수의 이름이 곧 커널의 이름이며, #pragma...
    </summary>
  

  </entry>

</feed>





<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-08-22T23:51:03+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>유니티 에디터 다크모드 여부 스크립트로 확인하기</title>
    <link href="https://rito15.github.io/posts/unity-dark-mode-in-script/" rel="alternate" type="text/html" title="유니티 에디터 다크모드 여부 스크립트로 확인하기" />
    <published>2021-08-22T22:48:00+09:00</published>
  
    <updated>2021-08-22T22:48:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-dark-mode-in-script/</id>
    <content src="https://rito15.github.io/posts/unity-dark-mode-in-script/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor Memo" />
    
  

  
    <summary>
      





      Memo


확인된 버전


  2019.4.9f1




[1] 다크모드 여부 확인

EditorGUIUtility.isProSkin;

// true : 다크모드
// false : 일반모드(Light)




[2] 모드 변경하기

UnityEditorInternal.InternalEditorUtility.SwitchSkinAndRepaintAllViews();


    </summary>
  

  </entry>

  
  <entry>
    <title>(Shorts) C# Foreach가 실제로 생성하는 소스코드</title>
    <link href="https://rito15.github.io/posts/cs-list-foreach-code/" rel="alternate" type="text/html" title="(Shorts) C# Foreach가 실제로 생성하는 소스코드" />
    <published>2021-08-21T17:22:00+09:00</published>
  
    <updated>2021-08-21T17:22:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-list-foreach-code/</id>
    <content src="https://rito15.github.io/posts/cs-list-foreach-code/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      Memo


Source Code

private List&amp;lt;int&amp;gt; list = new List&amp;lt;int&amp;gt;(10);

foreach (var item in list)
{
    Console.WriteLine(item);
}




Generated Code

private List&amp;lt;int&amp;gt; list = new List&amp;lt;int&amp;gt;(10);

List&amp;lt;int&amp;gt;.Enumerator enumerator = list.GetEnumerator();

while (enumerator.MoveNext())
{
    int item = enumerator.Current;
    Console.WriteLine(item);
}




정리


  .GetEnumera...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# Switch-Case의 특징</title>
    <link href="https://rito15.github.io/posts/cs-switch-case/" rel="alternate" type="text/html" title="C# Switch-Case의 특징" />
    <published>2021-08-20T16:49:00+09:00</published>
  
    <updated>2021-08-20T16:49:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-switch-case/</id>
    <content src="https://rito15.github.io/posts/cs-switch-case/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Grammar" />
    
  

  
    <summary>
      





      Switch-Case 문



  
    대상 변수에 대해, 고정된 값들을 case에 지정하여 동등 비교를 수행할 수 있다.
  
  
    case가 일정 개수 미만일 경우, if-else와 동일한 방식으로 각 case를 순차적으로 확인하며 분기한다고 한다.
  
  
    case가 일정 개수 이상일 경우, 메모리에 Jump Table을 생성하여 해당 case로 직접 건너뛴다고 한다.
  




생성되는 CIL 코드 확인하기


[1] 소스 코드


   
.


  private void IfElse()
{
    int value = 2;

    if (value == 0) result = 0;
    else if (value == 1) result = 10;
    else if (...
    </summary>
  

  </entry>

  
  <entry>
    <title>VS2019 파일 템플릿 만들기</title>
    <link href="https://rito15.github.io/posts/cs-vs-2019-item-template/" rel="alternate" type="text/html" title="VS2019 파일 템플릿 만들기" />
    <published>2021-08-20T16:16:00+09:00</published>
  
    <updated>2021-08-20T16:16:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-vs-2019-item-template/</id>
    <content src="https://rito15.github.io/posts/cs-vs-2019-item-template/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      Memo


[1] 템플릿으로 사용할 파일 만들기





[2] 템플릿 내보내기


  [프로젝트] - [템플릿 내보내기]





  [항목 템플릿] 선택 - [다음]





  내보낼 파일에 체크





  참조가 필요한 경우 선택 - [다음]





  템플릿 이름과 설명 작성 후 - [마침]




[2] 생성된 파일 확인





[3] 템플릿 확인


  비주얼 스튜디오를 닫고, 다시 시작한다.





  새 항목 추가 창에서 새로운 템플릿이 생성된 것을 확인할 수 있다.




References


  https://docs.microsoft.com/ko-kr/visualstudio/ide/how-to-create-item-templates?view=vs-2019
  https:...
    </summary>
  

  </entry>

  
  <entry>
    <title>Enum을 인덱스로 사용할 경우, 배열과 딕셔너리의 참조 성능 비교</title>
    <link href="https://rito15.github.io/posts/cs-enum-index-array-vs-dict/" rel="alternate" type="text/html" title="Enum을 인덱스로 사용할 경우, 배열과 딕셔너리의 참조 성능 비교" />
    <published>2021-08-19T23:11:00+09:00</published>
  
    <updated>2021-08-19T23:11:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-enum-index-array-vs-dict/</id>
    <content src="https://rito15.github.io/posts/cs-enum-index-array-vs-dict/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      요약



  array[(int)enumValue], dict[enumValue]의 참조 성능을 비교한다.




테스트 코드


public enum MyEnum
{
    Zero, One, Two, Three, Four, Five, Six, Seven, Eight, Nine
}

public float[] targetArray;
public Dictionary&amp;lt;MyEnum, float&amp;gt; targetDict;

[GlobalSetup]
public void GlobalSetup()
{
    targetArray = new float[10];
    targetDict = new Dictionary&amp;lt;MyEnum, float&amp;gt;(10);

    for (int i = 0; i ...
    </summary>
  

  </entry>

</feed>



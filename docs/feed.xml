

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-11-04T21:02:55+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>유니티 - 키보드 입력 및 리지드바디 이동, 점프 기본 코드</title>
    <link href="https://rito15.github.io/posts/unity-rigidbody-move-and-jump/" rel="alternate" type="text/html" title="유니티 - 키보드 입력 및 리지드바디 이동, 점프 기본 코드" />
    <published>2021-11-04T20:30:00+09:00</published>
  
    <updated>2021-11-04T20:30:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-rigidbody-move-and-jump/</id>
    <content src="https://rito15.github.io/posts/unity-rigidbody-move-and-jump/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo - Shorts" />
    
  

  
    <summary>
      





      Source Code



  기본 중의 기본 코드





  


using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;

[RequireComponent(typeof(Rigidbody))]
public class InputAndPhysicsMove : MonoBehaviour
{
    private Vector3 moveDir;
    private bool isMoving = false;
    private bool isJumpRequired = false;
    private Rigidbody rb;

    [SerializeField, Range(0f, 100f)]
    p...
    </summary>
  

  </entry>

  
  <entry>
    <title>Intel Assembly 기초 간단 정리</title>
    <link href="https://rito15.github.io/posts/intel-assembly-memo/" rel="alternate" type="text/html" title="Intel Assembly 기초 간단 정리" />
    <published>2021-11-02T03:54:00+09:00</published>
  
    <updated>2021-11-02T03:54:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/intel-assembly-memo/</id>
    <content src="https://rito15.github.io/posts/intel-assembly-memo/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Memo" />
    
    <category term="Assembly Memo" />
    
  

  
    <summary>
      





      목표


  비주얼 스튜디오에서 디스어셈블러로 어셈블리 코드를 읽었을 때, 대충이라도 흐름과 동작 이해하기




어셈블리 문법 종류



  
    Intel, AT&amp;amp;T 문법이 있다.
  
  eax, [eax] 꼴의 문법은 Intel이며,
  
    %eax, (%eax) 꼴의 문법은 AT&amp;amp;T이다.
  
  Intel 문법을 따르는 대표적인 예시로 MASM(Microsoft Macro Assembler), NASM(Netwide Assembler) 등이 있다.




알아두기



  
…


  어셈블리 연산의 특징

  메모리 주소 간의 연산을 수행할 때,

  특정 주소에서 주소로 직접 연산할 수 없고, 반드시 레지스터를 거쳐간다.

  예를 들어 메모리 0x24 위치의 값을...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 - 매 프레임 처리 성능 테스트 - Update() vs 코루틴</title>
    <link href="https://rito15.github.io/posts/unity-update-vs-coroutine-every-frame/" rel="alternate" type="text/html" title="유니티 - 매 프레임 처리 성능 테스트 - Update() vs 코루틴" />
    <published>2021-11-01T15:02:00+09:00</published>
  
    <updated>2021-11-01T15:02:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-update-vs-coroutine-every-frame/</id>
    <content src="https://rito15.github.io/posts/unity-update-vs-coroutine-every-frame/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      실험 목적



  매 프레임 호출되는 Update() 메소드, 코루틴의 성능 비교




실험 조건



  운영체제 : Windows 10
  유니티 에디터 버전 : 2020.3.17f1
  실행 환경 : 유니티 에디터, Windows Standalone Build(Mono, IL2CPP)




실험 대상


[1] Update()


  각 컴포넌트마다 Update() 작성



  
UpdateEveryFrame.cs


  public class UpdateEveryFrame : MonoBehaviour
{
    private void Update() { }
}
  





[2] CustomUpdate()


  한 컴포넌트의 Update()에서 다른 컴포넌트들의 CustomUpdate...
    </summary>
  

  </entry>

  
  <entry>
    <title>Sphere-AABB Intersection</title>
    <link href="https://rito15.github.io/posts/sphere-aabb-intersection/" rel="alternate" type="text/html" title="Sphere-AABB Intersection" />
    <published>2021-10-26T20:22:00+09:00</published>
  
    <updated>2021-10-29T03:59:19+09:00</updated>
  
    <id>https://rito15.github.io/posts/sphere-aabb-intersection/</id>
    <content src="https://rito15.github.io/posts/sphere-aabb-intersection/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Algorithm" />
    
    <category term="Algorithms" />
    
  

  
    <summary>
      





      Sphere



  
    공간의 한 점에서부터 동일한 거리에 있는 점들의 집합
  
  
    구체의 중심 좌표(Vector3), 반지름(float)을 통해 정의할 수 있다.
  




AABB



  
    Axis-Aligned Bounding Box
  
  
    여섯 면이 모두 각각 X, Y, Z 축에 정렬된 형태의 육면체
  
  
    중심 좌표(Vector3)와 각 축의 크기(Vector3) 또는
최소 좌표(Vector3)와 최대 좌표(Vector3)를 통해 정의할 수 있다.
  






Closest Point to AABB


우선, AABB 바깥의 한 점에서부터

AABB 여섯 면 위의 가장 가까운 점을 찾는다.

2차원 평면의 예시는 다음과 같다.





위의...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# - Global Mouse Hook</title>
    <link href="https://rito15.github.io/posts/cs-global-mouse-hook/" rel="alternate" type="text/html" title="C# - Global Mouse Hook" />
    <published>2021-10-26T03:56:00+09:00</published>
  
    <updated>2021-11-04T16:09:07+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-global-mouse-hook/</id>
    <content src="https://rito15.github.io/posts/cs-global-mouse-hook/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Winform" />
    
  

  
    <summary>
      





      Source Code





  


using System;
using System.Runtime.InteropServices;
using System.Diagnostics;
using System.Threading;

namespace Rito
{
    /*
         [기능]
             - 마우스 누름, 뗌, 휠 올림/내림, 휠클릭 이벤트 글로벌 후킹

         [메소드]
            - 후킹 시작 : Start()
            - 후킹 종료 : Stop()
            - 핸들러 추가 : Mouse~, Middle~, Left~, Right~ 이벤트 핸들러에 메소드 등록
            - 마우스 현재 위치 받아오기 : GetCurso...
    </summary>
  

  </entry>

</feed>



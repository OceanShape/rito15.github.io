

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-02-19T22:18:17+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>OpenGL 공부 - 23 - Mesh, GameObject Class, Multiple Objects</title>
    <link href="https://rito15.github.io/posts/opengl-study-23/" rel="alternate" type="text/html" title="OpenGL 공부 - 23 - Mesh, GameObject Class, Multiple Objects" />
    <published>2021-02-19T16:27:00+09:00</published>
  
    <updated>2021-02-19T16:27:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/opengl-study-23/</id>
    <content src="https://rito15.github.io/posts/opengl-study-23/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="OpenGL" />
    
    <category term="OpenGL Study" />
    
  

  
    <summary>
      





      목표


  프래그먼트 쉐이더 수정
  Mesh 클래스 작성
  GameObject 클래스 작성
  여러 개의 게임오브젝트 렌더링




1. 프래그먼트 쉐이더 수정


  
    각각의 계산이 독립적이고 순차적으로 수행될 수 있도록 변경한다.
  
  
    바뀐 구조
    
      
        1. 색상 계산(텍스쳐, 버텍스 컬러 등)
      
      
        2. 라이트 계산(디퓨즈, 스페큘러, 앰비언트 독립적으로)
      
      
        3. 최종 색상 조립(디퓨즈, 스페큘러, 앰비언트 독립적)
      
    
  




소스코드

// fragment_core.glsl

#version 440

#define saturate(x) clamp(x...
    </summary>
  

  </entry>

  
  <entry>
    <title>레이캐스트 성능 체크</title>
    <link href="https://rito15.github.io/posts/memo-raycast-performance/" rel="alternate" type="text/html" title="레이캐스트 성능 체크" />
    <published>2021-02-19T16:18:00+09:00</published>
  
    <updated>2021-02-19T16:18:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/memo-raycast-performance/</id>
    <content src="https://rito15.github.io/posts/memo-raycast-performance/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      조건

고정

  레이캐스트 시작점
  레이캐스트 방향


변동

  레이캐스트 종류
  레이어마스크
  레이캐스트 거리
  레이캐스트 도형 크기(Sphere, Box)
  레이캐스트 히트 여부


결과




결론

성능에 영향을 주는 것

  레이캐스트 종류
  레이캐스트 히트 여부


성능에 영향을 주지 않는 것

  레이어마스크
  레이캐스트 거리
  레이캐스트 도형 크기(Sphere, Box)


    </summary>
  

  </entry>

  
  <entry>
    <title>커스텀 애트리뷰트</title>
    <link href="https://rito15.github.io/posts/memo-custom-attribute/" rel="alternate" type="text/html" title="커스텀 애트리뷰트" />
    <published>2021-02-19T03:55:00+09:00</published>
  
    <updated>2021-02-19T05:12:32+09:00</updated>
  
    <id>https://rito15.github.io/posts/memo-custom-attribute/</id>
    <content src="https://rito15.github.io/posts/memo-custom-attribute/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Csharp" />
    
    <category term="Csharp Memo" />
    
  

  
    <summary>
      





      필요 네임스페이스

using System;
using System.Linq;


1. 애트리뷰트 클래스 작성

[System.AttributeUsage(System.AttributeTargets.Method)]
public class CustomAttribute : System.Attribute
{
    public string Title { get; }

    public CustomAttribute(string t) =&amp;gt; Title = t;
}


2. 타겟 메소드에 애트리뷰트 장착

public class TargetClass
{
    [CustomAttribute("Title String")]
    public void TargetMethod()
    {

    }
}


3....
    </summary>
  

  </entry>

  
  <entry>
    <title>리플렉션</title>
    <link href="https://rito15.github.io/posts/memo-reflection/" rel="alternate" type="text/html" title="리플렉션" />
    <published>2021-02-19T03:50:00+09:00</published>
  
    <updated>2021-02-19T03:50:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/memo-reflection/</id>
    <content src="https://rito15.github.io/posts/memo-reflection/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Csharp" />
    
    <category term="Csharp Memo" />
    
  

  
    <summary>
      





      필요 네임스페이스
using System;
using System.Reflection;



특정 클래스 타입 가져오기
Type targetType = Type.GetType("클래스명");



네임스페이스 내에 있는 클래스 타입 가져오기
Type targetType = Type.GetType("네임스페이스명.클래스명");



다른 어셈블리(예: DLL) 내에 있는 클래스 타입 가져오기
Type targetType = Type.GetType("네임스페이스명.클래스명, 어셈블리명);



타입으로 객체 생성하기
object instance = Activator.CreateInstance(targetType);



특정 클래스의 메소드 가져오기
MethodInfo targetMethod = targe...
    </summary>
  

  </entry>

  
  <entry>
    <title>OpenGL 공부 - 22 - Light Class</title>
    <link href="https://rito15.github.io/posts/opengl-study-22/" rel="alternate" type="text/html" title="OpenGL 공부 - 22 - Light Class" />
    <published>2021-02-18T15:13:00+09:00</published>
  
    <updated>2021-02-18T15:13:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/opengl-study-22/</id>
    <content src="https://rito15.github.io/posts/opengl-study-22/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="OpenGL" />
    
    <category term="OpenGL Study" />
    
  

  
    <summary>
      





      목표


  DirectionalLight, PointLight 클래스 작성
  프래그먼트 쉐이더에서 각 라이트에 맞는 계산 수행




1. Directional Light



  위치에 관계 없이 방향으로만 작용하는 직광 만들기


DirectionalLight 클래스 작성

class DirectionalLight
{
private:
    glm::vec3 direction; // 빛의 방향과 반전된 L 벡터 방향
    glm::vec3 color;
    float intensity;

public:
    DirectionalLight(const glm::vec3&amp;amp; direction, const glm::vec3&amp;amp; color, const float&amp;amp; intensity...
    </summary>
  

  </entry>

</feed>



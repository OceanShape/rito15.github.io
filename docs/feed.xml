

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-03-12T21:59:32+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>델리게이트가 특정 메소드를 갖고 있는지 확인하기</title>
    <link href="https://rito15.github.io/posts/memo-cs-delegate-has-method/" rel="alternate" type="text/html" title="델리게이트가 특정 메소드를 갖고 있는지 확인하기" />
    <published>2021-03-12T21:52:00+09:00</published>
  
    <updated>2021-03-12T21:52:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/memo-cs-delegate-has-method/</id>
    <content src="https://rito15.github.io/posts/memo-cs-delegate-has-method/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Memo" />
    
    <category term="Csharp Memo" />
    
  

  
    <summary>
      





      //using System;
//using System.Linq;

/// &amp;lt;summary&amp;gt; 델리게이트가 메소드를 갖고 있는지 검사 &amp;lt;/summary&amp;gt;
private static bool CheckDelegateHasMethod&amp;lt;DType&amp;gt;(DType @delegate, DType method) where DType : Delegate
{
    return @delegate?.GetInvocationList()
            .Where(d =&amp;gt; d.Method == method.Method)
            .Count() &amp;gt; 0;
}

private Action&amp;lt;int&amp;gt; del;
private void MethodA(int i) {...
    </summary>
  

  </entry>

  
  <entry>
    <title>Menu Item</title>
    <link href="https://rito15.github.io/posts/unity-editor-menu-item/" rel="alternate" type="text/html" title="Menu Item" />
    <published>2021-03-12T20:10:00+09:00</published>
  
    <updated>2021-03-12T20:10:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-editor-menu-item/</id>
    <content src="https://rito15.github.io/posts/unity-editor-menu-item/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor" />
    
  

  
    <summary>
      





      메뉴 아이템 기본

private const string MenuItemTitle = "Window/Rito/Menu Item";
private const int MenuItemPriority = 123;

[MenuItem(MenuItemTitle)]
private static void MenuItem1()
{
    // ..
}

[MenuItem(MenuItemTitle, false, MenuItemPriority)]
private static void MenuItem2()
{
    // ..
}




활성화/비활성화 설정

private const string MenuItemTitle = "Window/Rito/Menu Item";

[MenuItem(MenuItemTitle, false)...
    </summary>
  

  </entry>

  
  <entry>
    <title>Scripting Define Symbol 스크립트로 제어하기</title>
    <link href="https://rito15.github.io/posts/unity-editor-define-symbol/" rel="alternate" type="text/html" title="Scripting Define Symbol 스크립트로 제어하기" />
    <published>2021-03-12T18:28:00+09:00</published>
  
    <updated>2021-03-12T18:28:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-editor-define-symbol/</id>
    <content src="https://rito15.github.io/posts/unity-editor-define-symbol/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor" />
    
  

  
    <summary>
      





      Scripting Define Symbol?





  
    스크립트에서 #define으로 정의하듯, 프로젝트 전체에서 정의하여 사용할 수 있는 심볼
  
  
    Project Settings - Player - Other Settings - Scripting Define Symbols
  
  
    빌드 타겟마다 달라진다.
  
  
    유니티 에디터 스크립팅을 통해 확인, 추가, 제거할 수 있다.
  




Source Code


using System.Text.RegularExpressions;
using UnityEditor;

public static class DefineSymbolManager
{
    public struct DefineSymbolData
    {...
    </summary>
  

  </entry>

  
  <entry>
    <title>스크립트(.cs), 어셈블리(.dll, .exe) 경로 참조</title>
    <link href="https://rito15.github.io/posts/memo-cs-get-path/" rel="alternate" type="text/html" title="스크립트(.cs), 어셈블리(.dll, .exe) 경로 참조" />
    <published>2021-03-12T18:10:00+09:00</published>
  
    <updated>2021-03-12T18:10:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/memo-cs-get-path/</id>
    <content src="https://rito15.github.io/posts/memo-cs-get-path/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Memo" />
    
    <category term="Csharp Memo" />
    
  

  
    <summary>
      





      스크립트 경로

public static void GetScriptPath([System.Runtime.CompilerServices.CallerFilePath] string filePath = "")
{
    // 1. Script(.cs) Path
    _ = filePath;

    // 2. Folder Path
    string folderPath = System.IO.Path.GetDirectoryName(filePath);

    // 3. Specific Root Folder Path
    string rootFolderName = @"Assets\";
    int rootIndex = folderPath.IndexOf(rootFolderName);
    if (rootIn...
    </summary>
  

  </entry>

  
  <entry>
    <title>컴포넌트의 인스펙터 내 순서를 맨 위로 올리기</title>
    <link href="https://rito15.github.io/posts/unity-editor-component-on-top/" rel="alternate" type="text/html" title="컴포넌트의 인스펙터 내 순서를 맨 위로 올리기" />
    <published>2021-03-12T04:04:00+09:00</published>
  
    <updated>2021-03-12T04:04:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-editor-component-on-top/</id>
    <content src="https://rito15.github.io/posts/unity-editor-component-on-top/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor" />
    
  

  
    <summary>
      





      bool flag = true;
while (flag)
{
    flag = UnityEditorInternal.ComponentUtility.MoveComponentUp(this);
    // 맨 위로 올라갔을 경우 false 리턴
}


    </summary>
  

  </entry>

</feed>





<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-08-07T01:19:23+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Screen Drag Selection(화면에 마우스 드래그 영역 표시하기)</title>
    <link href="https://rito15.github.io/posts/unity-screen-drag-selection/" rel="alternate" type="text/html" title="Screen Drag Selection(화면에 마우스 드래그 영역 표시하기)" />
    <published>2021-08-07T01:11:00+09:00</published>
  
    <updated>2021-08-07T01:11:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-screen-drag-selection/</id>
    <content src="https://rito15.github.io/posts/unity-screen-drag-selection/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Toys" />
    
  

  
    <summary>
      





      Preview




Source Code


using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;

// 날짜 : 2021-08-07 AM 1:12:20
// 작성자 : Rito

/// &amp;lt;summary&amp;gt; 화면에 마우스 드래그로 사각형 선택 영역 표시하기 &amp;lt;/summary&amp;gt;
public class ScreenDragSelection : MonoBehaviour
{
    private Vector2 mPosCur;
    private Vector2 mPosBegin;
    private Vector2 mPosMin;
    private Vector2 mPosMax...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# 구조체 프로퍼티, 구조체 인덱서</title>
    <link href="https://rito15.github.io/posts/cs-struct-property-indexer/" rel="alternate" type="text/html" title="C# 구조체 프로퍼티, 구조체 인덱서" />
    <published>2021-08-06T15:00:00+09:00</published>
  
    <updated>2021-08-06T15:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-struct-property-indexer/</id>
    <content src="https://rito15.github.io/posts/cs-struct-property-indexer/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Grammar" />
    
  

  
    <summary>
      





      구조체의 특징


  초기화(할당), 리턴 등의 동작을 통해 값을 전달할 경우, 구조체가 통째로 복제된다.


struct MyStruct
{
    public float value;
}

class MainClass
{
    private MyStruct ms;

    private MyStruct GetStruct()
    {
        return ms; // 복제하여 리턴
    }

    public void Main()
    {
        MyStruct ms1 = ms;          // 복제하여 초기화
        MyStruct ms2 = GetStruct(); // 복제하여 반환된 값 초기화
    }
}




프로퍼티의 특징


private float _v...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 오브젝트 풀링(Object Pooling)</title>
    <link href="https://rito15.github.io/posts/unity-object-pooling/" rel="alternate" type="text/html" title="유니티 오브젝트 풀링(Object Pooling)" />
    <published>2021-08-06T01:22:00+09:00</published>
  
    <updated>2021-08-06T17:13:49+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-object-pooling/</id>
    <content src="https://rito15.github.io/posts/unity-object-pooling/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Study" />
    
  

  
    <summary>
      





      1. 목표


  
    오브젝트 풀링 기법 이해하기
  
  
    Key 기반 다중 풀링 기법 이해하기
  
  
    오브젝트 풀 매니저 클래스 구현하기
  




2. 개념


게임오브젝트를 생성, 파괴하는 것은 순간적으로 큰 성능 소모 및 프레임 저하를 발생시킬 수 있다.

따라서 생성, 파괴 대신 활성화, 비활성화 방식을 사용하면 순간적인 프레임 저하를 방지할 수 있다.

이를 오브젝트 풀링 기법이라고 하며, 동일한 여러 개의 오브젝트를 하나의 풀(예 : 리스트, 스택, 큐)에  미리 담아 관리한다.

파괴 대신 비활성화하여 풀에 저장하고, 생성 대신 풀에서 꺼내어 활성화하는 방식을 사용한다.



풀 내의 오브젝트는 파괴되지 않고 메모리에 계속 남아있기 때문에,

CPU 성능 소모를...
    </summary>
  

  </entry>

  
  <entry>
    <title>Unity Async Web Request</title>
    <link href="https://rito15.github.io/posts/unity-web-request/" rel="alternate" type="text/html" title="Unity Async Web Request" />
    <published>2021-08-04T15:45:00+09:00</published>
  
    <updated>2021-08-04T15:45:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-web-request/</id>
    <content src="https://rito15.github.io/posts/unity-web-request/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo - Shorts" />
    
  

  
    <summary>
      





      Note



  
    UnityWebRequest는 AsyncOperation 클래스를 상속받는다.
  
  
    그러니까 코루틴에서 yield return으로 기다릴 수 있다.
  
  
    웹페이지를 받아올 경우, 페이지 소스의 &amp;lt;head&amp;gt; 부분에서 인코딩을 꼭 확인해야 한다.
  




Source Code


// using UnityEngine.Networking;

IEnumerator WebReqRoutine()
{
    UnityWebRequest www = UnityWebRequest.Get("https://rito15.github.io/posts/unity-memo-compilation/");
    yield return www.SendWebRequest(...
    </summary>
  

  </entry>

  
  <entry>
    <title>TCP 비동기 소켓으로 간단한 콘솔 채팅 구현하기</title>
    <link href="https://rito15.github.io/posts/cs-tcp-async-socket-chatting/" rel="alternate" type="text/html" title="TCP 비동기 소켓으로 간단한 콘솔 채팅 구현하기" />
    <published>2021-08-03T03:33:00+09:00</published>
  
    <updated>2021-08-06T18:31:06+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-tcp-async-socket-chatting/</id>
    <content src="https://rito15.github.io/posts/cs-tcp-async-socket-chatting/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Socket" />
    
  

  
    <summary>
      





      
  이전 포스팅에서 이어집니다.




1. 채팅을 위한 패킷 설계


[1] ChattingCommand 열거형


  전달하는 패킷의 명령어를 미리 열거형으로 정의한다.
  명령어의 종류는 크게 공통, 클라이언트의 요청, 서버의 통지 3가지로 나뉜다.





   
ChattingCommand.cs


  /// &amp;lt;summary&amp;gt; 채팅 명령어 &amp;lt;/summary&amp;gt;
public enum ChattingCommand
{
    /* [1] 공통 */
    /// &amp;lt;summary&amp;gt; 일반 채팅 &amp;lt;/summary&amp;gt;
    Chat,

    /* [2] 클라이언트 -&amp;gt; 서버 */
    /// &amp;lt;summary&amp;gt; 닉네임 변경 요청 &amp;lt;/summ...
    </summary>
  

  </entry>

</feed>





<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-07-30T18:18:18+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>C#에서 union 구현하기</title>
    <link href="https://rito15.github.io/posts/cs-union-in-csharp/" rel="alternate" type="text/html" title="C#에서 union 구현하기" />
    <published>2021-07-30T18:00:00+09:00</published>
  
    <updated>2021-07-30T18:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-union-in-csharp/</id>
    <content src="https://rito15.github.io/posts/cs-union-in-csharp/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Grammar" />
    
  

  
    <summary>
      





      C언어의 union


union MyUnion
{
    int intValue;     // 4바이트
    short shortValue; // 2바이트
}



  위처럼 C언어에는 서로 다른 타입의 변수가 동일 메모리를 사용하도록 하는 union(공용체)이 존재한다.




C#에서의 union



  C#에는 union 키워드가 존재하지 않지만, 편법을 통해 union 기능을 구현할 수 있다.


[System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
class UnionExample
{
    [System.Runtime.InteropServices.FieldOffset...
    </summary>
  

  </entry>

  
  <entry>
    <title>클래스 타입 객체가 null인지 검사하는 4가지 방법</title>
    <link href="https://rito15.github.io/posts/cs-null-check/" rel="alternate" type="text/html" title="클래스 타입 객체가 null인지 검사하는 4가지 방법" />
    <published>2021-07-30T17:30:00+09:00</published>
  
    <updated>2021-07-30T17:30:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-null-check/</id>
    <content src="https://rito15.github.io/posts/cs-null-check/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Grammar" />
    
  

  
    <summary>
      





      4가지 방법


[1]

instance == null;


// 1-1. == 연산자를 오버로딩 하지 않은 경우
ldloc.0
ldnull
ceq

// 1-2. == 연산자를 오버로딩한 경우
ldnull
call        bool ClassName::op_Equality(class ClassName, class ClassName)




[2]

instance.Equals(null);


ldnull
callvirt   instance bool [mscorlib]System.Object::Equals(object)




[3]

ReferenceEquals(instance, null);


ldloc.0
ldnull
ceq




[4]

// C# 7.0부터 사용 가능
instance is...
    </summary>
  

  </entry>

  
  <entry>
    <title>Infinite Horizontal Scroll (무한 횡스크롤) UI</title>
    <link href="https://rito15.github.io/posts/unity-infinite-horizontal-scroll-ui/" rel="alternate" type="text/html" title="Infinite Horizontal Scroll (무한 횡스크롤) UI" />
    <published>2021-07-28T19:50:00+09:00</published>
  
    <updated>2021-07-28T19:50:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-infinite-horizontal-scroll-ui/</id>
    <content src="https://rito15.github.io/posts/unity-infinite-horizontal-scroll-ui/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Toys" />
    
  

  
    <summary>
      





      Summary


  자식 UI들을 좌우로 무한히 스크롤시키는 컴포넌트




Preview








How To Use


  
    횡스크롤 시킬 UI들을 하나의 부모 오브젝트에 묶는다.
  
  
    해당 부모 오브젝트에 InfiniteHorizontalScroll 컴포넌트를 추가한다.
  
  
    게임 시작 후 좌우 화살표 키를 누르면 각 방향으로 스크롤이 진행된다.
  




Properties

Center UI Size (Vector2)

  중앙에 위치한 UI의 크기


Edge UI Size (Vector2)

  좌우 끝에 위치한 UI의 크기


Space Width (float)

  각 UI 사이의 간격


Transition TIme (float)

  스크롤 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>(Amplify) Tree Growth Shader</title>
    <link href="https://rito15.github.io/posts/unity-amplify-tree-growth/" rel="alternate" type="text/html" title="(Amplify) Tree Growth Shader" />
    <published>2021-07-24T17:21:00+09:00</published>
  
    <updated>2021-07-24T17:21:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-amplify-tree-growth/</id>
    <content src="https://rito15.github.io/posts/unity-amplify-tree-growth/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Amplify Shader" />
    
  

  
    <summary>
      





      Summary



  나무가 성장하는 효과 표현하기




Preview






1. Tree - Body


프로퍼티 목록





쉐이더 에디터 설정




  
    우측 상단을 클릭하여 Blend Mode를 Masked로 변경한다.
  
  
    Mask Clip Value 값을 쉐이더 에디터에서 직접 설정해도 되지만
마테리얼에서 프로퍼티를 통해 조정하려면 우측의 점을 누르고 드롭다운에서 프로퍼티를 선택한다.
  




쉐이더 노드





설명

식물 성장을 표현하기 위해 사용되는 메시는 특별한 조건이 필요하다.

식물이 아래에서 위로 성장하는 것을 표현하기 위해

메시의 UV.Y 값은 가장 하단 정점에서 0을 갖고

+Y축 방향으로 상단에 위치한 정점일수록 점점 커지는 형태를 가...
    </summary>
  

  </entry>

  
  <entry>
    <title>(Amplify) Sea Urchin Shader</title>
    <link href="https://rito15.github.io/posts/unity-amplify-sea-urchin/" rel="alternate" type="text/html" title="(Amplify) Sea Urchin Shader" />
    <published>2021-07-23T15:15:00+09:00</published>
  
    <updated>2021-07-23T15:15:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-amplify-sea-urchin/</id>
    <content src="https://rito15.github.io/posts/unity-amplify-sea-urchin/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Amplify Shader" />
    
  

  
    <summary>
      





      Summary



  가시 삐쭉삐쭉한 성게 쉐이더




1. 기본


Preview







Properties




  
    
      프로퍼티
      설명
    
  
  
    
      Edge length
      테셀레이션 간격(작을수록 촘촘해진다)
    
    
      Tiling
      가시 개수 비율
    
    
      Sharpness
      가시의 뾰족한 정도
    
    
      Height
      가시의 길이
    
    
      Body Color
      구체 색상
    
    
      Thron
      가시 색상
    
    
      Color Mix Threshold
      두 색상의...
    </summary>
  

  </entry>

</feed>



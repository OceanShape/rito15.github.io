

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-02-04T17:19:05+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>C++ Smart Debugging</title>
    <link href="https://rito15.github.io/posts/cpp-smart-debugging/" rel="alternate" type="text/html" title="C++ Smart Debugging" />
    <published>2021-02-04T16:56:00+09:00</published>
  
    <updated>2021-02-04T16:56:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cpp-smart-debugging/</id>
    <content src="https://rito15.github.io/posts/cpp-smart-debugging/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C++" />
    
    <category term="C++ Memo" />
    
  

  
    <summary>
      





      Note

C++에는 미리 정의된 동적 매크로가 있다.

__FILE__

  해당 위치의 소스파일 경로를 문자열로 가져온다.


__LINE__

  해당 위치의 줄 번호를 정수로 가져온다.



그리고 매크로의 매개변수를 무조건 스트링으로 변환하여 가져올 수 있는 방법이 존재한다.

#define MACRO(x) #x

  x에 위치한 코드를 문자열로 변환하여 가져온다.




이를 이용하면 해당 소스코드와 실행 위치 정보를 간단히 출력할 수 있다.

#include &amp;lt;iostream&amp;gt;
using namespace std;

#define ShowCodeInfo(x) cout &amp;lt;&amp;lt; "Code : " &amp;lt;&amp;lt; #x &amp;lt;&amp;lt; endl\
	&amp;lt;&amp;lt; "Line :...
    </summary>
  

  </entry>

  
  <entry>
    <title>OpenGL 공부 - 08</title>
    <link href="https://rito15.github.io/posts/opengl-study-08/" rel="alternate" type="text/html" title="OpenGL 공부 - 08" />
    <published>2021-02-04T15:45:00+09:00</published>
  
    <updated>2021-02-04T15:45:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/opengl-study-08/</id>
    <content src="https://rito15.github.io/posts/opengl-study-08/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="OpenGL" />
    
    <category term="OpenGL Study" />
    
  

  
    <summary>
      





      목표


  OpenGL 내에서 디버깅하기




공부 내용


  OpenGL 내에서 에러가 발생하거나 코드를 잘못 작성한 경우, 친절한 에러 메시지보다는 그저 검은 화면을 볼 가능성이 높다.





  그래서 디버깅을 하려면, OpenGL에서 제공하는 몇몇 메소드와 매크로를 활용해야 한다.




  
    glGetError
    
      에러가 발생한 경우 에러 플래그를 리턴한다.
    
  



  
    
      return GLenum
      에러 플래그 - GL_NO_ERROR - GL_INVALID_ENUM - GL_INVALID_VALUE - GL_INVALID_OPERATION - GL_INVALID_FRAMEBUFFER_OPERATION - GL_OUT_OF_...
    </summary>
  

  </entry>

  
  <entry>
    <title>OpenGL 공부 - 07</title>
    <link href="https://rito15.github.io/posts/opengl-study-07/" rel="alternate" type="text/html" title="OpenGL 공부 - 07" />
    <published>2021-02-03T16:32:00+09:00</published>
  
    <updated>2021-02-03T16:32:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/opengl-study-07/</id>
    <content src="https://rito15.github.io/posts/opengl-study-07/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="OpenGL" />
    
    <category term="OpenGL Study" />
    
  

  
    <summary>
      





      목표


  인덱스 버퍼의 사용과 이해




공부 내용


삼각형 그리기

  삼각형을 하나 그리려면, 버텍스 3개가 필요하다.


float positions[6] =
{
    -0.5f, -0.5f,
     0.0f,  0.5f,
     0.5f, -0.5f,
};



  GPU는 전달받은 버텍스들을 순서대로 확인하여 3개씩 짝지어서 하나의 폴리곤을 그려준다.
  이 때, 3개의 버텍스가 순서대로 시계 반대 방향으로 위치해야 폴리곤의 전면이 그려진다.



사각형 그리기

  사각형을 하나 그리려면 삼각형이 2개 필요하므로, 결국 버텍스 6개가 필요하다.





  
    그런데 두 삼각형이 두 개의 버텍스를 공유하므로, 여섯 개의 버텍스를 전달하는건 버텍스를 두 개만큼 손해보는 것과 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>인스펙터에 오토 프로퍼티 표시하기</title>
    <link href="https://rito15.github.io/posts/show-property-on-inspector/" rel="alternate" type="text/html" title="인스펙터에 오토 프로퍼티 표시하기" />
    <published>2021-02-02T17:08:00+09:00</published>
  
    <updated>2021-02-02T17:08:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/show-property-on-inspector/</id>
    <content src="https://rito15.github.io/posts/show-property-on-inspector/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      Memo


public GameObject Property1 =&amp;gt; Field1;
private GameObject Field1;


이런 형태의 프로퍼티라면,

public GameObject Property1 =&amp;gt; field1;

[SerializeField]
private GameObject field1;


이렇게 대상 필드에 [SerializeField]를 붙여서 인스펙터에 표시할 수 있다.

하지만

[SerializeField]
public GameObject Property2 { get; private set; }


이런 오토 속성 프로퍼티는 프로퍼티 앞에 [SerializeField]를 붙여도 인스펙터에 표시되지 않는다.

그런데,

[field: SerializeField...
    </summary>
  

  </entry>

  
  <entry>
    <title>OpenGL 공부 - 06</title>
    <link href="https://rito15.github.io/posts/opengl-study-06/" rel="alternate" type="text/html" title="OpenGL 공부 - 06" />
    <published>2021-02-02T14:21:00+09:00</published>
  
    <updated>2021-02-02T14:21:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/opengl-study-06/</id>
    <content src="https://rito15.github.io/posts/opengl-study-06/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="OpenGL" />
    
    <category term="OpenGL Study" />
    
  

  
    <summary>
      





      목표


  쉐이더를 파일로 분리하여, 파일로부터 읽어와 사용하기




공부 내용


쉐이더 파일 작성하기

  솔루션 디렉터리 - [Resources/Shaders] 폴더 생성
  Shaders 폴더 내에 [Basic.shader] 파일 생성
  속성 - 디버깅 - 작업 디렉터리에 $(ProjectDir)가 포함되어 있으므로 상대경로에서 불러오기 가능
  기존의 쉐이더 코드를 옮겨와 약간 수정하여 내용 작성


#shader vertex
#version 330 core

layout(location = 0) in vec4 position;

void main()
{
   gl_Position = position;
};

#shader fragment
#version 330 core

layout(l...
    </summary>
  

  </entry>

</feed>



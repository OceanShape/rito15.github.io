

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Game Programmer</subtitle>
  <updated>2021-12-07T17:45:13+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Fisher-Yates Shuffle 간단 정리</title>
    <link href="https://rito15.github.io/posts/fisher-yates-shuffle/" rel="alternate" type="text/html" title="Fisher-Yates Shuffle 간단 정리" />
    <published>2021-12-06T18:00:00+09:00</published>
  
    <updated>2021-12-06T18:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/fisher-yates-shuffle/</id>
    <content src="https://rito15.github.io/posts/fisher-yates-shuffle/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Algorithm" />
    
    <category term="Algorithms" />
    
  

  
    <summary>
      





      1. Original Fisher-Yates Shuffle


알고리즘


  
…


  

  길이 n인 배열이 있다.

  

  

  [0, n-1] 범위에서 무작위 인덱스를 뽑아, 그 위치의 원소를 새로운 배열의 인덱스 0 위치에 넣는다.

  

  

  기존 배열에서 n-1 인덱스에 있는 원소를 구멍 뚫린 위치에 채워 넣는다.

  뒤에서 한 칸씩 밀어서 빈 칸을 채우는 방법도 있겠으나, 그러면 O(n)에 해당하므로 정말 굉장히 비효율적이다.

  끝에서 꺼내어 채워 넣으면 O(1)이므로 쓸만하다.

  

  

  이번에는 [0, n-2] 범위에서 무작위 인덱스를 뽑아 새로운 배열의 인덱스 1에 넣고,

  마찬가지로 n-2 인덱스의 원소를 구멍 뚫린 위치에 채워 넣는다.

  

...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 - 깔끔하고 보기 좋은 변수명 짓기</title>
    <link href="https://rito15.github.io/posts/unity-naming-variables-neatly/" rel="alternate" type="text/html" title="유니티 - 깔끔하고 보기 좋은 변수명 짓기" />
    <published>2021-12-04T17:50:00+09:00</published>
  
    <updated>2021-12-05T22:21:16+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-naming-variables-neatly/</id>
    <content src="https://rito15.github.io/posts/unity-naming-variables-neatly/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Tips" />
    
  

  
    <summary>
      





      Intro


코딩을 하다보면 변수의 이름을 지을 때 많은 고민을 하게 되고, 생각보다 많은 시간이 소요된다.

아무 의미 없는 이름을 짓게 되면 개발을 이어 나가면서 스스로도 혼란을 겪게 되고,

만일 협업을 하고 있었다면, 솔직히 혼나도 할 말이 없다.

그러니 ‘보기에도 깔끔하고 한 눈에 의미를 알아볼 수 있는 이름’을 짓기 위해 언제나 고심하게 된다.



Naming Rules


의미 있고 규칙성 있는 이름을 짓기 위해, 몇가지 규칙을 정할 필요가 있다.


  카멜 케이스(Camel Case)를 사용한다.
  이름은 명사형으로 짓는다.
  접두어 + 몸체 + 접미어 형태로 짓는다.
  단어의 개수는 4개를 넘지 않는다.




[1] 카멜 케이스

1번 규칙은 기본 중의 기본이다.

카멜 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>(Amplify) Screen Effect - Pixelation</title>
    <link href="https://rito15.github.io/posts/unity-amplify-screen-pixelation/" rel="alternate" type="text/html" title="(Amplify) Screen Effect - Pixelation" />
    <published>2021-11-26T16:16:00+09:00</published>
  
    <updated>2021-11-26T16:16:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-amplify-screen-pixelation/</id>
    <content src="https://rito15.github.io/posts/unity-amplify-screen-pixelation/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Amplify Shader" />
    
  

  
    <summary>
      





      Summary


  
    화면 전체를 도트로 찍은 듯한 픽셀화 효과를 적용한다.
  
  
    스크린 이펙트 적용 애셋 : Link
  




Preview










Properties



  Pixelation
    
      픽셀화 강도(0 ~ 0.99)
    
  




Nodes






Download


  2021_1126_Screen Effect_Pixelate.zip



    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 - 드로우 콜과 배칭 개념 간단 정리</title>
    <link href="https://rito15.github.io/posts/unity-draw-call-and-batching/" rel="alternate" type="text/html" title="유니티 - 드로우 콜과 배칭 개념 간단 정리" />
    <published>2021-11-22T20:13:00+09:00</published>
  
    <updated>2021-11-22T20:13:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-draw-call-and-batching/</id>
    <content src="https://rito15.github.io/posts/unity-draw-call-and-batching/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Optimization" />
    
  

  
    <summary>
      





      1. CPU와 GPU의 상호작용


CPU에서 GPU에 명령하기

  일반적으로 CPU에서 렌더링, 상태 변경 등의 명령을 GPU에 전달한다.
  그런데 GPU가 바쁘게 작업하는 도중이라면, CPU는 GPU의 작업이 끝나기를 하염없이 기다리게 될 수 있다.
  따라서 커맨드 패턴(Command Pattern)과 메시지 큐(Message Queue)에 의한 비동기 방식을 활용한다.
  CPU에서 GPU에 전달할 명령(Command)을 임시 공간에 담아 두고, GPU가 여유 될 때 명령을 하나씩 꺼내어 처리한다.


Command Buffer(커맨드 버퍼)

  CPU의 각 스레드에서는 GPU에 전달할 렌더링 관련 명령을 모듈화하여 커맨드 버퍼에 차곡차곡 쌓아 임시로 저장한다.
  그리고 GPU의 공유 커...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 - FixedUpdate()에서 이동, 회전 구현 시 버벅임 현상 해결하기</title>
    <link href="https://rito15.github.io/posts/unity-fixed-update-and-stuttering/" rel="alternate" type="text/html" title="유니티 - FixedUpdate()에서 이동, 회전 구현 시 버벅임 현상 해결하기" />
    <published>2021-11-22T00:23:00+09:00</published>
  
    <updated>2021-11-29T05:05:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-fixed-update-and-stuttering/</id>
    <content src="https://rito15.github.io/posts/unity-fixed-update-and-stuttering/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Tips" />
    
  

  
    <summary>
      





      Update()와 FixedUpdate()


Update()

Update() 메소드는 프레임 당 한 번씩 호출된다.

그리고 이동, 회전 등을 구현할 경우 프레임 간의 호출 간격을 고려하고

단위 시간 당 일정한 수치로 기능을 구현하기 위해 Time.deltaTime을 사용한다.



FixedUpdate()

리지드바디를 사용할 때, 즉 물리 엔진의 기능을 이용할 때 사용하는 메소드.

FixedUpdate() 메소드는 Fixed Time Step 주기(기본 0.02초)마다 한 번씩 호출되도록 보정된다.

그냥 ‘호출된다’가 아니고, ‘호출되도록 보정된다’.

왜냐하면, FixedUpdate()의 호출은 Update()를 호출하는 게임 루프와 별도의 루프, 혹은 멀티스레드에 의해 발생하지 않기 때...
    </summary>
  

  </entry>

</feed>



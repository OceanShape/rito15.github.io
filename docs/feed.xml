

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-09-05T03:08:03+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Script Line Counter(유니티 C# 스크립트 개수, 전체 라인 수 계산기)</title>
    <link href="https://rito15.github.io/posts/unity-cs-script-line-counter/" rel="alternate" type="text/html" title="Script Line Counter(유니티 C# 스크립트 개수, 전체 라인 수 계산기)" />
    <published>2021-09-04T23:23:00+09:00</published>
  
    <updated>2021-09-04T23:23:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-cs-script-line-counter/</id>
    <content src="https://rito15.github.io/posts/unity-cs-script-line-counter/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor Utilities" />
    
  

  
    <summary>
      





      Summary



  지정한 폴더의 모든 하위 경로에서 C# 스크립트의 개수와 라인 수를 계산하여 보여줍니다.




Preview






How To Use



  
    [Window] - [Rito] - [C# Script Line Counter]를 클릭합니다.
  
  
    열린 창에서 Folder 부분에 Project 윈도우의 폴더 애셋을 드래그 앤 드롭합니다.
  
  
    Folder에 아무 폴더도 지정하지 않을 경우, Assets 폴더 전체를 대상으로 합니다.
  
  
    Calculate 버튼을 클릭합니다.
  




Download



  Script Line Counter.unitypackage




Github


  https://github.com/r...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 에디터 윈도우 - 스크롤 바 생성하기</title>
    <link href="https://rito15.github.io/posts/unity-editor-window-scrollbar/" rel="alternate" type="text/html" title="유니티 에디터 윈도우 - 스크롤 바 생성하기" />
    <published>2021-09-04T23:11:00+09:00</published>
  
    <updated>2021-09-04T23:11:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-editor-window-scrollbar/</id>
    <content src="https://rito15.github.io/posts/unity-editor-window-scrollbar/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor Memo" />
    
  

  
    <summary>
      





      Memo



  
    에디터 윈도우 내의 내용들이 세로 범위를 넘어설 경우, 윈도우 우측에 스크롤 바를 생성한다.
  
  
    BeginScrollView ~ EndScrollView 사이 영역에만 스크롤바를 생성하고,
위아래 영역은 기존처럼 고정된다.
  


[SerializeField]
private Vector2 scrollPos = Vector2.zero;

private void OnGUI()
{
    scrollPos = EditorGUILayout.BeginScrollView(scrollPos);

    // Codes....

    EditorGUILayout.EndScrollView();
}



    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 - 폴더 애셋으로부터 폴더 전체 경로 구하기</title>
    <link href="https://rito15.github.io/posts/unity-find-folder-path-from-folder-asset/" rel="alternate" type="text/html" title="유니티 - 폴더 애셋으로부터 폴더 전체 경로 구하기" />
    <published>2021-09-04T19:59:00+09:00</published>
  
    <updated>2021-09-04T19:59:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-find-folder-path-from-folder-asset/</id>
    <content src="https://rito15.github.io/posts/unity-find-folder-path-from-folder-asset/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor Memo" />
    
  

  
    <summary>
      





      1. 삽질



   
…


  아무 생각 없이 재귀로 폴더도 찾고, 메타 파일도 찾고, Regex로 guid도 찾고…

  정신 차려보니 아래와 같은 소스 코드를 짜고 있었다.

  /// &amp;lt;summary&amp;gt; 지정한 폴더 애셋의 전체 경로 찾기 &amp;lt;/summary&amp;gt;
private string FindFolderAssetFullPath(DefaultAsset folderAsset)
{
    // Note: Assets 디렉토리로부터 하위 폴더 전부 순회하며 폴더 이름 일치하는 경로 탐색

    DirectoryInfo rootDirectory = Directory.CreateDirectory(Application.dataPath);
    string found = null;

...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# 하위 폴더, 파일의 전체 경로 찾기</title>
    <link href="https://rito15.github.io/posts/cs-memo-find-internal-path/" rel="alternate" type="text/html" title="C# 하위 폴더, 파일의 전체 경로 찾기" />
    <published>2021-09-04T19:45:00+09:00</published>
  
    <updated>2021-09-04T19:45:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-memo-find-internal-path/</id>
    <content src="https://rito15.github.io/posts/cs-memo-find-internal-path/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      Summary


  재귀를 이용하여 특정 폴더 하위 경로에 있는 파일, 폴더 전체 경로 찾기




Source Code


Usage

string folder = FindFolderFullPath(@"c:\MyFolder", "FolderName");
string file = FindFileFullPath(@"c:\MyFolder", "FileName.txt");




Code

/// &amp;lt;summary&amp;gt; 특정 폴더의 모든 하위 경로에서 이름이 일치하는 폴더 경로 찾기 &amp;lt;/summary&amp;gt;
private string FindFolderFullPath(string rootFolderPath, string folderName)
{
    DirectoryInfo rootDirect...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# 비동기 Task를 사용하면서 흔히 발생하는 실수</title>
    <link href="https://rito15.github.io/posts/cs-async-task-mistakes/" rel="alternate" type="text/html" title="C# 비동기 Task를 사용하면서 흔히 발생하는 실수" />
    <published>2021-09-04T04:09:00+09:00</published>
  
    <updated>2021-09-04T04:09:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-async-task-mistakes/</id>
    <content src="https://rito15.github.io/posts/cs-async-task-mistakes/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Threading" />
    
  

  
    <summary>
      





      Mistake


private static void Main()
{
    Task t = Task.Run(() =&amp;gt; TaskBody(3));

    t.Wait(); // TaskBody(3)의 종료를 대기하려고 시도

    Console.WriteLine("End");
}

static async void TaskBody(int count)
{
    for (int i = 0; i &amp;lt; count; i++)
    {
        await Task.Delay(500);
        Console.WriteLine($"[{i}] Thread : {Thread.CurrentThread.ManagedThreadId}");
    }
}


위의 소스 코드는 얼핏 보면 문제가 없어 보...
    </summary>
  

  </entry>

</feed>





<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-06-29T04:16:47+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>간단한 앰플리파이 쉐이더 예제 모음</title>
    <link href="https://rito15.github.io/posts/simple-amplify-shader-examples/" rel="alternate" type="text/html" title="간단한 앰플리파이 쉐이더 예제 모음" />
    <published>2021-06-27T04:24:00+09:00</published>
  
    <updated>2021-06-28T03:22:13+09:00</updated>
  
    <id>https://rito15.github.io/posts/simple-amplify-shader-examples/</id>
    <content src="https://rito15.github.io/posts/simple-amplify-shader-examples/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Amplify Shader" />
    
  

  
    <summary>
      





      1. Vertex


Scale Up and Down





Heartbeat



( max( sin(T * F), 1-S ) - (1-S) ) * A

T : Time
F : Frequency
S : Sensitivity
A : Amplitude




World Position Offset





World Position Offset (Same Scale)





2. Color


UV Mask




  Step의 A, B 입력을 서로 바꿀 경우, 마스크 색상 반전




Smooth UV Mask




  Smoothstep의 Min, Max 입력을 서로 바꿀 경우, 마스크 색상 반전




UV Circle





Smooth UV Circle





UV Mask Dissol...
    </summary>
  

  </entry>

  
  <entry>
    <title>Process, Thread, ThreadPool, Task 개념 간단 정리</title>
    <link href="https://rito15.github.io/posts/cs-process-thread-threadpool-task/" rel="alternate" type="text/html" title="Process, Thread, ThreadPool, Task 개념 간단 정리" />
    <published>2021-06-25T21:21:00+09:00</published>
  
    <updated>2021-06-25T21:21:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-process-thread-threadpool-task/</id>
    <content src="https://rito15.github.io/posts/cs-process-thread-threadpool-task/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      Process



  
    메모리에 적재되어 실행되는 프로그램
  
  
    운영체제로부터 자원을 할당받아 수행되는 작업의 단위
  
  
    Code, Data, Heap, Stack 메모리 공간을 독립적으로 갖는다.
  




Thread



  
    프로세스의 자원을 사용하는 실행 흐름의 단위
  
  
    프로세스의 Code, Data, Heap 영역을 공유한다.
  
  
    각 스레드마다 Stack 영역만 독립적으로 갖는다.
  
  
    컨텍스트 스위칭이 발생할 때 Stack 정보를 비롯해 간단한 정보만 저장하기 때문에, 프로세스의 컨텍스트 스위칭보다 빠르다.
  
  
    C#에는 Thread 클래스가 있다.
  
  
    기본적으로 Foregroun...
    </summary>
  

  </entry>

  
  <entry>
    <title>Camera Depth, Sorting Layer, Sorting Group</title>
    <link href="https://rito15.github.io/posts/unity-depth-sorting-layer-sorting-group/" rel="alternate" type="text/html" title="Camera Depth, Sorting Layer, Sorting Group" />
    <published>2021-06-25T20:40:00+09:00</published>
  
    <updated>2021-06-25T20:40:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-depth-sorting-layer-sorting-group/</id>
    <content src="https://rito15.github.io/posts/unity-depth-sorting-layer-sorting-group/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo - Shorts" />
    
  

  
    <summary>
      





      Camera Depth(Z)



  
    카메라로부터의 거리
  
  
    가까울수록 먼저 보인다.
  




Sorting Layer vs. Camera Depth



  
    Sorting Layer가 Camera Depth보다 우선적으로 깊이를 결정한다.
  
  
    Sorting Layer 설정이 같은 경우, Camera Depth가 깊이를 결정한다.
  




Sorting Layer



  
    서로 다른 Sorting Layer의 경우, 인덱스의 값이 클수록(0 &amp;lt; 1 &amp;lt; 2 &amp;lt; …) 먼저 보인다.
  
  
    같은 Sorting Layer 내에서는 Order In layer 값이 클수록 먼저 보인다.
  




Sorting Group
...
    </summary>
  

  </entry>

  
  <entry>
    <title>앰플리파이 쉐이더 입문자를 위한 60가지 노드 모음</title>
    <link href="https://rito15.github.io/posts/amplify-shader-60-nodes-for-beginners/" rel="alternate" type="text/html" title="앰플리파이 쉐이더 입문자를 위한 60가지 노드 모음" />
    <published>2021-06-24T01:23:00+09:00</published>
  
    <updated>2021-06-28T03:22:13+09:00</updated>
  
    <id>https://rito15.github.io/posts/amplify-shader-60-nodes-for-beginners/</id>
    <content src="https://rito15.github.io/posts/amplify-shader-60-nodes-for-beginners/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Amplify Shader" />
    
  

  
    <summary>
      





      목표



  앰플리파이 쉐이더 그래프를 다루기 위해 필요한, 아주 기초적인 60가지 노드 익히기




목차



  프로퍼티(변수)
    
      Int (0)
      Float (1)
      Vector2 (2)
      Vector3 (3)
      Vector4 (4)
      Color (5)
      Texture Sample (T)
    
  
  상수
    
      PI
      Tau
    
  
  정점 데이터
    
      Vertex Position
      World Position
      Vertex Normal
      World Normal
      Vertex Color
    
  
  UV
    
      Vertex ...
    </summary>
  

  </entry>

  
  <entry>
    <title>Black Hole &amp;amp; World Position Offset</title>
    <link href="https://rito15.github.io/posts/unity-black-hole-effect-shadergraph/" rel="alternate" type="text/html" title="Black Hole &amp;amp; World Position Offset" />
    <published>2021-06-20T03:33:00+09:00</published>
  
    <updated>2021-06-20T03:33:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-black-hole-effect-shadergraph/</id>
    <content src="https://rito15.github.io/posts/unity-black-hole-effect-shadergraph/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="URP Shader Graph" />
    
  

  
    <summary>
      





      Summary


World Position Offset Shader


  정점이 순차적으로 월드의 특정 좌표에 빨려 들어가는 쉐이더




Black Hole Shader


  영역 내의 색상을 왜곡하는 쉐이더




Preview






WPO - Step 1 : 정점 좌표의 이동


World Space의 좌표에 대해 계산해야 하지만,

마스터 노드의 Vertex Position 입력은 Object Space여야 한다.

따라서 두 가지 선택지가 있다.



[1] World Space에서 계산하고 최종적으로 Object Space로 변환





[2] 처음부터 Object Space로 변환하고 Object Space에서 계산





기본적으로 쉐이더 내에서의 계산은 대부분 Object...
    </summary>
  

  </entry>

</feed>





<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-09-07T00:19:10+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Unity - 트리 구조 데이터 직렬화하기</title>
    <link href="https://rito15.github.io/posts/unity-serialize-tree-object/" rel="alternate" type="text/html" title="Unity - 트리 구조 데이터 직렬화하기" />
    <published>2021-09-06T23:23:00+09:00</published>
  
    <updated>2021-09-06T23:23:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-serialize-tree-object/</id>
    <content src="https://rito15.github.io/posts/unity-serialize-tree-object/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Study" />
    
  

  
    <summary>
      





      트리(Tree) 자료구조


class TreeNode
{
    public TreeNode[] children;
}


위와 같이 자기 타입의 배열 또는 컬렉션을 필드로 갖는 구조를 트리 자료구조라고 한다.

자식 및 하위 노드들을 순회하기 위해 재귀적 호출을 많이 사용한다.





직렬화(Serialization)


데이터를 저장 또는 통신하기 위한 목적으로 변형하는 것을 의미한다.

직렬화 결과의 형태로는 대표적으로 JSON, XML, byte[], string 등이 있다.

그리고 유니티 엔진에서는 SerializedObject가 있다.

단어 의미 그대로 직렬화된 오브젝트라는 뜻이다.



MonoBahaviour 내의 public, 혹은 직렬화 가능한 필드는

인스펙트에 그냥 그대로 보...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# 간단한 트릭 - 널 체크</title>
    <link href="https://rito15.github.io/posts/cs-null-check-trick/" rel="alternate" type="text/html" title="C# 간단한 트릭 - 널 체크" />
    <published>2021-09-06T04:40:00+09:00</published>
  
    <updated>2021-09-06T04:40:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-null-check-trick/</id>
    <content src="https://rito15.github.io/posts/cs-null-check-trick/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      Note


public class MyClass
{
    public int[] dataArray;

    public bool IsEmpty()
    {
        return dataArray == null || dataArray.Length == 0;
    }
}


위와 같이 내부에 간단한 배열을 담고 있는 클래스가 있다.

MyClass m = null;

Console.WriteLine(m.IsEmpty());


그리고 위와 같이 객체가 null인 상태에서 인스턴스 메소드를 호출하면

당연히 NullReferenceException이 발생한다.



그런데 데이터의 유효성 검사만 확인하면 되고, 이 검사가 매우 빈번한 경우에

매번 m != null &amp;amp;&amp;amp; !m.I...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 IMGUI 이벤트, 그리고 Getting control n's position... 예외 처리</title>
    <link href="https://rito15.github.io/posts/unity-imgui-event-and-handle-exception/" rel="alternate" type="text/html" title="유니티 IMGUI 이벤트, 그리고 Getting control n's position... 예외 처리" />
    <published>2021-09-05T18:00:00+09:00</published>
  
    <updated>2021-09-06T05:13:06+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-imgui-event-and-handle-exception/</id>
    <content src="https://rito15.github.io/posts/unity-imgui-event-and-handle-exception/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor" />
    
  

  
    <summary>
      





      IMGUI 이벤트


유니티 IMGUI에서 OnGUI() 메소드가 호출되는 이벤트 타이밍은

기본적으로 Layout과 Repaint가 있다.

Layout은 GUI 레이아웃 컨트롤을 생성하는 단계이고,

Repaint은 GUI 컨트롤들을 화면에 그려내는 단계이다.

별도의 상호작용이나 간섭이 없다면 Layout과 Repaint가 반복된다.

Event.current를 통해 현재 IMGUI 환경에서의 이벤트 객체를 참조할 수 있고,

Event.current.type을 통해 현재 처리되는 이벤트의 종류를 알 수 있다.



사용자 상호작용이 발생할 경우, 사용자 상호작용에 따라

마우스를 눌렀으면 Layout - MouseDown 순서로 이벤트가 발생하여

MouseDown 이벤트에서 사용자의 마우스 입...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# 메모리 동기화가 필요한 경우, 아닌 경우 간단 정리</title>
    <link href="https://rito15.github.io/posts/cs-memory-synchronization-memo/" rel="alternate" type="text/html" title="C# 메모리 동기화가 필요한 경우, 아닌 경우 간단 정리" />
    <published>2021-09-05T14:54:00+09:00</published>
  
    <updated>2021-09-05T14:54:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-memory-synchronization-memo/</id>
    <content src="https://rito15.github.io/posts/cs-memory-synchronization-memo/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Threading" />
    
  

  
    <summary>
      





      전혀 필요하지 않은 경우



  
    싱글 스레드 환경인 경우
  
  
    단일 공유 변수에 대해 하나의 스레드만 쓰기를 수행하는 경우
  
  
    하나의 스레드가 공유 변수를 읽는 동안 다른 스레드가 변경할 염려가 없는 경우
  
  
    어떤 작업을 동시에 하나의 스레드만 해야 할 필요가 없는 경우
  




원자성(Atomic) 보장이 필요한 경우



  
    여러 스레드가 공유 변수에 쓰기를 수행하는 경우
  
  
    완전히 동일한 순간에 접근하는 경우를 방지한다.
  
  
    Interlocked를 많이 사용한다.
  


static int sharedValue = 0;

static void TaskBody1()
{
    Interlocked.Incr...
    </summary>
  

  </entry>

  
  <entry>
    <title>Script Line Counter(유니티 C# 스크립트 개수, 전체 라인 수 계산기)</title>
    <link href="https://rito15.github.io/posts/unity-cs-script-line-counter/" rel="alternate" type="text/html" title="Script Line Counter(유니티 C# 스크립트 개수, 전체 라인 수 계산기)" />
    <published>2021-09-04T23:23:00+09:00</published>
  
    <updated>2021-09-04T23:23:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-cs-script-line-counter/</id>
    <content src="https://rito15.github.io/posts/unity-cs-script-line-counter/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor Utilities" />
    
  

  
    <summary>
      





      Summary



  지정한 폴더의 모든 하위 경로에서 C# 스크립트의 개수와 라인 수를 계산하여 보여줍니다.




Preview






How To Use



  
    [Window] - [Rito] - [C# Script Line Counter]를 클릭합니다.
  
  
    열린 창에서 Folder 부분에 Project 윈도우의 폴더 애셋을 드래그 앤 드롭합니다.
  
  
    Folder에 아무 폴더도 지정하지 않을 경우, Assets 폴더 전체를 대상으로 합니다.
  
  
    Calculate 버튼을 클릭합니다.
  




Download



  Script Line Counter.unitypackage




Github


  https://github.com/r...
    </summary>
  

  </entry>

</feed>



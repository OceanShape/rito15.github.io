

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-08-05T02:29:39+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Unity Async Web Request</title>
    <link href="https://rito15.github.io/posts/unity-web-request/" rel="alternate" type="text/html" title="Unity Async Web Request" />
    <published>2021-08-04T15:45:00+09:00</published>
  
    <updated>2021-08-04T15:45:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-web-request/</id>
    <content src="https://rito15.github.io/posts/unity-web-request/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo - Shorts" />
    
  

  
    <summary>
      





      Note



  
    UnityWebRequest는 AsyncOperation 클래스를 상속받는다.
  
  
    그러니까 코루틴에서 yield return으로 기다릴 수 있다.
  
  
    웹페이지를 받아올 경우, 페이지 소스의 &amp;lt;head&amp;gt; 부분에서 인코딩을 꼭 확인해야 한다.
  




Source Code


// using UnityEngine.Networking;

IEnumerator WebReqRoutine()
{
    UnityWebRequest www = UnityWebRequest.Get("https://rito15.github.io/posts/unity-memo-compilation/");
    yield return www.SendWebRequest(...
    </summary>
  

  </entry>

  
  <entry>
    <title>TCP 비동기 소켓으로 간단한 콘솔 채팅 구현하기</title>
    <link href="https://rito15.github.io/posts/cs-tcp-async-socket-chatting/" rel="alternate" type="text/html" title="TCP 비동기 소켓으로 간단한 콘솔 채팅 구현하기" />
    <published>2021-08-03T03:33:00+09:00</published>
  
    <updated>2021-08-03T03:33:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-tcp-async-socket-chatting/</id>
    <content src="https://rito15.github.io/posts/cs-tcp-async-socket-chatting/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Socket" />
    
  

  
    <summary>
      





      
  이전 포스팅에서 이어집니다.




1. 채팅을 위한 패킷 설계


[1] ChattingCommand 열거형


  전달하는 패킷의 명령어를 미리 열거형으로 정의한다.
  명령어의 종류는 크게 공통, 클라이언트의 요청, 서버의 통지 3가지로 나뉜다.





   
ChattingCommand.cs


  /// &amp;lt;summary&amp;gt; 채팅 명령어 &amp;lt;/summary&amp;gt;
public enum ChattingCommand
{
    /* [1] 공통 */
    /// &amp;lt;summary&amp;gt; 일반 채팅 &amp;lt;/summary&amp;gt;
    Chat,

    /* [2] 클라이언트 -&amp;gt; 서버 */
    /// &amp;lt;summary&amp;gt; 닉네임 변경 요청 &amp;lt;/summ...
    </summary>
  

  </entry>

  
  <entry>
    <title>TCP 비동기 소켓 서버, 클라이언트 - 패킷 고려하기</title>
    <link href="https://rito15.github.io/posts/06-cs-tcp-async-socket-with-packet.md/" rel="alternate" type="text/html" title="TCP 비동기 소켓 서버, 클라이언트 - 패킷 고려하기" />
    <published>2021-08-02T00:06:00+09:00</published>
  
    <updated>2021-08-03T03:50:36+09:00</updated>
  
    <id>https://rito15.github.io/posts/06-cs-tcp-async-socket-with-packet.md/</id>
    <content src="https://rito15.github.io/posts/06-cs-tcp-async-socket-with-packet.md/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Socket" />
    
  

  
    <summary>
      





      
  이전 포스팅에서 이어집니다.




ReceiveBuffer, SendBuffer



  소켓 통신을 통한 데이터 전달 시 단순히 byte[]를 주고 받는 것에서 그치지 않고, 정말로 ‘패킷’을 주고 받기 위해 필요하다.




ReceiveBuffer 클래스



  
    각 세션마다 하나의 ReceiveBuffer 객체를 갖는다.
  
  
    TCP 소켓 통신을 통해 수신한 패킷이 완전하지 않을 경우를 대비해 사용된다.
  
  
    패킷을 수신하자마자 이를 완전히 처리하는 것이 아니라, ReceiveBuffer에 차례로 저장한다.
  
  
    ReceiveBuffer 앞부분부터 패킷의 헤더를 확인하여, 지정된 길이만큼 패킷이 완전히 도착한 것이 확인된 경우에만 해당 패킷을...
    </summary>
  

  </entry>

  
  <entry>
    <title>TCP 비동기 소켓 서버, 클라이언트 기본</title>
    <link href="https://rito15.github.io/posts/05-cs-tcp-async-socket-basic.md/" rel="alternate" type="text/html" title="TCP 비동기 소켓 서버, 클라이언트 기본" />
    <published>2021-08-02T00:05:00+09:00</published>
  
    <updated>2021-08-02T00:05:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/05-cs-tcp-async-socket-basic.md/</id>
    <content src="https://rito15.github.io/posts/05-cs-tcp-async-socket-basic.md/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Socket" />
    
  

  
    <summary>
      





      비동기 소켓 통신 방식


Socket 객체에는 ~Async() 형태로 명명된 비동기 메소드들이 존재한다.


  AcceptAsync(SocketAsyncEventArgs)
  ConnectAsync(SocketAsyncEventArgs)
  DisconnectAsync(SocketAsyncEventArgs)
  ConnectAsync(SocketAsyncEventArgs)
  ReceiveAsync(SocketAsyncEventArgs)
  ReceiveFromAsync(SocketAsyncEventArgs)
  SendAsync(SocketAsyncEventArgs)
  SendToAsync(SocketAsyncEventArgs)


이런 비동기 메소드들은 모두 내부적으로 워커 스레드에서 동작한다...
    </summary>
  

  </entry>

  
  <entry>
    <title>UDP 소켓 서버, 클라이언트 기본</title>
    <link href="https://rito15.github.io/posts/04-cs-udp-socket-server-client-basic.md/" rel="alternate" type="text/html" title="UDP 소켓 서버, 클라이언트 기본" />
    <published>2021-08-02T00:04:00+09:00</published>
  
    <updated>2021-08-02T00:04:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/04-cs-udp-socket-server-client-basic.md/</id>
    <content src="https://rito15.github.io/posts/04-cs-udp-socket-server-client-basic.md/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Socket" />
    
  

  
    <summary>
      





      UDP 소켓 통신의 특징



  서버와 클라이언트 간의 1:1 연결이 생성되지 않는다.
  리스너 소켓이 필요하지 않다.
  Listen(), Connect() 과정이 없다.
  소켓의 .ReceiveFrom(), .SendTo() 메소드를 통해 엔드포인트와 데이터를 주고 받는다.




소켓 통신 과정


서버

  서버 IP 주소, 포트를 통해 서버 엔드포인트 생성
  서버 소켓 객체 생성
  Bind(서버 엔드포인트 정보를 서버 소켓에 연동)
  클라이언트에 대응할 리모트 엔드포인트 생성
  Send =&amp;gt; 리모트 엔드포인트
  Receive &amp;lt;= 리모트 엔드포인트
  Close


클라이언트

  서버 IP 주소, 포트를 통해 서버 엔드포인트 생성
  클라이언트 소켓 객체 생성
  리...
    </summary>
  

  </entry>

</feed>



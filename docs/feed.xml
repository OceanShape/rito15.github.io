

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-01-24T17:20:13+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Frame Rate Checker</title>
    <link href="https://rito15.github.io/posts/frame-rate-checker/" rel="alternate" type="text/html" title="Frame Rate Checker" />
    <published>2021-01-24T17:00:00+09:00</published>
  
    <updated>2021-01-24T17:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/frame-rate-checker/</id>
    <content src="https://rito15.github.io/posts/frame-rate-checker/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Toys" />
    
  

  
    <summary>
      





      Note


  실제 FPS 값을 실시간, 최근 N개의 평균, 최소, 최댓값으로 확인할 수 있습니다.
  게임 진행 동안 텍스트의 위치, 색상, 크기, GUI 표시 상태를 실시간으로 변경할 수 있습니다.


Preview




Source Code



  https://github.com/rito15/Unity_Toys


    </summary>
  

  </entry>

  
  <entry>
    <title>Job System</title>
    <link href="https://rito15.github.io/posts/job-system/" rel="alternate" type="text/html" title="Job System" />
    <published>2021-01-24T13:15:00+09:00</published>
  
    <updated>2021-01-24T13:15:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/job-system/</id>
    <content src="https://rito15.github.io/posts/job-system/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Study" />
    
  

  
    <summary>
      





      개념


  유니티에서 안전한 멀티스레딩을 구현하는 시스템
  스레드를 별도로 생성하지 않으며, 유니티의 워커스레드에 작업을 지시할 수 있게 한다.
  잡 대기열에 잡을 배치하면 워커 스레드가 잡 대기열에서 항목을 가져와 실행한다.
  Native Container를 이용해 잡의 수행 결과를 메인 스레드와 공유한다.
  버스트 컴파일러를 이용하여 추가적인 성능 향상을 기대할 수 있다.






장점


  다수의 작은 작업들을 처리하기에 좋으며, 속도가 빠르다.
  스레드를 추가로 만들고 관리하지 않아도 되므로 메모리를 절약할 수 있다.
  유니티 콘솔을 이용해 디버깅할 수 있다.
  메인 스레드의 데이터를 잡의 스택에 깊은 복사를 하여 복사본으로 사용하므로 Race Condition이 발생하지 않는...
    </summary>
  

  </entry>

  
  <entry>
    <title>Fog of War</title>
    <link href="https://rito15.github.io/posts/fog-of-war/" rel="alternate" type="text/html" title="Fog of War" />
    <published>2021-01-19T23:15:00+09:00</published>
  
    <updated>2021-01-24T08:41:09+09:00</updated>
  
    <id>https://rito15.github.io/posts/fog-of-war/</id>
    <content src="https://rito15.github.io/posts/fog-of-war/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Study" />
    
  

  
    <summary>
      





      개념


  맵 전체에 걸쳐 RGBA(0, 0, 0, a)의 텍스쳐를 씌워 시야를 표현한다.
  지정한 유닛이 현재 위치한 영역들은 a = 0,
  지정한 유닛이 한 번이라도 위치했던 영역들은 a = 0.5~0.8,
  지정한 유닛이 한 번도 방문하지 않은 영역은 a = 1로 표현한다.




구현 방법

[1] 카메라와 지상 사이에 안개 플레인 사용


  
    시야의 역할을 해줄 검정색 플레인을 카메라와 지상 사이에 위치시킨다.
  
  
    맵 전체를 좌표 형태의 2차원배열로 관리하여, 유닛들이 현재 위치한 영역, 방문했던 영역, 한 번도 방문하지 않은 영역의 정보를 실시간으로 저장한다.
  
  
    카메라와 해당 유닛들 사이에서 시야를 적용할 안개 플레인의 로컬좌표를 구하고 정점 색...
    </summary>
  

  </entry>

  
  <entry>
    <title>Ray Marching</title>
    <link href="https://rito15.github.io/posts/ray-marching/" rel="alternate" type="text/html" title="Ray Marching" />
    <published>2021-01-19T23:15:00+09:00</published>
  
    <updated>2021-01-24T08:41:09+09:00</updated>
  
    <id>https://rito15.github.io/posts/ray-marching/</id>
    <content src="https://rito15.github.io/posts/ray-marching/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Study" />
    
  

  
    <summary>
      





      레이 마칭이란?



  
    폴리곤의 정점 정보를 이용하는 기존의 3D 렌더링 방식과는 달리, 레이를 전진시켜(Ray Marching) 표면의 정보를 얻어 오브젝트를 그려내는 기법
  
  
    레이 마칭의 모든 모델링들은 폴리곤이 아닌 거리 함수(SDF : Signed Distance Function)로 표면의 정보가 계산된다.
  







  한 점(RO : Ray Origin, 위의 그림에서 Camera)에서 스크린의 각각의 픽셀을 향한 방향(RD : Ray Direction, 위의 그림에서 Image)들을 향해
레이 캐스팅을 하여, 각 레이마다 여러 스텝(Step)으로 나누어 레이를 전진시키게 된다.




  


  
    한 번의 스텝마다 존재하는 모든 SDF를 각각 계산하...
    </summary>
  

  </entry>

  
  <entry>
    <title>Pixelater</title>
    <link href="https://rito15.github.io/posts/pixelater/" rel="alternate" type="text/html" title="Pixelater" />
    <published>2021-01-19T22:56:00+09:00</published>
  
    <updated>2021-01-19T22:56:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/pixelater/</id>
    <content src="https://rito15.github.io/posts/pixelater/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Toys" />
    
  

  
    <summary>
      





      Note


  렌더 텍스쳐의 해상도를 강제로 변경하여 화면을 픽셀화시킵니다.
  스크립트를 카메라에 부착하여 사용합니다.


Preview



Reference


  https://www.youtube.com/watch?v=5rMkh9sl2bM


Source Code


  https://github.com/rito15/Unity_Toys


    </summary>
  

  </entry>

</feed>





<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-09-12T16:36:12+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>(Amplify) Screen Effect - Ice (Frozen)</title>
    <link href="https://rito15.github.io/posts/unity-amplify-screen-ice/" rel="alternate" type="text/html" title="(Amplify) Screen Effect - Ice (Frozen)" />
    <published>2021-09-12T01:01:00+09:00</published>
  
    <updated>2021-09-12T01:01:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-amplify-screen-ice/</id>
    <content src="https://rito15.github.io/posts/unity-amplify-screen-ice/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Amplify Shader" />
    
  

  
    <summary>
      





      Summary


  
    화면이 가장자리부터 얼어붙는 효과
  
  
    스크린 이펙트 적용 애셋 : Link
  




Preview








Properties



  Ice Texture
    
      얼음 효과로 사용할 텍스쳐
      원하는 텍스쳐를 사용하면 된다.
    
  
  Range
    
      효과 적용 범위 (0 ~ 1)
    
  
  Noise Scale
    
      기본 값 : 4
      노이즈 적용 스케일
    
  
  Power A
    
      기본 값 : 3
      영역의 모양
      작을수록 원형, 클수록 사각형에 가까워진다.
    
  
  Power B
    
      기본 값 : 2
      ...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# Deconstructor</title>
    <link href="https://rito15.github.io/posts/cs-deconstructor/" rel="alternate" type="text/html" title="C# Deconstructor" />
    <published>2021-09-11T04:32:00+09:00</published>
  
    <updated>2021-09-11T04:32:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-deconstructor/</id>
    <content src="https://rito15.github.io/posts/cs-deconstructor/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Grammar" />
    
  

  
    <summary>
      





      Deconstructor


class Student
{
    public int id;
    public string name;
}


클래스가 있다.

Student student = new Student();


객체도 있다.

(int id, string name) = student;


위와 같이 한다고 해서 객체의 필드들이 각각의 변수에 할당되지는 않는다.



class Student
{
    public int id;
    public string name;

    public void Deconstruct(out int id, out string name)
    {
        id = this.id;
        name = this.name;
    }
}


그런데 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# Tuple, ValueTuple</title>
    <link href="https://rito15.github.io/posts/cs-tuple-and-value-tuple/" rel="alternate" type="text/html" title="C# Tuple, ValueTuple" />
    <published>2021-09-11T03:45:00+09:00</published>
  
    <updated>2021-09-11T03:45:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-tuple-and-value-tuple/</id>
    <content src="https://rito15.github.io/posts/cs-tuple-and-value-tuple/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Grammar" />
    
  

  
    <summary>
      





      Note


Tuple, ValueTuple은 C# 7.0에 처음 도입되었다.

두 개 이상의 타입을 함께 묶어 사용할 때,

클래스나 구조체를 따로 정의하지 않고 곧바로 사용할 수 있게 해준다.



Tuple


클래스 튜플 타입.

클래스 타입이므로 전달할 때 복사가 발생하지 않고, 참조를 전달한다.

Tuple&amp;lt;T1, T2&amp;gt; 같이 명시적으로 타입명을 작성해야 한다.



Tuple&amp;lt;int, float&amp;gt; tuple = (10, 20f); // 불가능


아쉽게도 위와 같은 편리한 생성은 안되고,

Tuple&amp;lt;int, float&amp;gt; tuple = new Tuple&amp;lt;int, float&amp;gt;(10, 20f);


이렇게 명시적으로 생성자를 호출하여 생성해야 한다.
...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# 타입별 GetHashCode() 성능</title>
    <link href="https://rito15.github.io/posts/cs-gethashcode-cost-by-types/" rel="alternate" type="text/html" title="C# 타입별 GetHashCode() 성능" />
    <published>2021-09-11T00:30:00+09:00</published>
  
    <updated>2021-09-11T03:05:19+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-gethashcode-cost-by-types/</id>
    <content src="https://rito15.github.io/posts/cs-gethashcode-cost-by-types/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      Curiosity


타입별로 GetHashCode()의 성능 비용이 얼마나 달라지는지 간단히 확인해본다.

사용자 정의 타입은 GetHashCode() 메소드를 임의로 오버라이드 하지 않고 확인한다.



사용자 정의 타입

public struct Struct1 { }
public struct Struct2
{
    public int a, b, c, d, e, f, g;
    public long A, B, C, D, E, F, G, H;
}
public struct Struct3
{
    public int i1, i2, i3, i4, i5, i6, i7, i8;
    public long l1, l2, l3, l4, l5, l6, l7, l8;
    public double d1, d...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# Dictionary 탐색 성능 - 선형 탐색과 비교</title>
    <link href="https://rito15.github.io/posts/cs-dictionary-search-cost/" rel="alternate" type="text/html" title="C# Dictionary 탐색 성능 - 선형 탐색과 비교" />
    <published>2021-09-11T00:01:00+09:00</published>
  
    <updated>2021-09-11T00:01:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-dictionary-search-cost/</id>
    <content src="https://rito15.github.io/posts/cs-dictionary-search-cost/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      Curiosity


Dictionary&amp;lt;TKey, TValue&amp;gt;는 해시 테이블 자료구조의 제네릭 구현 클래스로서,

Key-Value 꼴로 데이터를 저장하고

Key에 대한 해시 계산을 통해 Value를 탐색할 수 있다.

그렇다면 Key-Value를 저장하는 배열의 선형 탐색과 비교했을 때,

Dictionary의 탐색 성능은 어느 정도일까?



Benchmark


Benchmark DotNet을 이용하여

&amp;lt;TKey, TValue&amp;gt; 꼴의 딕셔너리, 이를 페어로 저장하는 배열을 비교한다.

TKey와 TValue는 임의의 클래스 타입을 사용한다.

public class Data { } // 임의의 클래스 타입

public class Pair
{
    public Dat...
    </summary>
  

  </entry>

</feed>





<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-08-06T17:09:58+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>C# 구조체 프로퍼티, 구조체 인덱서</title>
    <link href="https://rito15.github.io/posts/cs-struct-property-indexer/" rel="alternate" type="text/html" title="C# 구조체 프로퍼티, 구조체 인덱서" />
    <published>2021-08-06T15:00:00+09:00</published>
  
    <updated>2021-08-06T15:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-struct-property-indexer/</id>
    <content src="https://rito15.github.io/posts/cs-struct-property-indexer/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Grammar" />
    
  

  
    <summary>
      





      구조체의 특징


  초기화(할당), 리턴 등의 동작을 통해 값을 전달할 경우, 구조체가 통째로 복제된다.


struct MyStruct
{
    public float value;
}

class MainClass
{
    private MyStruct ms;

    private MyStruct GetStruct()
    {
        return ms; // 복제하여 리턴
    }

    public void Main()
    {
        MyStruct ms1 = ms;          // 복제하여 초기화
        MyStruct ms2 = GetStruct(); // 복제하여 반환된 값 초기화
    }
}




프로퍼티의 특징


private float _v...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 오브젝트 풀링(Object Pooling)</title>
    <link href="https://rito15.github.io/posts/unity-object-pooling/" rel="alternate" type="text/html" title="유니티 오브젝트 풀링(Object Pooling)" />
    <published>2021-08-06T01:22:00+09:00</published>
  
    <updated>2021-08-06T01:22:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-object-pooling/</id>
    <content src="https://rito15.github.io/posts/unity-object-pooling/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Study" />
    
  

  
    <summary>
      





      1. 목표


  
    오브젝트 풀링 기법 이해하기
  
  
    Key 기반 다중 풀링 기법 이해하기
  
  
    오브젝트 풀 매니저 클래스 구현하기
  




2. 개념


게임오브젝트를 생성, 파괴하는 것은 순간적으로 큰 성능 소모 및 프레임 저하를 발생시킬 수 있다.

따라서 생성, 파괴 대신 활성화, 비활성화 방식을 사용하면 순간적인 프레임 저하를 방지할 수 있다.

이를 오브젝트 풀링 기법이라고 하며, 동일한 여러 개의 오브젝트를 하나의 풀(예 : 리스트, 스택, 큐)에  미리 담아 관리한다.

파괴 대신 비활성화하여 풀에 저장하고, 생성 대신 풀에서 꺼내어 활성화하는 방식을 사용한다.



풀 내의 오브젝트는 파괴되지 않고 메모리에 계속 남아있기 때문에,

CPU 성능 소모를...
    </summary>
  

  </entry>

  
  <entry>
    <title>Unity Async Web Request</title>
    <link href="https://rito15.github.io/posts/unity-web-request/" rel="alternate" type="text/html" title="Unity Async Web Request" />
    <published>2021-08-04T15:45:00+09:00</published>
  
    <updated>2021-08-04T15:45:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-web-request/</id>
    <content src="https://rito15.github.io/posts/unity-web-request/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo - Shorts" />
    
  

  
    <summary>
      





      Note



  
    UnityWebRequest는 AsyncOperation 클래스를 상속받는다.
  
  
    그러니까 코루틴에서 yield return으로 기다릴 수 있다.
  
  
    웹페이지를 받아올 경우, 페이지 소스의 &amp;lt;head&amp;gt; 부분에서 인코딩을 꼭 확인해야 한다.
  




Source Code


// using UnityEngine.Networking;

IEnumerator WebReqRoutine()
{
    UnityWebRequest www = UnityWebRequest.Get("https://rito15.github.io/posts/unity-memo-compilation/");
    yield return www.SendWebRequest(...
    </summary>
  

  </entry>

  
  <entry>
    <title>TCP 비동기 소켓으로 간단한 콘솔 채팅 구현하기</title>
    <link href="https://rito15.github.io/posts/cs-tcp-async-socket-chatting/" rel="alternate" type="text/html" title="TCP 비동기 소켓으로 간단한 콘솔 채팅 구현하기" />
    <published>2021-08-03T03:33:00+09:00</published>
  
    <updated>2021-08-03T03:33:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-tcp-async-socket-chatting/</id>
    <content src="https://rito15.github.io/posts/cs-tcp-async-socket-chatting/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Socket" />
    
  

  
    <summary>
      





      
  이전 포스팅에서 이어집니다.




1. 채팅을 위한 패킷 설계


[1] ChattingCommand 열거형


  전달하는 패킷의 명령어를 미리 열거형으로 정의한다.
  명령어의 종류는 크게 공통, 클라이언트의 요청, 서버의 통지 3가지로 나뉜다.





   
ChattingCommand.cs


  /// &amp;lt;summary&amp;gt; 채팅 명령어 &amp;lt;/summary&amp;gt;
public enum ChattingCommand
{
    /* [1] 공통 */
    /// &amp;lt;summary&amp;gt; 일반 채팅 &amp;lt;/summary&amp;gt;
    Chat,

    /* [2] 클라이언트 -&amp;gt; 서버 */
    /// &amp;lt;summary&amp;gt; 닉네임 변경 요청 &amp;lt;/summ...
    </summary>
  

  </entry>

  
  <entry>
    <title>TCP 비동기 소켓 서버, 클라이언트 - 패킷 고려하기</title>
    <link href="https://rito15.github.io/posts/06-cs-tcp-async-socket-with-packet.md/" rel="alternate" type="text/html" title="TCP 비동기 소켓 서버, 클라이언트 - 패킷 고려하기" />
    <published>2021-08-02T00:06:00+09:00</published>
  
    <updated>2021-08-03T03:50:36+09:00</updated>
  
    <id>https://rito15.github.io/posts/06-cs-tcp-async-socket-with-packet.md/</id>
    <content src="https://rito15.github.io/posts/06-cs-tcp-async-socket-with-packet.md/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Socket" />
    
  

  
    <summary>
      





      
  이전 포스팅에서 이어집니다.




ReceiveBuffer, SendBuffer



  소켓 통신을 통한 데이터 전달 시 단순히 byte[]를 주고 받는 것에서 그치지 않고, 정말로 ‘패킷’을 주고 받기 위해 필요하다.




ReceiveBuffer 클래스



  
    각 세션마다 하나의 ReceiveBuffer 객체를 갖는다.
  
  
    TCP 소켓 통신을 통해 수신한 패킷이 완전하지 않을 경우를 대비해 사용된다.
  
  
    패킷을 수신하자마자 이를 완전히 처리하는 것이 아니라, ReceiveBuffer에 차례로 저장한다.
  
  
    ReceiveBuffer 앞부분부터 패킷의 헤더를 확인하여, 지정된 길이만큼 패킷이 완전히 도착한 것이 확인된 경우에만 해당 패킷을...
    </summary>
  

  </entry>

</feed>



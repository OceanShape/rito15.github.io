

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-09-05T15:48:33+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>C# 메모리 동기화가 필요한 경우, 아닌 경우 간단 정리</title>
    <link href="https://rito15.github.io/posts/cs-memory-synchronization-memo/" rel="alternate" type="text/html" title="C# 메모리 동기화가 필요한 경우, 아닌 경우 간단 정리" />
    <published>2021-09-05T14:54:00+09:00</published>
  
    <updated>2021-09-05T14:54:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-memory-synchronization-memo/</id>
    <content src="https://rito15.github.io/posts/cs-memory-synchronization-memo/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Threading" />
    
  

  
    <summary>
      





      전혀 필요하지 않은 경우



  
    싱글 스레드 환경인 경우
  
  
    단일 공유 변수에 대해 하나의 스레드만 쓰기를 수행하는 경우
  
  
    하나의 스레드가 공유 변수를 읽는 동안 다른 스레드가 변경할 염려가 없는 경우
  
  
    어떤 작업을 동시에 하나의 스레드만 해야 할 필요가 없는 경우
  




원자성(Atomic) 보장이 필요한 경우



  
    여러 스레드가 공유 변수에 쓰기를 수행하는 경우
  
  
    완전히 동일한 순간에 접근하는 경우를 방지한다.
  
  
    Interlocked를 많이 사용한다.
  


static int sharedValue = 0;

static void TaskBody1()
{
    Interlocked.Incr...
    </summary>
  

  </entry>

  
  <entry>
    <title>Script Line Counter(유니티 C# 스크립트 개수, 전체 라인 수 계산기)</title>
    <link href="https://rito15.github.io/posts/unity-cs-script-line-counter/" rel="alternate" type="text/html" title="Script Line Counter(유니티 C# 스크립트 개수, 전체 라인 수 계산기)" />
    <published>2021-09-04T23:23:00+09:00</published>
  
    <updated>2021-09-04T23:23:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-cs-script-line-counter/</id>
    <content src="https://rito15.github.io/posts/unity-cs-script-line-counter/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor Utilities" />
    
  

  
    <summary>
      





      Summary



  지정한 폴더의 모든 하위 경로에서 C# 스크립트의 개수와 라인 수를 계산하여 보여줍니다.




Preview






How To Use



  
    [Window] - [Rito] - [C# Script Line Counter]를 클릭합니다.
  
  
    열린 창에서 Folder 부분에 Project 윈도우의 폴더 애셋을 드래그 앤 드롭합니다.
  
  
    Folder에 아무 폴더도 지정하지 않을 경우, Assets 폴더 전체를 대상으로 합니다.
  
  
    Calculate 버튼을 클릭합니다.
  




Download



  Script Line Counter.unitypackage




Github


  https://github.com/r...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 에디터 윈도우 - 스크롤 바 생성하기</title>
    <link href="https://rito15.github.io/posts/unity-editor-window-scrollbar/" rel="alternate" type="text/html" title="유니티 에디터 윈도우 - 스크롤 바 생성하기" />
    <published>2021-09-04T23:11:00+09:00</published>
  
    <updated>2021-09-05T03:09:14+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-editor-window-scrollbar/</id>
    <content src="https://rito15.github.io/posts/unity-editor-window-scrollbar/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor Memo" />
    
  

  
    <summary>
      





      Memo



  
    에디터 윈도우 내의 내용들이 세로 범위를 넘어설 경우, 윈도우 우측에 스크롤 바를 생성한다.
  
  
    BeginScrollView ~ EndScrollView 사이 영역에만 스크롤바를 생성하고,
위아래 영역은 기존처럼 고정된다.
  


[SerializeField]
private Vector2 scrollPos = Vector2.zero;

private void OnGUI()
{
    scrollPos = EditorGUILayout.BeginScrollView(scrollPos);

    // Codes....

    EditorGUILayout.EndScrollView();
}



    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 - 폴더 애셋으로부터 폴더 전체 경로 구하기</title>
    <link href="https://rito15.github.io/posts/unity-find-folder-path-from-folder-asset/" rel="alternate" type="text/html" title="유니티 - 폴더 애셋으로부터 폴더 전체 경로 구하기" />
    <published>2021-09-04T19:59:00+09:00</published>
  
    <updated>2021-09-04T19:59:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-find-folder-path-from-folder-asset/</id>
    <content src="https://rito15.github.io/posts/unity-find-folder-path-from-folder-asset/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor Memo" />
    
  

  
    <summary>
      





      1. 삽질



   
…


  아무 생각 없이 재귀로 폴더도 찾고, 메타 파일도 찾고, Regex로 guid도 찾고…

  정신 차려보니 아래와 같은 소스 코드를 짜고 있었다.

  /// &amp;lt;summary&amp;gt; 지정한 폴더 애셋의 전체 경로 찾기 &amp;lt;/summary&amp;gt;
private string FindFolderAssetFullPath(DefaultAsset folderAsset)
{
    // Note: Assets 디렉토리로부터 하위 폴더 전부 순회하며 폴더 이름 일치하는 경로 탐색

    DirectoryInfo rootDirectory = Directory.CreateDirectory(Application.dataPath);
    string found = null;

...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# 하위 폴더, 파일의 전체 경로 찾기</title>
    <link href="https://rito15.github.io/posts/cs-memo-find-internal-path/" rel="alternate" type="text/html" title="C# 하위 폴더, 파일의 전체 경로 찾기" />
    <published>2021-09-04T19:45:00+09:00</published>
  
    <updated>2021-09-04T19:45:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-memo-find-internal-path/</id>
    <content src="https://rito15.github.io/posts/cs-memo-find-internal-path/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      Summary


  재귀를 이용하여 특정 폴더 하위 경로에 있는 파일, 폴더 전체 경로 찾기




Source Code


Usage

string folder = FindFolderFullPath(@"c:\MyFolder", "FolderName");
string file = FindFileFullPath(@"c:\MyFolder", "FileName.txt");




Code

/// &amp;lt;summary&amp;gt; 특정 폴더의 모든 하위 경로에서 이름이 일치하는 폴더 경로 찾기 &amp;lt;/summary&amp;gt;
private string FindFolderFullPath(string rootFolderPath, string folderName)
{
    DirectoryInfo rootDirect...
    </summary>
  

  </entry>

</feed>



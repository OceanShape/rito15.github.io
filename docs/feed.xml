

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-08-08T03:14:47+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>C# 패킷을 byte[]로 직렬화하는 다양한 방법</title>
    <link href="https://rito15.github.io/posts/cs-serializations-to-byte-array/" rel="alternate" type="text/html" title="C# 패킷을 byte[]로 직렬화하는 다양한 방법" />
    <published>2021-08-08T02:34:00+09:00</published>
  
    <updated>2021-08-08T02:34:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-serializations-to-byte-array/</id>
    <content src="https://rito15.github.io/posts/cs-serializations-to-byte-array/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      Note



  
    비교적 단순한 형태의 패킷들을 정의한다.
  
  
    패킷을 다양한 방법으로 직렬화하여 byte[] 타입 버퍼에 순서대로 넣으며, 성능을 검사한다.
  
  
    직렬화된 결과의 크기는 패킷 내 모든 필드의 크기의 합이어야 한다.
  
  
    문자열 패킷은 어차피 공통적으로 인코딩을 거쳐야 하므로, 제외한다.
  
  
    BenchmarkDotNet를 통해 벤치마크를 진행한다.
  




패킷 정의



   
Source Code


  public class Packet
{
    public ushort size;
    public ushort id;

    public Packet(ushort id)
    {
        this.id = ...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# Benchmark DotNet</title>
    <link href="https://rito15.github.io/posts/cs-benchmark-dotnet/" rel="alternate" type="text/html" title="C# Benchmark DotNet" />
    <published>2021-08-07T16:16:00+09:00</published>
  
    <updated>2021-08-07T16:16:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-benchmark-dotnet/</id>
    <content src="https://rito15.github.io/posts/cs-benchmark-dotnet/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      설치



  비주얼 스튜디오 - 프로젝트 - NuGet 패키지 관리 - Benchmark를 검색하여 설치




사용법


[1] 테스트 대상 클래스

네임스페이스

using BenchmarkDotNet;
using BenchmarkDotNet.Attributes;




클래스 애트리뷰트


  [SimpleJob()]
    
      https://benchmarkdotnet.org/articles/guides/choosing-run-strategy.html
      실행 옵션을 간단히 지정할 수 있다.
      launchCount : 벤치마크 전체 반복 횟수(기본값 : 1)
      warmupCount : 실제 벤치마크 수행 전, 가상 벤치마크 횟수(기본값 : 10~15 내외)
 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>Screen Drag Selection(화면에 마우스 드래그 영역 표시하기)</title>
    <link href="https://rito15.github.io/posts/unity-screen-drag-selection/" rel="alternate" type="text/html" title="Screen Drag Selection(화면에 마우스 드래그 영역 표시하기)" />
    <published>2021-08-07T01:11:00+09:00</published>
  
    <updated>2021-08-07T01:11:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-screen-drag-selection/</id>
    <content src="https://rito15.github.io/posts/unity-screen-drag-selection/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Toys" />
    
  

  
    <summary>
      





      Preview




Source Code


using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;

// 날짜 : 2021-08-07 AM 1:12:20
// 작성자 : Rito

/// &amp;lt;summary&amp;gt; 화면에 마우스 드래그로 사각형 선택 영역 표시하기 &amp;lt;/summary&amp;gt;
public class ScreenDragSelection : MonoBehaviour
{
    private Vector2 mPosCur;
    private Vector2 mPosBegin;
    private Vector2 mPosMin;
    private Vector2 mPosMax...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# 구조체 프로퍼티, 구조체 인덱서</title>
    <link href="https://rito15.github.io/posts/cs-struct-property-indexer/" rel="alternate" type="text/html" title="C# 구조체 프로퍼티, 구조체 인덱서" />
    <published>2021-08-06T15:00:00+09:00</published>
  
    <updated>2021-08-06T15:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-struct-property-indexer/</id>
    <content src="https://rito15.github.io/posts/cs-struct-property-indexer/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Grammar" />
    
  

  
    <summary>
      





      구조체의 특징


  초기화(할당), 리턴 등의 동작을 통해 값을 전달할 경우, 구조체가 통째로 복제된다.


struct MyStruct
{
    public float value;
}

class MainClass
{
    private MyStruct ms;

    private MyStruct GetStruct()
    {
        return ms; // 복제하여 리턴
    }

    public void Main()
    {
        MyStruct ms1 = ms;          // 복제하여 초기화
        MyStruct ms2 = GetStruct(); // 복제하여 반환된 값 초기화
    }
}




프로퍼티의 특징


private float _v...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 오브젝트 풀링(Object Pooling)</title>
    <link href="https://rito15.github.io/posts/unity-object-pooling/" rel="alternate" type="text/html" title="유니티 오브젝트 풀링(Object Pooling)" />
    <published>2021-08-06T01:22:00+09:00</published>
  
    <updated>2021-08-06T17:13:49+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-object-pooling/</id>
    <content src="https://rito15.github.io/posts/unity-object-pooling/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Study" />
    
  

  
    <summary>
      





      1. 목표


  
    오브젝트 풀링 기법 이해하기
  
  
    Key 기반 다중 풀링 기법 이해하기
  
  
    오브젝트 풀 매니저 클래스 구현하기
  




2. 개념


게임오브젝트를 생성, 파괴하는 것은 순간적으로 큰 성능 소모 및 프레임 저하를 발생시킬 수 있다.

따라서 생성, 파괴 대신 활성화, 비활성화 방식을 사용하면 순간적인 프레임 저하를 방지할 수 있다.

이를 오브젝트 풀링 기법이라고 하며, 동일한 여러 개의 오브젝트를 하나의 풀(예 : 리스트, 스택, 큐)에  미리 담아 관리한다.

파괴 대신 비활성화하여 풀에 저장하고, 생성 대신 풀에서 꺼내어 활성화하는 방식을 사용한다.



풀 내의 오브젝트는 파괴되지 않고 메모리에 계속 남아있기 때문에,

CPU 성능 소모를...
    </summary>
  

  </entry>

</feed>





<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Game Programmer</subtitle>
  <updated>2021-11-22T01:16:58+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>유니티 - FixedUpdate()에서 이동, 회전 구현 시 버벅임 현상 해결하기</title>
    <link href="https://rito15.github.io/posts/unity-fixed-update-and-stuttering/" rel="alternate" type="text/html" title="유니티 - FixedUpdate()에서 이동, 회전 구현 시 버벅임 현상 해결하기" />
    <published>2021-11-22T00:23:00+09:00</published>
  
    <updated>2021-11-22T00:23:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-fixed-update-and-stuttering/</id>
    <content src="https://rito15.github.io/posts/unity-fixed-update-and-stuttering/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Tips" />
    
  

  
    <summary>
      





      Update()와 FixedUpdate()


Update()

Update() 메소드는 프레임 당 한 번씩 호출된다.

그리고 이동, 회전 등을 구현할 경우 프레임 간의 호출 간격을 고려하고

단위 시간 당 일정한 수치로 기능을 구현하기 위해 Time.deltaTime을 사용한다.



FixedUpdate()

리지드바디를 사용할 때, 즉 물리 엔진의 기능을 이용할 때 사용하는 메소드.

FixedUpdate() 메소드는 Fixed Time Step 주기(기본 0.02초)마다 한 번씩 호출되도록 보정된다.

그냥 ‘호출된다’가 아니고, ‘호출되도록 보정된다’.

왜냐하면, FixedUpdate()의 호출은 Update()를 호출하는 게임 루프와 별도의 루프, 혹은 멀티스레드에 의해 발생하지 않기 때...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 - Time.deltaTime과 Time.fixedDeltaTime의 올바른 이해</title>
    <link href="https://rito15.github.io/posts/unity-deltatime-and-fixeddeltatime/" rel="alternate" type="text/html" title="유니티 - Time.deltaTime과 Time.fixedDeltaTime의 올바른 이해" />
    <published>2021-11-21T23:45:00+09:00</published>
  
    <updated>2021-11-21T23:45:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-deltatime-and-fixeddeltatime/</id>
    <content src="https://rito15.github.io/posts/unity-deltatime-and-fixeddeltatime/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Tips" />
    
  

  
    <summary>
      





      deltaTime과 fixedDeltaTime


deltaTime

Time.deltaTime을 통해 참조할 수 있다.

이전 프레임의 발생 시각과 현재 프레임의 발생 시각 사이의 시간 간격,

즉 이전 프레임의 수행에 걸린 시간을 의미한다.

Update() 내에서 시간의 진행에 따른 일정한 기능을 구현하기 위해 Time.deltaTime을 이용해 보정한다.



fixedDeltaTime

Time.fixedDeltaTime을 통해 참조할 수 있다.

기본적으로 물리 업데이트 발생 주기, 즉 Fixed Time Step 값을 의미한다.

마찬가지로 FixedUpdate() 내에서 Time.fixedDeltaTime을 이용해 보정한다.



Frame Rate


‘프레임률’이라고도 부르며, 초당 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>(Amplify) Screen Effect - Chromatic Aberration</title>
    <link href="https://rito15.github.io/posts/unity-amplify-screen-chromatic-aberration/" rel="alternate" type="text/html" title="(Amplify) Screen Effect - Chromatic Aberration" />
    <published>2021-11-20T01:01:00+09:00</published>
  
    <updated>2021-11-20T01:01:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-amplify-screen-chromatic-aberration/</id>
    <content src="https://rito15.github.io/posts/unity-amplify-screen-chromatic-aberration/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Amplify Shader" />
    
  

  
    <summary>
      





      Summary


  
    색수차 효과
  
  
    스크린 이펙트 적용 애셋 : Link
  




Preview






Properties



  Red Offset
    
      R 채널 색상의 화면 UV 진행 방향
    
  
  Green Offset
    
      G 채널 색상의 화면 UV 진행 방향
    
  
  Blue Offset
    
      B 채널 색상의 화면 UV 진행 방향
    
  
  Intensity
    
      색수차 효과 적용 강도
    
  
  Circle Range Power
    
      화면 내에서 원형 효과 범위에 대한 Power 지수 값
      작을수록 화면 전범위에, 클수록 화면 가장자리에만 색수차 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 - 쉐이더에서 파티클 시스템 커스텀 데이터(Custom Data) 사용하기</title>
    <link href="https://rito15.github.io/posts/unity-particle-system-custom-data/" rel="alternate" type="text/html" title="유니티 - 쉐이더에서 파티클 시스템 커스텀 데이터(Custom Data) 사용하기" />
    <published>2021-11-19T15:00:00+09:00</published>
  
    <updated>2021-11-19T15:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-particle-system-custom-data/</id>
    <content src="https://rito15.github.io/posts/unity-particle-system-custom-data/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Particle System" />
    
  

  
    <summary>
      





      커스텀 데이터(Custom Data)


  파티클 시스템의 Custom Data 모듈에서 지정한 값을 쉐이더로 가져와 사용할 수 있다.




1. 파티클 시스템 설정


[1] Custom Data 모듈

  
    Custom Data 모듈에 체크한다.
  
  
    Mode를 Vector 또는 Color로 설정한다.
  
  
    Vector로 설정한 경우, 사용할 채널 개수(Number of Components), 각 채널의 값을 지정한다.
  






[2] Renderer 모듈

  Custom Vertex Streams에 치크한다.







  
    우측 하단의 + 버튼을 눌러 알맞은 커스텀 데이터를 목록에 추가한다.
  
  
    Custom Data 모듈에서 지...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 - 반드시 고쳐야 하는, 잘못된 코딩 방식들</title>
    <link href="https://rito15.github.io/posts/unity-bad-coding-practices/" rel="alternate" type="text/html" title="유니티 - 반드시 고쳐야 하는, 잘못된 코딩 방식들" />
    <published>2021-11-16T22:51:00+09:00</published>
  
    <updated>2021-11-18T00:19:03+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-bad-coding-practices/</id>
    <content src="https://rito15.github.io/posts/unity-bad-coding-practices/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Tips" />
    
  

  
    <summary>
      





      Intro


별 생각 없이 흔하게 작성할 수 있지만,

제대로 알고 보면 ‘절대 이렇게 작성하면 안되겠다’라고 생각할 수 있는 유니티 C# 코딩 방식들에 대해 다룹니다.

편의상 본문에서는 평어로 서술합니다.



Note



  
    본문에서의 ‘자주’는 Update(), FixedUpdate(), 코루틴 내부의 while(true) 문 등에서 자주 호출되는 경우를 의미한다.
  
  
    예를 들어 Update()는 매 프레임마다 한 번씩 호출되므로, 자주 호출된다고 할 수 있다.
  




1. 자주 호출되는 Find(), GetComponent()


예시

private void Update()
{
    GameObject managerObject  = GameObject.Fin...
    </summary>
  

  </entry>

</feed>



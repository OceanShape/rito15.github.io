

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-02-06T03:36:01+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>유니티 투명 쉐이더와 스텐실</title>
    <link href="https://rito15.github.io/posts/unity-transparent-stencil/" rel="alternate" type="text/html" title="유니티 투명 쉐이더와 스텐실" />
    <published>2021-02-06T01:29:00+09:00</published>
  
    <updated>2021-02-06T01:29:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-transparent-stencil/</id>
    <content src="https://rito15.github.io/posts/unity-transparent-stencil/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Shader Study" />
    
  

  
    <summary>
      





      불투명과 투명


불투명(Opaque)과 투명(Transparent) 오브젝트는 그려지는 타이밍도, 그리기 위한 고려사항도 다르다.

유니티로 설명하자면 오브젝트를 렌더링하는 순서를 렌더 큐(Render Queue)를 통해 지정하는데 
지정한 숫자가 작은 순서대로 그리게 되며, 기본적으로 Opaque는 2000, Transparent는 3000의 값을 가진다.
따라서 Opaque를 전부 그린 후에 Transparent를 그린다.



Z-buffer

카메라로부터 픽셀마다 가장 가까운 오브젝트까지의 거리를 (0.0 ~ 1.0) 값으로 기록해놓는 버퍼.

깊이 버퍼(Depth Buffer)라고도 한다.





불투명(Opaque)



불투명 오브젝트를 그리기 위해서 우선 Z버퍼를 참조한다.
각각의 픽...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 쉐이더 모음</title>
    <link href="https://rito15.github.io/posts/unity-shader-compilation/" rel="alternate" type="text/html" title="유니티 쉐이더 모음" />
    <published>2021-02-06T01:25:00+09:00</published>
  
    <updated>2021-02-06T01:25:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-shader-compilation/</id>
    <content src="https://rito15.github.io/posts/unity-shader-compilation/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Shader Study" />
    
  

  
    <summary>
      





      Render Depth



  단순히 뎁스만 색상으로 보여주는 쉐이더




Shader "Render Depth"
{
    Properties
    {
        _Multiplier("Multiplier", Float) = 50
    }

    SubShader
    {
        Tags { "RenderType" = "Opaque" }
        Pass 
        {
            CGPROGRAM

            #pragma vertex vert
            #pragma fragment frag
            #include "UnityCG.cginc"

            struct v2f 
            {
     ...
    </summary>
  

  </entry>

  
  <entry>
    <title>OpenGL 공부 - 09</title>
    <link href="https://rito15.github.io/posts/opengl-study-09/" rel="alternate" type="text/html" title="OpenGL 공부 - 09" />
    <published>2021-02-05T15:20:00+09:00</published>
  
    <updated>2021-02-05T15:20:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/opengl-study-09/</id>
    <content src="https://rito15.github.io/posts/opengl-study-09/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="OpenGL" />
    
    <category term="OpenGL Study" />
    
  

  
    <summary>
      





      목표


  uniform 변수, VAO에 대한 이해 및 사용




1. uniform


uniform이란?

  OpenGL에서 쉐이더로 전달하는 글로벌 변수



쉐이더에서 uniform 변수 선언 및 사용

#shader fragment
#version 330 core

layout(location = 0) out vec4 color;

uniform vec4 u_Color;

void main()
{
	color = u_Color;
};



  uniform 변수는 기본적으로 u_를 붙여 네이밍한다.



OpenGL에서 uniform 변수 선언 및 전달


  
    glGetUniformLocation
    
      대상 프로그램(쉐이더)에 uniform 변수의 위치를 생성하고,...
    </summary>
  

  </entry>

  
  <entry>
    <title>Unity Script Optimization</title>
    <link href="https://rito15.github.io/posts/unity-script-optimization/" rel="alternate" type="text/html" title="Unity Script Optimization" />
    <published>2021-02-04T19:30:00+09:00</published>
  
    <updated>2021-02-05T04:27:44+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-script-optimization/</id>
    <content src="https://rito15.github.io/posts/unity-script-optimization/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Study" />
    
  

  
    <summary>
      





      Tips


1. GetComponent(), Find() 메소드 반복 호출하지 않기

너무나 기본적인 것이라 간단히 짚고 넘어가지만,
매 프레임, 혹은 주기적으로 Get, Find류의 메소드를 호출하는 것은 매우 좋지 않다.
항상 처음에만 Get, Find로 필드에 담아놓고 사용해야 한다.



2. 필요하지 않은 경우, new로 생성하지 않기

클래스 타입으로 생성한 객체는 항상 GC의 먹이가 된다.
따라서 가능하면 한 번만 생성하고 이후에는 재사용 하는 방식을 선택해야 한다.

데이터 클래스의 경우, 대신 구조체를 사용하는 것도 좋다.



3. 구조체 사용하기


  http://clarkkromenaker.com/post/csharp-structs/


동일한 데이터를 하나는 구조체, 하나는 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>Unity Profiling</title>
    <link href="https://rito15.github.io/posts/unity-profiling/" rel="alternate" type="text/html" title="Unity Profiling" />
    <published>2021-02-04T19:30:00+09:00</published>
  
    <updated>2021-02-05T04:27:44+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-profiling/</id>
    <content src="https://rito15.github.io/posts/unity-profiling/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Study" />
    
  

  
    <summary>
      





      Note


  프로파일링은 1차적으로 에디터에서 수행하지만, 타겟 디바이스에서 실제로 실행하며 진행하는 프로파일링이 가장 중요하다.
  [Edit - Project Settings - Quliaty - Other]에서 VSync가 설정되어 있는지 확인한다.
  Application.targetFrameRate가 설정되어 있는지 확인한다(미설정 시 -1)
  병목을 확인할 때 CPU 바운드인지 GPU 바운드인지 꼭 짚고 시작한다.
  모바일 기기라면 프로파일링 순간이 쓰로틀링 상황인지 확인해야 한다.



Tools


1. Unity Editor

Unity Profiler

  [Window - Analysis - Profiler (Ctrl+7)]
  https://docs.unity3d.com/k...
    </summary>
  

  </entry>

</feed>





<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-09-04T04:21:11+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>C# 비동기 Task를 사용하면서 흔히 발생하는 실수</title>
    <link href="https://rito15.github.io/posts/cs-async-task-mistakes/" rel="alternate" type="text/html" title="C# 비동기 Task를 사용하면서 흔히 발생하는 실수" />
    <published>2021-09-04T04:09:00+09:00</published>
  
    <updated>2021-09-04T04:09:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-async-task-mistakes/</id>
    <content src="https://rito15.github.io/posts/cs-async-task-mistakes/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Threading" />
    
  

  
    <summary>
      





      Mistake


private static void Main()
{
    Task t = Task.Run(() =&amp;gt; TaskBody(3));

    t.Wait(); // TaskBody(3)의 종료를 대기하려고 시도

    Console.WriteLine("End");
}

static async void TaskBody(int count)
{
    for (int i = 0; i &amp;lt; count; i++)
    {
        await Task.Delay(500);
        Console.WriteLine($"[{i}] Thread : {Thread.CurrentThread.ManagedThreadId}");
    }
}


위의 소스 코드는 얼핏 보면 문제가 없어 보...
    </summary>
  

  </entry>

  
  <entry>
    <title>동적 계획법(Dynamic Programming, DP)</title>
    <link href="https://rito15.github.io/posts/dynamic-programming/" rel="alternate" type="text/html" title="동적 계획법(Dynamic Programming, DP)" />
    <published>2021-09-02T16:40:00+09:00</published>
  
    <updated>2021-09-02T16:40:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/dynamic-programming/</id>
    <content src="https://rito15.github.io/posts/dynamic-programming/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Algorithm" />
    
    <category term="Algorithms" />
    
  

  
    <summary>
      





      개념


동적 계획법

문제를 여러 개의 하위 문제들로 나누어 해결 및 기록한 뒤

이를 이용해 최종적인 문제를 해결해나가는 방법.



다시 말해,

문제 해결 과정을 메모리에 기록하고 이를 바탕으로 이후의 문제를 해결해나가는 방법이다.

한 번 기록한 적이 있다면 다시 계산할 필요 없이 곧바로 답을 도출해낼 수 있다.



메모이제이션(Memoization)

동적 계획법의 핵심 개념.

하위 문제의 답을 구한 뒤 메모리에 저장하는 것을 의미한다.

이렇게 저장된 값은 동일한 하위 문제의 결과값이 필요할 때 재계산 없이 곧바로 사용될 수 있다.



예제 - 피보나치



  동적 계획법의 기초 예제로 많이 볼 수 있는 피보나치.


Fibonacci(0) = 0
Fibonacci(1) = 1
Fi...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# Foreach 구문 심층 파헤치기</title>
    <link href="https://rito15.github.io/posts/cs-grammar-foreach/" rel="alternate" type="text/html" title="C# Foreach 구문 심층 파헤치기" />
    <published>2021-09-02T16:00:00+09:00</published>
  
    <updated>2021-09-03T14:25:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-grammar-foreach/</id>
    <content src="https://rito15.github.io/posts/cs-grammar-foreach/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Grammar" />
    
  

  
    <summary>
      





      Foreach 구문



  컬렉션의 요소를 간편히 순차 탐색할 수 있는 구문


List&amp;lt;int&amp;gt; list = new List&amp;lt;int&amp;gt;();

foreach (int item in list)
{
    Console.WriteLine(item);
}




Foreach 구문이 실제로 생성하는 코드?



  위의 소스 코드는 실제로 다음과 같은 코드를 생성한다고 한다.


List&amp;lt;int&amp;gt; list = new List&amp;lt;int&amp;gt;();

List&amp;lt;int&amp;gt;.Enumerator enumerator = list.GetEnumerator();
while (enumerator.MoveNext())
{
    int item = enumerator.Curren...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 .unitypackage 확장자 연결 끊어진 경우 해결하기</title>
    <link href="https://rito15.github.io/posts/unity-fix-unitypackage-association/" rel="alternate" type="text/html" title="유니티 .unitypackage 확장자 연결 끊어진 경우 해결하기" />
    <published>2021-09-01T23:33:00+09:00</published>
  
    <updated>2021-09-01T23:33:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-fix-unitypackage-association/</id>
    <content src="https://rito15.github.io/posts/unity-fix-unitypackage-association/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      Note


컴퓨터에 설치된 유니티 에디터 버전 중 하나를 지운 경우,

.unitypackage 확장자의 연결이 끊어지는 경우가 종종 있다.

확장자의 연결 프로그램이 단순한 응용 프로그램 실행이라면 상관 없지만,

.unitypackage 확장자의 경우 그렇지 않기 때문에 연결프로그램 연결만으로는 해결할 수 없다.

이를 비교적 간단히 해결하기 위한 두 가지 방법이 있다.

아래의 두 가지 방식 중 하나를 선택해서 하면 된다.



1. 명령 프롬프트에서 해결하기


우선, 유니티 에디터가 설치된 경로를 알아야 한다.

C:\Program Files 경로에 들어가서 2021.1.16f1과 같이 유니티 에디터 버전이 쓰여 있는 폴더를 확인한다.



이제 윈도우 + R 키를 눌러 cmd라고 적고, 엔...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 에디터 - 빌드 직전에 동작하는 기능 작성하기</title>
    <link href="https://rito15.github.io/posts/unity-editor-process-before-build/" rel="alternate" type="text/html" title="유니티 에디터 - 빌드 직전에 동작하는 기능 작성하기" />
    <published>2021-09-01T17:51:00+09:00</published>
  
    <updated>2021-09-01T17:51:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-editor-process-before-build/</id>
    <content src="https://rito15.github.io/posts/unity-editor-process-before-build/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor Memo" />
    
  

  
    <summary>
      





      Memo



  아래의 형태로 스크립트를 작성해놓으면 빌드 직전에 동작한다.


#if UNITY_EDITOR

class BuildPreProcessor : UnityEditor.Build.IPreprocessBuildWithReport
{
    public int callbackOrder =&amp;gt; 0;

    public void OnPreprocessBuild(UnityEditor.Build.Reporting.BuildReport report)
    {
        // Do Something Here
    }
}

#endif




References


  https://docs.unity3d.com/ScriptReference/Build.IPreprocessBuildWithRe...
    </summary>
  

  </entry>

</feed>



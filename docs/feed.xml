

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-04-26T02:06:24+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>브레즌햄(픽셀에 직선 그리기) 알고리즘</title>
    <link href="https://rito15.github.io/posts/bresenham-algorithm/" rel="alternate" type="text/html" title="브레즌햄(픽셀에 직선 그리기) 알고리즘" />
    <published>2021-04-25T17:32:00+09:00</published>
  
    <updated>2021-04-25T17:32:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/bresenham-algorithm/</id>
    <content src="https://rito15.github.io/posts/bresenham-algorithm/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Algorithm" />
    
  

  
    <summary>
      





      Summary


직선을 그릴 때 직선 위의 점들은 실수 값을 가질 수밖에 없다.

그래서 불연속 정수 값만을 갖는 픽셀에 직선을 그릴 때는

실수 값의 소수점을 버리거나 반올림하여 정수로 변환해야 하는데,

브레즌햄 알고리즘은 실수 연산 없이 정수 연산만으로 직선을 그릴 수 있게 해준다.



Details


2가지 경우로 나눈다.




  기울기 절댓값이 1 미만인 경우
  기울기 절댓값이 1 이상인 경우




1번의 경우에는 x 좌표를 1씩 증가 또는 감소시키며 해당하는 y 좌표를 구하고,

2번의 경우에는 y 좌표를 1씩 증가 또는 감소시키며 해당하는 x 좌표를 구한다.



1번을 예시로 했을 때

x 좌표를 1씩 증가 또는 감소시켰을 때 y좌표 역시 1 증가 또는 감소시킬지 여부를 결정...
    </summary>
  

  </entry>

  
  <entry>
    <title>Debug.Log에 색상 넣기</title>
    <link href="https://rito15.github.io/posts/unity-memo-color-debug-log/" rel="alternate" type="text/html" title="Debug.Log에 색상 넣기" />
    <published>2021-04-25T17:10:00+09:00</published>
  
    <updated>2021-04-25T17:10:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-memo-color-debug-log/</id>
    <content src="https://rito15.github.io/posts/unity-memo-color-debug-log/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      Memo


  &amp;lt;color=&amp;gt;&amp;lt;/color&amp;gt; 태그를 사용하여 로그 메시지에 색상을 넣을 수 있다.
  color= 뒤에는 색상 이름 또는 HTML 색상코드를 입력한다.




Debug.Log("Default");
Debug.Log("&amp;lt;color=white&amp;gt;White&amp;lt;/color&amp;gt;");
Debug.Log("&amp;lt;color=grey&amp;gt;Grey&amp;lt;/color&amp;gt;");
Debug.Log("&amp;lt;color=black&amp;gt;Black&amp;lt;/color&amp;gt;");
Debug.Log("&amp;lt;color=red&amp;gt;Red&amp;lt;/color&amp;gt;");
Debug.Log("&amp;lt;color=green&amp;gt;Green&amp;lt;/color&amp;gt;");
Debug...
    </summary>
  

  </entry>

  
  <entry>
    <title>Drag and Drop Recorder</title>
    <link href="https://rito15.github.io/posts/unity-toy-drag-and-drop-recorder/" rel="alternate" type="text/html" title="Drag and Drop Recorder" />
    <published>2021-04-19T21:00:00+09:00</published>
  
    <updated>2021-04-19T21:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-toy-drag-and-drop-recorder/</id>
    <content src="https://rito15.github.io/posts/unity-toy-drag-and-drop-recorder/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Toys" />
    
  

  
    <summary>
      





      Summary


  드래그 앤 드롭으로 게임오브젝트를 커서를 따라 이동시킨다.
  이동 경로를 기록하고, 반복재생할 수 있다.


How To Use


  빈 게임오브젝트에 DDRecorder 컴포넌트를 추가한다.
  드래그 앤 드롭으로 이동시킬 게임오브젝트에 콜라이더와 DDTarget 컴포넌트를 추가한다.
  DDRecorder 컴포넌트의 Replay Target 필드에 반복 재생시킬 게임오브젝트를 등록한다.
  스페이스바를 누를 때마다 등록된 경로대로 타겟 게임오브젝트가 이동한다.


Preview




Download


  Drag and Drop Recorder.zip


Source Code


  https://github.com/rito15/Unity_Toys



    </summary>
  

  </entry>

  
  <entry>
    <title>RPG Inventory System(RPG 게임용 인벤토리 제작하기)</title>
    <link href="https://rito15.github.io/posts/unity-study-rpg-inventory/" rel="alternate" type="text/html" title="RPG Inventory System(RPG 게임용 인벤토리 제작하기)" />
    <published>2021-04-15T22:00:00+09:00</published>
  
    <updated>2021-04-15T22:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-study-rpg-inventory/</id>
    <content src="https://rito15.github.io/posts/unity-study-rpg-inventory/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Study" />
    
  

  
    <summary>
      





      개요



  RPG 게임에서 사용할 수 있는 기본적인 인벤토리를 제작한다.




클래스 구조 설계




1. 인벤토리

  Inventory : 전체 아이템들을 관리하고, 인벤토리 내부의 실질적 동작들을 담당한다.


2. 아이템

  Item : 인벤토리의 각 슬롯에 들어가는 실제 아이템. 각각의 아이템이 개별적으로 갖는 데이터들을 보관한다.
    
      CountableItem : 수량을 셀 수 있는 아이템
        
          PortionItem : 소모 아이템(포션)
        
      
      EquipmentItem : 장비 아이템
        
          WeaponItem : 무기 아이템
          ArmorItem : 방어구 아이템
...
    </summary>
  

  </entry>

  
  <entry>
    <title>Quick Sort(빠른 정렬)</title>
    <link href="https://rito15.github.io/posts/algorithm-quick-sort/" rel="alternate" type="text/html" title="Quick Sort(빠른 정렬)" />
    <published>2021-04-07T22:00:00+09:00</published>
  
    <updated>2021-04-07T22:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/algorithm-quick-sort/</id>
    <content src="https://rito15.github.io/posts/algorithm-quick-sort/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Algorithm" />
    
    <category term="Sort Algorithm" />
    
  

  
    <summary>
      





      Summary



  
    
      시간복잡도
      평균 \(O(n log n)\), 최악 \(O(n^2)\)
    
    
      공간복잡도
      \(O(n)\)
    
    
      정렬 특징
      불안정 정렬
    
  


특징

  분할 정복
  재귀




Details


메소드 구성

QuickSort(arr, left, right)

  배열의 left ~ right 인덱스 내에서만 정렬을 수행한다.


Partition(arr, left, right)

  배열의 left ~ right 인덱스 내에서 피벗을 선정한다.
  내부적으로 정렬을 수행하고, 피벗의 인덱스를 리턴한다.




정렬 과정

[1] QuickSort(arr, 0, arr.L...
    </summary>
  

  </entry>

</feed>



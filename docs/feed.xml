

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-11-20T01:14:26+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>(Amplify) Screen Effect - Chromatic Aberration</title>
    <link href="https://rito15.github.io/posts/unity-amplify-screen-chromatic-aberration/" rel="alternate" type="text/html" title="(Amplify) Screen Effect - Chromatic Aberration" />
    <published>2021-11-20T01:01:00+09:00</published>
  
    <updated>2021-11-20T01:01:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-amplify-screen-chromatic-aberration/</id>
    <content src="https://rito15.github.io/posts/unity-amplify-screen-chromatic-aberration/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Amplify Shader" />
    
  

  
    <summary>
      





      Summary


  
    색수차 효과
  
  
    스크린 이펙트 적용 애셋 : Link
  




Preview






Properties



  Red Offset
    
      R 채널 색상의 화면 UV 진행 방향
    
  
  Green Offset
    
      G 채널 색상의 화면 UV 진행 방향
    
  
  Blue Offset
    
      B 채널 색상의 화면 UV 진행 방향
    
  
  Intensity
    
      색수차 효과 적용 강도
    
  
  Circle Range Power
    
      화면 내에서 원형 효과 범위에 대한 Power 지수 값
      작을수록 화면 전범위에, 클수록 화면 가장자리에만 색수차 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 - 쉐이더에서 파티클 시스템 커스텀 데이터(Custom Data) 사용하기</title>
    <link href="https://rito15.github.io/posts/unity-particle-system-custom-data/" rel="alternate" type="text/html" title="유니티 - 쉐이더에서 파티클 시스템 커스텀 데이터(Custom Data) 사용하기" />
    <published>2021-11-19T15:00:00+09:00</published>
  
    <updated>2021-11-19T15:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-particle-system-custom-data/</id>
    <content src="https://rito15.github.io/posts/unity-particle-system-custom-data/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Particle System" />
    
  

  
    <summary>
      





      커스텀 데이터(Custom Data)


  파티클 시스템의 Custom Data 모듈에서 지정한 값을 쉐이더로 가져와 사용할 수 있다.




1. 파티클 시스템 설정


[1] Custom Data 모듈

  
    Custom Data 모듈에 체크한다.
  
  
    Mode를 Vector 또는 Color로 설정한다.
  
  
    Vector로 설정한 경우, 사용할 채널 개수(Number of Components), 각 채널의 값을 지정한다.
  






[2] Renderer 모듈

  Custom Vertex Streams에 치크한다.







  
    우측 하단의 + 버튼을 눌러 알맞은 커스텀 데이터를 목록에 추가한다.
  
  
    Custom Data 모듈에서 지...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 - 반드시 고쳐야 하는, 잘못된 코딩 방식들</title>
    <link href="https://rito15.github.io/posts/unity-bad-coding-practices/" rel="alternate" type="text/html" title="유니티 - 반드시 고쳐야 하는, 잘못된 코딩 방식들" />
    <published>2021-11-16T22:51:00+09:00</published>
  
    <updated>2021-11-18T00:19:03+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-bad-coding-practices/</id>
    <content src="https://rito15.github.io/posts/unity-bad-coding-practices/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Tips" />
    
  

  
    <summary>
      





      Intro


별 생각 없이 흔하게 작성할 수 있지만,

제대로 알고 보면 ‘절대 이렇게 작성하면 안되겠다’라고 생각할 수 있는 유니티 C# 코딩 방식들에 대해 다룹니다.

편의상 본문에서는 평어로 서술합니다.



Note



  
    본문에서의 ‘자주’는 Update(), FixedUpdate(), 코루틴 내부의 while(true) 문 등에서 자주 호출되는 경우를 의미한다.
  
  
    예를 들어 Update()는 매 프레임마다 한 번씩 호출되므로, 자주 호출된다고 할 수 있다.
  




1. 자주 호출되는 Find(), GetComponent()


예시

private void Update()
{
    GameObject managerObject  = GameObject.Fin...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 - Transform의 공간 변환 메소드 간단 메모</title>
    <link href="https://rito15.github.io/posts/unity-transform-transformation-methods/" rel="alternate" type="text/html" title="유니티 - Transform의 공간 변환 메소드 간단 메모" />
    <published>2021-11-13T00:02:00+09:00</published>
  
    <updated>2021-11-16T00:25:12+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-transform-transformation-methods/</id>
    <content src="https://rito15.github.io/posts/unity-transform-transformation-methods/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo - Shorts" />
    
  

  
    <summary>
      





      1. 로컬-월드 변환


[1] TransformPoint()


  
    위치, 회전, 크기 변환을 적용한다.
  
  
    방향 벡터가 아니라, 위치 벡터를 월드 위치로 변환할 때 사용한다.
  
  
    메시의 로컬 정점 좌표로부터 월드 정점 좌표를 구할 때처럼, 
오브젝트에 완전히 종속적인 위치 벡터를 변환할 때 사용된다.
  
  
    C# 스크립트에서는 딱히 자주 쓰이지 않는다.
  




[2] TransformVector()


  
    회전, 크기 변환을 적용한다.
  
  
    메시의 노멀 벡터처럼 오브젝트에 종속적인 방향 벡터를 월드로 변환할 때 사용된다.
  
  
    이것도 C# 스크립트에서 딱히 쓸 일은 없어 보인다.
  
  
    혹시나 방향 벡...
    </summary>
  

  </entry>

  
  <entry>
    <title>게임 수학 - 세 점이 주어질 때 수선의 발 구하기</title>
    <link href="https://rito15.github.io/posts/foot-of-perpendicular-in-three-vectors/" rel="alternate" type="text/html" title="게임 수학 - 세 점이 주어질 때 수선의 발 구하기" />
    <published>2021-11-12T18:12:00+09:00</published>
  
    <updated>2021-11-12T18:12:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/foot-of-perpendicular-in-three-vectors/</id>
    <content src="https://rito15.github.io/posts/foot-of-perpendicular-in-three-vectors/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Memo" />
    
    <category term="Game Mathematics" />
    
  

  
    <summary>
      





      수선의 발 구하기




공간 상의 세 점 A, B, C가 주어져 있다.

D는 C에서 직선 AB에 내린 수선의 발이다.

D는 간단히 다음과 같이 구할 수 있다.

\[D = A + AB * \frac{AB \cdot AC}{AB \cdot AB}\]



설명

AD 벡터를 구하고, A에서 AD를 더해 D를 계산하는 방식이다.

벡터 AB와 AC를 내적하면 AB의 크기와 AC를 AB에 사영한 벡터 AD의 크기를 곱한 값, 즉 |AB| * |AD|를 얻을 수 있고,

벡터 AB를 자기 자신에 대해 내적하면 |AB| * |AB|를 얻을 수 있다.

전자를 후자로 나누면 |AD| / |AB|를 얻을 수 있고,

여기에 벡터 AB를 곱하면 AB의 방향을 유지한채 크기는 |AD|인 벡터, 즉 AD를 얻을 수...
    </summary>
  

  </entry>

</feed>





<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-02-01T20:24:09+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>C++ 스택 메모리 동적 할당</title>
    <link href="https://rito15.github.io/posts/cpp-stack-memory-allocation/" rel="alternate" type="text/html" title="C++ 스택 메모리 동적 할당" />
    <published>2021-02-01T18:45:00+09:00</published>
  
    <updated>2021-02-01T18:45:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cpp-stack-memory-allocation/</id>
    <content src="https://rito15.github.io/posts/cpp-stack-memory-allocation/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C++" />
    
    <category term="C++ Memo" />
    
  

  
    <summary>
      





      Memo


  
    _alloca
    
      스택에 메모리를 동적으로 할당해준다.
      함수의 리턴으로 전달하면 안된다.
      블록이 종료되면 자동으로 할당 해제된다.
      공간 할당 불가능한 경우 Stack Overflow 에러가 발생할 수 있으니 주의
      예외가 발생한 경우 구조적 예외처리(SEH)로 받아야 함
    
  



  
    
      size_t size
      할당할 배열 크기(길이 * sizeof(타입))
    
    
      return void*
      할당된 배열의 주소(타입 캐스팅 필요)
    
  


int length = 10;

// 원했던 것 : char message[length]
// 하지만 배열의 크...
    </summary>
  

  </entry>

  
  <entry>
    <title>OpenGL 공부 - 05</title>
    <link href="https://rito15.github.io/posts/opengl-study-05/" rel="alternate" type="text/html" title="OpenGL 공부 - 05" />
    <published>2021-02-01T17:42:00+09:00</published>
  
    <updated>2021-02-01T17:42:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/opengl-study-05/</id>
    <content src="https://rito15.github.io/posts/opengl-study-05/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="OpenGL" />
    
    <category term="OpenGL Study" />
    
  

  
    <summary>
      





      목표


  OpenGL의 쉐이더에 대한 이해
  간단한 vertex, fragment 쉐이더 작성, 컴파일 및 실행




OpenGL의 쉐이더



  
    Vertex&amp;amp;Fragment Shader
    
      OpenGL에서 거의 90%의 비중을 차지
    
  
  
    Vertex Shader
    
      하나의 정점 당 한 번씩 실행된다.
      layout을 통해 정점 속성의 위치를 입력받는다.
      입력 : 정점 데이터
      출력 : 클립 스페이스의 정점 데이터
    
  
  
    Fragment Shader
    
      하나의 픽셀 당 한 번씩 실행된다.
      입력 : 프래그먼트 데이터(래스터라이저가 만들어줌)
      ...
    </summary>
  

  </entry>

  
  <entry>
    <title>Unity UI Memo</title>
    <link href="https://rito15.github.io/posts/unity-ui-memo/" rel="alternate" type="text/html" title="Unity UI Memo" />
    <published>2021-02-01T03:00:00+09:00</published>
  
    <updated>2021-02-01T03:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-ui-memo/</id>
    <content src="https://rito15.github.io/posts/unity-ui-memo/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      UI 드래그 앤 드롭으로 옮기기


  UI 헤더(윗부분)를 따로 구성했을 때, 헤더를 드래그 했을 때만 옮기기
  헤더 UI의 컴포넌트로 넣어주기


/// &amp;lt;summary&amp;gt; 헤더 드래그 앤 드롭에 의한 UI 이동 구현 &amp;lt;/summary&amp;gt;
public class PopupUIHeader : MonoBehaviour,
    IPointerDownHandler, IBeginDragHandler, IDragHandler
{
    private RectTransform _parentRect;

    private Vector2 _rectBegin;
    private Vector2 _moveBegin;
    private Vector2 _moveOffset;

    priva...
    </summary>
  

  </entry>

  
  <entry>
    <title>Popup UI Management System</title>
    <link href="https://rito15.github.io/posts/popup-ui-management-system/" rel="alternate" type="text/html" title="Popup UI Management System" />
    <published>2021-01-31T20:23:00+09:00</published>
  
    <updated>2021-01-31T20:23:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/popup-ui-management-system/</id>
    <content src="https://rito15.github.io/posts/popup-ui-management-system/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Study" />
    
  

  
    <summary>
      





      목표


  팝업 UI 관리 시스템 구현




게임의 UI


  온라인 PC게임을 예로 들었을 때, 다양한 형태의 UI들이 존재한다.
  화면 예시 : Smilegate RPG ‘LostARK’


1. 전체화면 UI

  크기가 화면 전체에 해당하는 UI
  예 : 상점, 캐시 샵




2. 고정형 UI

  고정된 위치에 항상 존재하는 UI
  예 : 하단 바, 퀵슬롯, 미니맵, 채팅창




3. 추적형 UI

  게임 내 요소들(캐릭터, 몬스터, 건물 등)의 위치를 실시간으로 추적하여 따라다니는 UI
  예 : 체력 바, 이름, 말풍선




4. 안내형 UI

  화면 한켠에 잠시 나타났다가 사라지는 형태의 UI
  게임의 진행사항, 공지사항 등을 안내하는 용도로 주로 사용된다.




...
    </summary>
  

  </entry>

  
  <entry>
    <title>OpenGL 공부 - 04</title>
    <link href="https://rito15.github.io/posts/opengl-study-04/" rel="alternate" type="text/html" title="OpenGL 공부 - 04" />
    <published>2021-01-31T13:31:00+09:00</published>
  
    <updated>2021-02-01T03:12:15+09:00</updated>
  
    <id>https://rito15.github.io/posts/opengl-study-04/</id>
    <content src="https://rito15.github.io/posts/opengl-study-04/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="OpenGL" />
    
    <category term="OpenGL Study" />
    
  

  
    <summary>
      





      목표


  Vertex Attributes, Layout, VBO, VAO에 대한 이해




Attributes, VAO, VBO


  버텍스 버퍼에는 버텍스 좌표, 텍스쳐 좌표, 노멀 벡터 등 여러 데이터가 float 값으로 들어갈 수 있다.
  하지만 그 자체로는 그저 메모리에 올라가는 값일 뿐이기 때문에 각각의 데이터가 어떤 역할을 하고, 길이는 얼마나 갖고 있고, 시작 위치는 어디인지 OpenGL에 알려줘야 한다.




  
    VAO(Vertex Array Object)
    
      하나 이상의 VBO를 담을 수 있는 객체
      개별 오브젝트의 모든 데이터를 담고 있다.
      고유 ID를 가진다.
    
  


// 1. VAO ID 준비
GLuint vao;
...
    </summary>
  

  </entry>

</feed>



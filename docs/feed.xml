

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-07-17T20:07:47+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Animator Event Controller(애니메이터 이벤트 관리 컴포넌트)</title>
    <link href="https://rito15.github.io/posts/unity-animator-event-controller/" rel="alternate" type="text/html" title="Animator Event Controller(애니메이터 이벤트 관리 컴포넌트)" />
    <published>2021-07-17T15:15:00+09:00</published>
  
    <updated>2021-07-17T15:15:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-animator-event-controller/</id>
    <content src="https://rito15.github.io/posts/unity-animator-event-controller/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor Utilities" />
    
  

  
    <summary>
      





      Summary


  
    애니메이터에서 재생하는 각 애니메이션 클립에 대한 이벤트를 생성, 관리하는 컴포넌트
  
  
    등록한 프리팹을 애니메이션의 특정 프레임에 복제하여 생성하는 이벤트를 만들 수 있습니다.
  
  
    플레이모드의 변경 사항은 플레이모드가 종료되어도 유지됩니다.
  
  
    테스트 버전 : 2018.3.14f1, 2019.4.9f1, 2020.3.14f1
  




Preview










0. Download &amp;amp; Import


  
    Animator Event Controller.unitypackage
  
  
    첨부 파일을 다운로드하고, 유니티 프로젝트가 켜져 있는 상태에서 실행합니다.
  
  
    임포트 창이 나타나면 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>파티클 시스템 예제 - 12 - Sword Aura</title>
    <link href="https://rito15.github.io/posts/unity-particle-system-example-12-sword-aura/" rel="alternate" type="text/html" title="파티클 시스템 예제 - 12 - Sword Aura" />
    <published>2021-07-11T14:55:00+09:00</published>
  
    <updated>2021-07-11T14:55:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-particle-system-example-12-sword-aura/</id>
    <content src="https://rito15.github.io/posts/unity-particle-system-example-12-sword-aura/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Particle System" />
    
  

  
    <summary>
      





      목차



  목표
  준비물
  1. 작업 환경 구성
  2. 하이라키 구성
  3. Aura 이펙트
  4. Smoke 이펙트
  5. Spark 이펙트
  6. Glow 이펙트




Preview










목표



  검 모델링에 부착하여 사용할 수 있는, 타오르는 듯한 이펙트 만들기




준비물


검 모델링

  https://assetstore.unity.com/packages/3d/props/weapons/free-low-poly-swords-189978


Additive 마테리얼들과 텍스쳐

  SwordAura, SwordSmoke, PointGlow
  SwordAura_Resources.zip




1. 작업 환경 구성


이펙트를 제작하기 위해 게임 뷰에는 스카이...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# TLS(Thread Local Storage)</title>
    <link href="https://rito15.github.io/posts/08-cs-thread-local-storage/" rel="alternate" type="text/html" title="C# TLS(Thread Local Storage)" />
    <published>2021-07-08T01:08:00+09:00</published>
  
    <updated>2021-07-08T01:08:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/08-cs-thread-local-storage/</id>
    <content src="https://rito15.github.io/posts/08-cs-thread-local-storage/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Threading" />
    
  

  
    <summary>
      





      

메모리 구조






TLS(Thread Local Storage)


Data 영역의 전역 변수, Heap 영역의 객체는 모든 스레드가 공유한다.

그리고 Stack 영역의 지역 변수(또는 멤버 변수)는 해당 블록 내에서만 사용된다.

따라서 기본적으로 각각의 스레드마다 고유하게 갖는 메모리 영역은 없다.

이를 만들어 줄 수 있는 것이 바로 TLS이다.



TLS는 각각의 스레드마다 자기만의 변수를 저장할 수 있게 해준다.

따라서 이를 활용하여, 공유 변수로 인해 빈번한 스레드 동기화가 일어날 수 있는 경우

임시로 TLS에 저장하고 나중에 공유 변수에 동기화하는 방식으로

스레드 동기화에 의한 성능 저하를 줄여줄 수 있다.



ThreadLocal&amp;lt;T&amp;gt;



  C#의 Thr...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# Thread Synchronization and Locks</title>
    <link href="https://rito15.github.io/posts/07-cs-thread-synchronization/" rel="alternate" type="text/html" title="C# Thread Synchronization and Locks" />
    <published>2021-07-08T01:07:00+09:00</published>
  
    <updated>2021-07-08T01:07:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/07-cs-thread-synchronization/</id>
    <content src="https://rito15.github.io/posts/07-cs-thread-synchronization/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Threading" />
    
  

  
    <summary>
      





      동기화 영역에 따른 구분


1. 유저 모드 동기화


  
    유저 객체(커널에서 제공하지 않는 객체)를 사용한다.
  
  
    대표적으로 크리티컬 섹션(Critical Section), 인터락(Interlocked)이 있다.
  
  
    커널 모드 동기화보다 빠르다.
  
  
    동일 프로세스 내에서만 동기화 가능하다.
  




2. 커널 모드 동기화


  
    커널 객체를 사용한다.
  
  
    대표적으로 뮤텍스(Mutex), 세마포어(Semaphore), 이벤트(Event)가 있다.
  
  
    다른 프로세스에 존재하는 스레드 간 동기화가 가능하다.
  
  
    유저 모드에서 커널 모드로 변경해야 하므로, 유저 모드 동기화에 비해 성능 소모가 크다.
...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# ReaderWriterLock</title>
    <link href="https://rito15.github.io/posts/06-cs-reader-writer-lock/" rel="alternate" type="text/html" title="C# ReaderWriterLock" />
    <published>2021-07-08T01:06:00+09:00</published>
  
    <updated>2021-07-08T01:06:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/06-cs-reader-writer-lock/</id>
    <content src="https://rito15.github.io/posts/06-cs-reader-writer-lock/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Threading" />
    
  

  
    <summary>
      





      Reader Writer Lock


스레드 간에 공유되는 데이터가 있을 때,

항상 모든 스레드가 그 데이터를 읽고 쓰는 것은 아니다.

어떤 스레드는 해당 데이터를 읽기만 하고,

어떤 스레드는 해당 데이터를 쓰기만 하는 구조로 이루어져 있을 수 있다.

그리고 소수의 쓰기 스레드가 상대적으로 적은 횟수로 쓰기를 수행하고,

다수의 읽기 스레드가 상대적으로 빈번하게 읽기를 수행하는 경우가 많다.



이런 경우에도 일반적인 락을 구현하여 읽기/쓰기를 수행하는 동안에 항상 락을 설정하고 해제한다면

데이터를 단순히 읽기만 하여 값이 변경되지 않는 상황에도 불필요하게 임계 영역을 만들게 되므로

성능상 굉장히 손해라고 할 수 있다.



ReaderWriterLock은 데이터에 쓰기 위해 접근할 때는 ...
    </summary>
  

  </entry>

</feed>



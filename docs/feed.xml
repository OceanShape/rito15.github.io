

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-04-22T20:06:42+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Drag and Drop Recorder</title>
    <link href="https://rito15.github.io/posts/unity-toy-drag-and-drop-recorder/" rel="alternate" type="text/html" title="Drag and Drop Recorder" />
    <published>2021-04-19T21:00:00+09:00</published>
  
    <updated>2021-04-19T21:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-toy-drag-and-drop-recorder/</id>
    <content src="https://rito15.github.io/posts/unity-toy-drag-and-drop-recorder/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Toys" />
    
  

  
    <summary>
      





      Summary


  드래그 앤 드롭으로 게임오브젝트를 커서를 따라 이동시킨다.
  이동 경로를 기록하고, 반복재생할 수 있다.


How To Use


  빈 게임오브젝트에 DDRecorder 컴포넌트를 추가한다.
  드래그 앤 드롭으로 이동시킬 게임오브젝트에 콜라이더와 DDTarget 컴포넌트를 추가한다.
  DDRecorder 컴포넌트의 Replay Target 필드에 반복 재생시킬 게임오브젝트를 등록한다.
  스페이스바를 누를 때마다 등록된 경로대로 타겟 게임오브젝트가 이동한다.


Preview




Download


  Drag and Drop Recorder.zip


Source Code


  https://github.com/rito15/Unity_Toys



    </summary>
  

  </entry>

  
  <entry>
    <title>RPG Inventory System(RPG 게임용 인벤토리 제작하기)</title>
    <link href="https://rito15.github.io/posts/unity-study-rpg-inventory/" rel="alternate" type="text/html" title="RPG Inventory System(RPG 게임용 인벤토리 제작하기)" />
    <published>2021-04-15T22:00:00+09:00</published>
  
    <updated>2021-04-15T22:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-study-rpg-inventory/</id>
    <content src="https://rito15.github.io/posts/unity-study-rpg-inventory/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Study" />
    
  

  
    <summary>
      





      개요



  RPG 게임에서 사용할 수 있는 기본적인 인벤토리를 제작한다.




클래스 구조 설계




1. 인벤토리

  Inventory : 전체 아이템들을 관리하고, 인벤토리 내부의 실질적 동작들을 담당한다.


2. 아이템

  Item : 인벤토리의 각 슬롯에 들어가는 실제 아이템. 각각의 아이템이 개별적으로 갖는 데이터들을 보관한다.
    
      CountableItem : 수량을 셀 수 있는 아이템
        
          PortionItem : 소모 아이템(포션)
        
      
      EquipmentItem : 장비 아이템
        
          WeaponItem : 무기 아이템
          ArmorItem : 방어구 아이템
...
    </summary>
  

  </entry>

  
  <entry>
    <title>Quick Sort(빠른 정렬)</title>
    <link href="https://rito15.github.io/posts/algorithm-quick-sort/" rel="alternate" type="text/html" title="Quick Sort(빠른 정렬)" />
    <published>2021-04-07T22:00:00+09:00</published>
  
    <updated>2021-04-07T22:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/algorithm-quick-sort/</id>
    <content src="https://rito15.github.io/posts/algorithm-quick-sort/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Algorithm" />
    
    <category term="Sort Algorithm" />
    
  

  
    <summary>
      





      Summary



  
    
      시간복잡도
      평균 \(O(n log n)\), 최악 \(O(n^2)\)
    
    
      공간복잡도
      \(O(n)\)
    
    
      정렬 특징
      불안정 정렬
    
  


특징

  분할 정복
  재귀




Details


메소드 구성

QuickSort(arr, left, right)

  배열의 left ~ right 인덱스 내에서만 정렬을 수행한다.


Partition(arr, left, right)

  배열의 left ~ right 인덱스 내에서 피벗을 선정한다.
  내부적으로 정렬을 수행하고, 피벗의 인덱스를 리턴한다.




정렬 과정

[1] QuickSort(arr, 0, arr.L...
    </summary>
  

  </entry>

  
  <entry>
    <title>O(logn) 거듭제곱 알고리즘</title>
    <link href="https://rito15.github.io/posts/algorithm-pow/" rel="alternate" type="text/html" title="O(logn) 거듭제곱 알고리즘" />
    <published>2021-04-06T18:00:00+09:00</published>
  
    <updated>2021-04-06T18:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/algorithm-pow/</id>
    <content src="https://rito15.github.io/posts/algorithm-pow/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Algorithm" />
    
  

  
    <summary>
      





      Summary



  
    일반적으로 \(O(n)\) 시간복잡도로 수행하는 거듭제곱 계산을 \(O(log_{2}n)\) 의 시간복잡도로 수행할 수 있는 알고리즘
  
  
    2진수 연산을 이용한다.
  




Details


\(a^n\)을 계산하는 가장 쉬운 방법은 \(a\)를 \(n\) 번 곱하는 것이다.

예를 들어 \(4^9\)을 구하려면 \(4 \cdot 4 \cdot 4 \cdot 4 \cdot 4 \cdot 4 \cdot 4 \cdot 4 \cdot 4\)를 계산하면 된다.

하지만 이렇게 되면 \(n - 1\) 번의 곱셈을 수행하므로 시간복잡도는 \(O(n)\)에 해당한다.



거듭제곱의 특징은 같은 숫자(밑)을 연달아 곱한다는 것이다.

이때 지수를 살펴보면 곱셈이 아닌...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티의 멀티스레딩과 Job의 활용</title>
    <link href="https://rito15.github.io/posts/unity-study-multithread-job/" rel="alternate" type="text/html" title="유니티의 멀티스레딩과 Job의 활용" />
    <published>2021-04-04T22:00:00+09:00</published>
  
    <updated>2021-04-04T22:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-study-multithread-job/</id>
    <content src="https://rito15.github.io/posts/unity-study-multithread-job/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Study" />
    
  

  
    <summary>
      





      유니티에서의 멀티스레딩

유니티엔진에서는 기본적으로 모든 CPU 연산이 메인 스레드에서 이루어진다.

그렇다고 다중 스레드를 사용할 수 없다는 것은 아니지만

메인 스레드가 아닌 다른 스레드에서 유니티의 메인 로직에 접근할 수 없도록 막혀있다.

다시 말해, 다른 스레드에서는 게임오브젝트, 컴포넌트 등에 접근하면 에러가 발생한다.

예를 들어

private async void TaskTest()
{
    await Task.Run(() =&amp;gt;
    {
        transform.Translate(1f, 0f, 0f);
    });
}


이런 메소드를 실행하면



이런 에러를 만날 수 있다.



따라서 다른 스레드에서 유니티 메인 로직에 접근해야 한다면 MainThreadDispat...
    </summary>
  

  </entry>

</feed>





<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-10-06T17:53:14+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>유니티 - 컴퓨트 버퍼를 통한 GPU 인스턴싱</title>
    <link href="https://rito15.github.io/posts/unity-compute-buffer-gpu-instancing/" rel="alternate" type="text/html" title="유니티 - 컴퓨트 버퍼를 통한 GPU 인스턴싱" />
    <published>2021-10-06T15:15:00+09:00</published>
  
    <updated>2021-10-06T15:15:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-compute-buffer-gpu-instancing/</id>
    <content src="https://rito15.github.io/posts/unity-compute-buffer-gpu-instancing/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Shader Study" />
    
  

  
    <summary>
      





      GPU Instancing


[1] 컴퓨트 버퍼 - 메시 데이터

  그려낼 메시의 정보를 컴퓨트 버퍼에 저장한다.
  컴퓨트 버퍼의 stride는 4 byte(sizeof(uint))이다.
  컴퓨트 버퍼의 크기는 20 byte(uint 5개)이며, 각각의 데이터는 메시에 대한 정보를 담고 있다.


Mesh mesh;                     // 그려낼 메시
int subMeshIndex = 0;          // 기본 : 0
int instanceCount = 100_000;   // 생성할 인스턴스의 개수
uint[] argsData = new uint[5]; // 메시 데이터

argsData[0] = (uint)mesh.GetIndexCount(subMeshIndex);
a...
    </summary>
  

  </entry>

  
  <entry>
    <title>레이캐스트 - 평면(Plane)</title>
    <link href="https://rito15.github.io/posts/raycast-to-plane/" rel="alternate" type="text/html" title="레이캐스트 - 평면(Plane)" />
    <published>2021-10-03T22:22:00+09:00</published>
  
    <updated>2021-10-04T04:13:50+09:00</updated>
  
    <id>https://rito15.github.io/posts/raycast-to-plane/</id>
    <content src="https://rito15.github.io/posts/raycast-to-plane/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Algorithm" />
    
    <category term="Algorithms" />
    
  

  
    <summary>
      





      레이캐스트(Raycast)



  공간 상의 한 점에서부터 목표 지점까지 가상의 광선을 발사하여, 광선에 닿는 물체의 표면을 검출한다.




평면(Plane)




평면 위의 점 P와 평면의 법선 벡터 N을 알고 있으면 평면을 정의할 수 있으며,

평면 위의 임의의 점 X를 가정하여 dot(N, P - X) = 0을 통해 평면의 방정식을 정의할 수 있다.



직선과 평면의 접점 찾기


점 A에서 점 B를 향해 광선을 발사하여, 광선(직선)과 평면이 만나는 지점을 찾는다.



위와 같이 A, B, P, N이 주어졌을 때,

길이 d를 알아내고 이를 통해 직선과 평면의 접점 C를 알아내야 한다.



평면의 정의에 의해 다음과 같은 식을 얻을 수 있다.

\[dot(N, P - C) = 0\]
...
    </summary>
  

  </entry>

  
  <entry>
    <title>레이캐스트 - 구체(Sphere)</title>
    <link href="https://rito15.github.io/posts/raycast-to-sphere/" rel="alternate" type="text/html" title="레이캐스트 - 구체(Sphere)" />
    <published>2021-10-02T02:02:00+09:00</published>
  
    <updated>2021-10-04T04:13:50+09:00</updated>
  
    <id>https://rito15.github.io/posts/raycast-to-sphere/</id>
    <content src="https://rito15.github.io/posts/raycast-to-sphere/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Algorithm" />
    
    <category term="Algorithms" />
    
  

  
    <summary>
      





      레이캐스트(Raycast)



  공간 상의 한 점에서부터 목표 지점까지 가상의 광선을 발사하여, 광선에 닿는 물체의 표면을 검출한다.




직선과 구체 표면의 접점 찾기



  시작 지점에서부터 목표 지점으로 광선을 발사하여, 그 사이에서 광선과 교차하는 구체의 표면 지점을 찾아낸다.
  3차원에서 수행하면 구체, 2차원에서 수행하면 원(Circle)의 표면을 검출할 수 있다.




먼저, 주어진 조건은 다음과 같다.


  
    A : 레이캐스트 시작 위치
    B : 레이캐스트 종료 위치
    S : 구체 중심 위치
    r : 구체 반지름 길이
  






다음과 같은 공간상의 지점 C, D를 가정할 수 있다.


  
    C : 점 S에서 직선 AB에 내린 수선의 발
 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# 바이트 버퍼를 읽어서 구조체로 변환하기</title>
    <link href="https://rito15.github.io/posts/cs-byte-buffer-to-struct/" rel="alternate" type="text/html" title="C# 바이트 버퍼를 읽어서 구조체로 변환하기" />
    <published>2021-10-01T00:01:00+09:00</published>
  
    <updated>2021-10-01T03:36:11+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-byte-buffer-to-struct/</id>
    <content src="https://rito15.github.io/posts/cs-byte-buffer-to-struct/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      소스 코드


메소드




  


/// &amp;lt;summary&amp;gt; 바이트 버퍼를 읽어서 구조체로 변환하기 &amp;lt;/summary&amp;gt;
public static T? ByteBufferToStruct&amp;lt;T&amp;gt;(byte[] buffer, int offset) where T : struct
{
    int size = Marshal.SizeOf(typeof(T));

    if (buffer.Length - offset &amp;lt; size)
        return null;

    // Unmanaged Heap에 size만큼 메모리 할당
    IntPtr ptr = Marshal.AllocHGlobal(size);

    // buffer[offset]부터 size만큼 읽어서 p...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 쉐이더 - 빌보드(Vert/Frag)</title>
    <link href="https://rito15.github.io/posts/unity-shader-billboard/" rel="alternate" type="text/html" title="유니티 쉐이더 - 빌보드(Vert/Frag)" />
    <published>2021-09-30T21:00:00+09:00</published>
  
    <updated>2021-09-30T21:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-shader-billboard/</id>
    <content src="https://rito15.github.io/posts/unity-shader-billboard/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Shader Memo" />
    
  

  
    <summary>
      





      1. 일반


struct appdata
{
    float4 vertex : POSITION;
    float2 uv : TEXCOORD0;
};

struct v2f
{
    float4 vertex : SV_POSITION;
    float2 uv : TEXCOORD0;
};

float4 Billboard(float4 vertex)
{
    float3 camUpVec      =  normalize( UNITY_MATRIX_V._m10_m11_m12 );
    float3 camForwardVec = -normalize( UNITY_MATRIX_V._m20_m21_m22 );
    float3 camRightVec   =  normalize( UNITY_MATRIX_V._m00_m...
    </summary>
  

  </entry>

</feed>



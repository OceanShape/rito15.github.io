

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-10-18T03:15:53+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>유니티 - 한 번씩만 실행되는 메소드들 순서 정리</title>
    <link href="https://rito15.github.io/posts/unity-initialization-methods/" rel="alternate" type="text/html" title="유니티 - 한 번씩만 실행되는 메소드들 순서 정리" />
    <published>2021-10-16T00:01:00+09:00</published>
  
    <updated>2021-10-16T00:01:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-initialization-methods/</id>
    <content src="https://rito15.github.io/posts/unity-initialization-methods/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor Memo" />
    
  

  
    <summary>
      





      Note


  실행되는 순서대로 작성




Methods


[1] [InitializeOnEnterPlayMode]

  
    Docs
  
  namespace UnityEditor
  메소드 애트리뷰트
  
    정적 메소드에 사용할 수 있다.
  
  플레이 모드에 진입하고, Awake()가 호출되기 전에 딱 1회 실행된다.
    
      씬을 재시작할 때는 실행되지 않는다.
    
  
  컴포넌트로 넣지 않고, 스크립트로만 존재해도 실행된다.


[InitializeOnEnterPlayMode]
private static void Method()
{
    // ...
}




[2] [InitializeOnLoad]

  
    Docs
  
  namespace Uni...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 - 에디터에서 스크립트로 태그, 레이어 추가하기</title>
    <link href="https://rito15.github.io/posts/unity-add-tag-or-layer-in-script/" rel="alternate" type="text/html" title="유니티 - 에디터에서 스크립트로 태그, 레이어 추가하기" />
    <published>2021-10-15T17:00:00+09:00</published>
  
    <updated>2021-10-15T17:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-add-tag-or-layer-in-script/</id>
    <content src="https://rito15.github.io/posts/unity-add-tag-or-layer-in-script/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor Memo" />
    
  

  
    <summary>
      





      Note


프로젝트의 일부를 다른 프로젝트로 옮기는 경우,

특정 씬에서만 사용하는 태그 또는 레이어가 존재할 수 있다.

그런데 옮긴 프로젝트에서 해당 태그 또는 레이어가 존재하지 않으면

직접 추가해줘야 하므로 번거롭다.

따라서 아래 소스 코드를 통해 이를 자동화할 수 있다.



Source Code


using UnityEngine;
using UnityEditor;

public static class EditorTagLayerHelper
{
    /// &amp;lt;summary&amp;gt; 태그 중복 확인 및 추가 &amp;lt;/summary&amp;gt;
    [System.Diagnostics.Conditional("UNITY_EDITOR")]
    public static void AddNewTa...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 - 스크립트의 실행 순서를 보장할 수 없는 경우, 종속적인 작업 처리하기</title>
    <link href="https://rito15.github.io/posts/unity-process-after-initalization/" rel="alternate" type="text/html" title="유니티 - 스크립트의 실행 순서를 보장할 수 없는 경우, 종속적인 작업 처리하기" />
    <published>2021-10-12T04:00:00+09:00</published>
  
    <updated>2021-10-12T15:24:38+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-process-after-initalization/</id>
    <content src="https://rito15.github.io/posts/unity-process-after-initalization/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      요약

A 클래스가 B 클래스에 종속적인 작업을 수행할 때,

B 클래스가 초기화 작업을 완료하기 전에 A 클래스가 작업을 요청하면 에러가 발생할 수 있다.

예를 들면 서로 다른 클래스의 Awake(), Start(), OnEnable() 호출 순서를 보장할 수 없는 경우를 생각해볼 수 있다.

이런 경우의 해결 방안을 알아본다.



상황 예시


[1] PlayerManager 클래스


  Player 객체들을 리스트에 담아 관리하며, 리스트에 추가/제거할 수 있는 API를 제공한다.


class PlayerManager : MonoBehaviour
{
    private List&amp;lt;Player&amp;gt; playerList;

    private void Awake()
    {
    ...
    </summary>
  

  </entry>

  
  <entry>
    <title>Sphere Cast to Sphere</title>
    <link href="https://rito15.github.io/posts/sphere-cast-to-sphere/" rel="alternate" type="text/html" title="Sphere Cast to Sphere" />
    <published>2021-10-09T18:26:00+09:00</published>
  
    <updated>2021-10-10T04:33:45+09:00</updated>
  
    <id>https://rito15.github.io/posts/sphere-cast-to-sphere/</id>
    <content src="https://rito15.github.io/posts/sphere-cast-to-sphere/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Algorithm" />
    
    <category term="Algorithms" />
    
  

  
    <summary>
      





      Sphere Cast



  
    공간 상의 한 점에서부터 목표 지점까지 구체를 전진시켜, 구체 표면에 닿는 물체 표면을 검출한다.
  
  
    레이캐스트와는 달리 구체의 반지름을 고려해야 한다.
  




Sphere Cast to Sphere



  
    대상 물체가 구체인 경우에 대해서만 검사한다.
  
  
    충돌 여부와 충돌 지점을 알아내는 것이 목표이다.
  




[1] 충돌 여부 판정

충돌 지점을 계산하기 전에, 우선 충돌 여부를 판정할 필요가 있다.


  
    A : 캐스트 시작 지점
    B : 캐스트 종료 지점
    S : 검사 대상 구체의 중심 위치
    r1 : 캐스트 구체의 반지름
    r2 : 구체 S의 반지름
    d : 점 S에서 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 쉐이더 - 실수 타입들</title>
    <link href="https://rito15.github.io/posts/unity-shader-real-number-types/" rel="alternate" type="text/html" title="유니티 쉐이더 - 실수 타입들" />
    <published>2021-10-07T00:48:00+09:00</published>
  
    <updated>2021-10-07T00:48:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-shader-real-number-types/</id>
    <content src="https://rito15.github.io/posts/unity-shader-real-number-types/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Shader Memo" />
    
  

  
    <summary>
      





      Memo


[1] float

  32비트
  
    유효 숫자 : 6자리
  
  실수 중 정확도가 가장 높다.
  실수 중 연산이 가장 느리다.
  
    정확해야 하는 경우, 대개 사용된다.
  
  예시 : 정점 위치, UV, 복합 스칼라 연산




[2] half

  16비트
  유효 숫자 : 3자리
  
    표현 범위 : -60,000.0 ~ +60,000.0
  
  예시 : 방향 벡터, HDR 색상




[3] fixed

  11비트
  정밀도 : 1/256
  
    표현 범위 : -2.0 ~ +2.0
  
  연산이 가장 빠르다.
  
    작은 범위에서 한정된 LDR 색상 등에 사용된다.
  
  예시 : Albedo, Emission, Normal




Ref...
    </summary>
  

  </entry>

</feed>



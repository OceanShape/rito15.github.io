

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-09-14T04:28:00+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>.NET CIL 명령어 모음</title>
    <link href="https://rito15.github.io/posts/dotnet-cil-instructions/" rel="alternate" type="text/html" title=".NET CIL 명령어 모음" />
    <published>2021-09-14T03:55:00+09:00</published>
  
    <updated>2021-09-14T03:55:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/dotnet-cil-instructions/</id>
    <content src="https://rito15.github.io/posts/dotnet-cil-instructions/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Grammar" />
    
  

  
    <summary>
      





      Instructions


Stack

  스택 : 계산 스택(Evaluation Stack)
  “스택의 값”을 언급하는 경우는 스택의 값을 꺼내어(Pop) 사용한다는 의미이다.
  “스택의 두 값”을 언급하는 경우는 스택에서 두 값을 꺼내어 사용한다는 의미이다.
  
    “스택의 두 값 A B”를 언급하는 경우, A는 스택에 먼저 넣었던 값이고 B는 그 다음에 넣은 값(Top)이다.
  
  ld로 시작하는 명령어는 Load를 의미하며, 대상의 값을 스택에 넣는다.
  
    ldFOO.0 명령어는 FOO 목록의 0번 인덱스에 있는 값을 스택에 넣는다.
  
  st로 시작하는 명령어는 Store를 의미하며, 스택의 값을 꺼내 다른 곳에 저장한다.
  stFOO.0 명령어는 스택에서 값을 꺼내...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# if-else if vs switch-case vs Dictionary</title>
    <link href="https://rito15.github.io/posts/cs-switch-case-vs-dictionary/" rel="alternate" type="text/html" title="C# if-else if vs switch-case vs Dictionary" />
    <published>2021-09-13T00:01:00+09:00</published>
  
    <updated>2021-09-13T05:00:59+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-switch-case-vs-dictionary/</id>
    <content src="https://rito15.github.io/posts/cs-switch-case-vs-dictionary/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      분기 처리


특정 변수의 값에 따라 분기를 나누어 처리해야 하는 경우,

일반적으로 if-else if 또는 switch-case문을 사용할 수 있다.

int value = someValue;

if(value == 0) DoSomething0();
else if(value == 1) DoSomething1();
else if(value == 2) DoSomething2();


int value = someValue;

switch(value)
{
    case 0 : DoSomething0() break;
    case 1 : DoSomething1() break;
    case 2 : DoSomething2() break;
}


그리고 이를 Dictionary를 통해 처리할 수도 있다....
    </summary>
  

  </entry>

  
  <entry>
    <title>(Amplify) Screen Effect - Ice (Freezing)</title>
    <link href="https://rito15.github.io/posts/unity-amplify-screen-ice/" rel="alternate" type="text/html" title="(Amplify) Screen Effect - Ice (Freezing)" />
    <published>2021-09-12T01:01:00+09:00</published>
  
    <updated>2021-09-13T05:19:26+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-amplify-screen-ice/</id>
    <content src="https://rito15.github.io/posts/unity-amplify-screen-ice/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Amplify Shader" />
    
  

  
    <summary>
      





      Summary


  
    화면이 가장자리부터 얼어붙는 효과
  
  
    스크린 이펙트 적용 애셋 : Link
  




Preview








Properties



  Ice Texture
    
      얼음 효과로 사용할 텍스쳐
      원하는 텍스쳐를 사용하면 된다.
    
  
  Range
    
      효과 적용 범위 (0 ~ 1)
    
  
  Noise Scale
    
      기본 값 : 4
      노이즈 적용 스케일
    
  
  Power A
    
      기본 값 : 3
      영역의 모양
      작을수록 원형, 클수록 사각형에 가까워진다.
    
  
  Power B
    
      기본 값 : 2
      ...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# Deconstructor</title>
    <link href="https://rito15.github.io/posts/cs-deconstructor/" rel="alternate" type="text/html" title="C# Deconstructor" />
    <published>2021-09-11T04:32:00+09:00</published>
  
    <updated>2021-09-11T04:32:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-deconstructor/</id>
    <content src="https://rito15.github.io/posts/cs-deconstructor/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Grammar" />
    
  

  
    <summary>
      





      Deconstructor


class Student
{
    public int id;
    public string name;
}


클래스가 있다.

Student student = new Student();


객체도 있다.

(int id, string name) = student;


위와 같이 한다고 해서 객체의 필드들이 각각의 변수에 할당되지는 않는다.



class Student
{
    public int id;
    public string name;

    public void Deconstruct(out int id, out string name)
    {
        id = this.id;
        name = this.name;
    }
}


그런데 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# Tuple, ValueTuple</title>
    <link href="https://rito15.github.io/posts/cs-tuple-and-value-tuple/" rel="alternate" type="text/html" title="C# Tuple, ValueTuple" />
    <published>2021-09-11T03:45:00+09:00</published>
  
    <updated>2021-09-11T03:45:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-tuple-and-value-tuple/</id>
    <content src="https://rito15.github.io/posts/cs-tuple-and-value-tuple/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Grammar" />
    
  

  
    <summary>
      





      Note


Tuple, ValueTuple은 C# 7.0에 처음 도입되었다.

두 개 이상의 타입을 함께 묶어 사용할 때,

클래스나 구조체를 따로 정의하지 않고 곧바로 사용할 수 있게 해준다.



Tuple


클래스 튜플 타입.

클래스 타입이므로 전달할 때 복사가 발생하지 않고, 참조를 전달한다.

Tuple&amp;lt;T1, T2&amp;gt; 같이 명시적으로 타입명을 작성해야 한다.



Tuple&amp;lt;int, float&amp;gt; tuple = (10, 20f); // 불가능


아쉽게도 위와 같은 편리한 생성은 안되고,

Tuple&amp;lt;int, float&amp;gt; tuple = new Tuple&amp;lt;int, float&amp;gt;(10, 20f);


이렇게 명시적으로 생성자를 호출하여 생성해야 한다.
...
    </summary>
  

  </entry>

</feed>



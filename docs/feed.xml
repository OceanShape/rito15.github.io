

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-08-11T00:16:22+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Snow Pile &amp;amp; Clear (Plane에 눈 쌓기, 지우기)</title>
    <link href="https://rito15.github.io/posts/unity-snow-pile-and-clear/" rel="alternate" type="text/html" title="Snow Pile &amp;amp; Clear (Plane에 눈 쌓기, 지우기)" />
    <published>2021-08-10T23:23:00+09:00</published>
  
    <updated>2021-08-10T23:23:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-snow-pile-and-clear/</id>
    <content src="https://rito15.github.io/posts/unity-snow-pile-and-clear/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Toys" />
    
  

  
    <summary>
      





      Summary


  
    파티클이 닿는 지점에 눈 쌓기
  
  
    쌓인 눈 지우기
  




Preview


[1] 쌓기






[2] 지우기






Details


[1] Ground 쉐이더


  
    메인 텍스쳐의 색상을 그대로 최종 색상으로 출력한다.
  
  
    메인 텍스쳐의 rgb 값 중 하나를 Height Map으로 사용하여, 버텍스 Y 위치값에 더해준다.
  
  
    마테리얼을 생성하여 Plane에 적용한다.
  




[2] 렌더 텍스쳐


  
    게임 시작 시 렌더 텍스쳐를 하나 생성한다.
  
  
    Ground 마테리얼의 메인 텍스쳐에 렌더 텍스쳐를 넣어준다.
  




[3] 브러시 텍스쳐


  
    마치 Default ...
    </summary>
  

  </entry>

  
  <entry>
    <title>(Amplify) Shockwave Shader</title>
    <link href="https://rito15.github.io/posts/unity-amplify-shockwave-shader/" rel="alternate" type="text/html" title="(Amplify) Shockwave Shader" />
    <published>2021-08-10T20:10:00+09:00</published>
  
    <updated>2021-08-10T20:10:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-amplify-shockwave-shader/</id>
    <content src="https://rito15.github.io/posts/unity-amplify-shockwave-shader/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Amplify Shader" />
    
  

  
    <summary>
      





      Summary



  Quad 기반 Shockwave 쉐이더




Preview








Properties




Progress 값이 증가함에 따라 Shockwave가 퍼져나간다.

(범위 : 0 ~ 1)



Settings


General

  Light Model : Unlit


Blend Mode

  Transparent




Nodes






Download



  2021_0810_Shockwave.zip



    </summary>
  

  </entry>

  
  <entry>
    <title>C# If vs. try-catch 성능</title>
    <link href="https://rito15.github.io/posts/cs-if-vs-try-performance/" rel="alternate" type="text/html" title="C# If vs. try-catch 성능" />
    <published>2021-08-09T14:41:00+09:00</published>
  
    <updated>2021-08-09T14:41:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-if-vs-try-performance/</id>
    <content src="https://rito15.github.io/posts/cs-if-vs-try-performance/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      Note


개발을 하다보면 고민되는 경우가 많다.

예외 조건을 처리할 때 if로 예외를 회피할지, try-catch로 처리할지,

실제 성능은 어떻게 될지도 궁금한 부분이다.



try-catch는 예외가 발생하지 않으면 성능 소모가 없다고도 하고,

성능 소모가 있지만 O(1)이라고도 하고,

찾아보면 다양한 주장들을 확인해볼 수 있다.



대신 공통적인 사실은

try-catch를 통해 예외를 핸들링하게 되면

무조건 if보다 성능 소모가 크다는 점이다.

try-catch는 예외 발생 지점의 스택을 거슬러 올라가서

모두 추적하고 기록하게 되는데,

이 과정에서 성능 소모가 크게 발생한다는 것이다.



이제 몇가지 테스트 케이스를 통해서 성능을 테스트하고,

if와 try-catch 선택...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# ArraySegment&amp;lt;T&amp;gt;, Span&amp;lt;T&amp;gt;, Memory&amp;lt;T&amp;gt;</title>
    <link href="https://rito15.github.io/posts/cs-arraysegment-span-memory/" rel="alternate" type="text/html" title="C# ArraySegment&amp;lt;T&amp;gt;, Span&amp;lt;T&amp;gt;, Memory&amp;lt;T&amp;gt;" />
    <published>2021-08-08T20:00:00+09:00</published>
  
    <updated>2021-08-10T01:07:40+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-arraysegment-span-memory/</id>
    <content src="https://rito15.github.io/posts/cs-arraysegment-span-memory/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      Array



  https://docs.microsoft.com/ko-kr/dotnet/csharp/programming-guide/arrays/single-dimensional-arrays
  https://docs.microsoft.com/ko-kr/dotnet/api/system.array?view=net-5.0




특징

  고정된 크기의 일차원 배열을 만든다.
  배열은 관리되는 힙 메모리에 저장된다.




ArraySegment&amp;lt;T&amp;gt;



   
…


  참고

  
     
.


    
      https://docs.microsoft.com/ko-kr/dotnet/api/system.arraysegment-1?view=net-5.0
      https://j...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# UTF8 문자열을 힙 할당 없이 byte 배열로 직렬화하기</title>
    <link href="https://rito15.github.io/posts/cs-utf8-string-to-byte-array/" rel="alternate" type="text/html" title="C# UTF8 문자열을 힙 할당 없이 byte 배열로 직렬화하기" />
    <published>2021-08-08T19:31:00+09:00</published>
  
    <updated>2021-08-08T19:31:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-utf8-string-to-byte-array/</id>
    <content src="https://rito15.github.io/posts/cs-utf8-string-to-byte-array/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      1. 힙 할당 있는 방식


string str = "가나다 ABC 123";

byte[] byteStr = Encoding.UTF8.GetBytes(str);




2. 힙 할당 없는 방식



  요지 : 미리 생성된 byte[]의 특정 offset에 문자열을 직렬화하여 복제하기




버퍼를 이용한 직렬화 예시

using System;
using System.Text;

class UTF8StringBuffer
{
    private byte[] buffer = new byte[1024 * 100];
    private int readPos = 0;
    private int writePos = 0;

    private void WriteCompleted(int pos) =&amp;gt; ...
    </summary>
  

  </entry>

</feed>



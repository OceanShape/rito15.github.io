

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-08-10T01:04:29+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>C# If vs. try-catch 성능</title>
    <link href="https://rito15.github.io/posts/cs-if-vs-try-performance/" rel="alternate" type="text/html" title="C# If vs. try-catch 성능" />
    <published>2021-08-09T14:41:00+09:00</published>
  
    <updated>2021-08-09T14:41:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-if-vs-try-performance/</id>
    <content src="https://rito15.github.io/posts/cs-if-vs-try-performance/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      Note


개발을 하다보면 고민되는 경우가 많다.

예외 조건을 처리할 때 if로 예외를 회피할지, try-catch로 처리할지,

실제 성능은 어떻게 될지도 궁금한 부분이다.



try-catch는 예외가 발생하지 않으면 성능 소모가 없다고도 하고,

성능 소모가 있지만 O(1)이라고도 하고,

찾아보면 다양한 주장들을 확인해볼 수 있다.



대신 공통적인 사실은

try-catch를 통해 예외를 핸들링하게 되면

무조건 if보다 성능 소모가 크다는 점이다.

try-catch는 예외 발생 지점의 스택을 거슬러 올라가서

모두 추적하고 기록하게 되는데,

이 과정에서 성능 소모가 크게 발생한다는 것이다.



이제 몇가지 테스트 케이스를 통해서 성능을 테스트하고,

if와 try-catch 선택...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# ArraySegment&amp;lt;T&amp;gt;, Span&amp;lt;T&amp;gt;, Memory&amp;lt;T&amp;gt;</title>
    <link href="https://rito15.github.io/posts/cs-arraysegment-span-memory/" rel="alternate" type="text/html" title="C# ArraySegment&amp;lt;T&amp;gt;, Span&amp;lt;T&amp;gt;, Memory&amp;lt;T&amp;gt;" />
    <published>2021-08-08T20:00:00+09:00</published>
  
    <updated>2021-08-08T20:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-arraysegment-span-memory/</id>
    <content src="https://rito15.github.io/posts/cs-arraysegment-span-memory/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      Array



  https://docs.microsoft.com/ko-kr/dotnet/csharp/programming-guide/arrays/single-dimensional-arrays
  https://docs.microsoft.com/ko-kr/dotnet/api/system.array?view=net-5.0




특징

  고정된 크기의 일차원 배열을 만든다.
  배열은 관리되는 힙 메모리에 저장된다.




ArraySegment&amp;lt;T&amp;gt;



   
…


  참고

  
     
.


    
      https://docs.microsoft.com/ko-kr/dotnet/api/system.arraysegment-1?view=net-5.0
      https://j...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# UTF8 문자열을 힙 할당 없이 byte 배열로 직렬화하기</title>
    <link href="https://rito15.github.io/posts/cs-utf8-string-to-byte-array/" rel="alternate" type="text/html" title="C# UTF8 문자열을 힙 할당 없이 byte 배열로 직렬화하기" />
    <published>2021-08-08T19:31:00+09:00</published>
  
    <updated>2021-08-08T19:31:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-utf8-string-to-byte-array/</id>
    <content src="https://rito15.github.io/posts/cs-utf8-string-to-byte-array/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      1. 힙 할당 있는 방식


string str = "가나다 ABC 123";

byte[] byteStr = Encoding.UTF8.GetBytes(str);




2. 힙 할당 없는 방식



  요지 : 미리 생성된 byte[]의 특정 offset에 문자열을 직렬화하여 복제하기




버퍼를 이용한 직렬화 예시

using System;
using System.Text;

class UTF8StringBuffer
{
    private byte[] buffer = new byte[1024 * 100];
    private int readPos = 0;
    private int writePos = 0;

    private void WriteCompleted(int pos) =&amp;gt; ...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# 간단한 힙 메모리 디버거 (콘솔)</title>
    <link href="https://rito15.github.io/posts/cs-heap-memory-debugger/" rel="alternate" type="text/html" title="C# 간단한 힙 메모리 디버거 (콘솔)" />
    <published>2021-08-08T12:12:00+09:00</published>
  
    <updated>2021-08-08T12:12:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-heap-memory-debugger/</id>
    <content src="https://rito15.github.io/posts/cs-heap-memory-debugger/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      기능



  원하는 지점의 힙 메모리 크기 기록
  기록된 두 지점의 힙 메모리 크기 차이 출력




주의사항



  Print() 이후에는 Record()하지 않아야 한다.
    
      Future Works : Print() 내에서 스트링을 스택에 할당하여 해결
    
  




사용 예시


HeapDebugger.Record(0);

int[] array = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

HeapDebugger.Record(1);

new string("ABCDE");

HeapDebugger.Record(2);

HeapDebugger.PrintDiff(0, 1); // 128
HeapDebugger.PrintDiff(1, 2); // 32
He...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# 패킷을 byte[]로 직렬화하는 다양한 방법</title>
    <link href="https://rito15.github.io/posts/cs-serializations-to-byte-array/" rel="alternate" type="text/html" title="C# 패킷을 byte[]로 직렬화하는 다양한 방법" />
    <published>2021-08-08T02:34:00+09:00</published>
  
    <updated>2021-08-09T03:03:52+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-serializations-to-byte-array/</id>
    <content src="https://rito15.github.io/posts/cs-serializations-to-byte-array/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      Note



  
    비교적 단순한 형태의 패킷들을 정의한다.
  
  
    패킷을 다양한 방법으로 직렬화하여 byte[] 타입 버퍼에 순서대로 넣으며, 성능을 검사한다.
  
  
    직렬화된 결과의 크기는 패킷 내 모든 필드의 크기의 합이어야 한다.
  
  
    문자열 패킷은 어차피 공통적으로 인코딩을 거쳐야 하므로, 제외한다.
  
  
    BenchmarkDotNet을 통해 벤치마크를 진행한다.
  




패킷 정의



   
Source Code


  public class Packet
{
    public ushort size;
    public ushort id;

    public Packet(ushort id)
    {
        this.id = ...
    </summary>
  

  </entry>

</feed>



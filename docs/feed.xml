

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-09-29T16:31:04+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>유니티 - sRGB, Linear, Gamma 컬러 스페이스</title>
    <link href="https://rito15.github.io/posts/unity-srgb-linear-gamma-color-space/" rel="alternate" type="text/html" title="유니티 - sRGB, Linear, Gamma 컬러 스페이스" />
    <published>2021-09-29T03:21:00+09:00</published>
  
    <updated>2021-09-29T03:21:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-srgb-linear-gamma-color-space/</id>
    <content src="https://rito15.github.io/posts/unity-srgb-linear-gamma-color-space/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      모니터의 색상 변환


  모니터는 디스크에 저장된 이미지를 화면에 출력할 때 Pow(color, 2.2) 연산을 적용해서 더 어둡게 출력한다.





  이유?
    
      베버의 법칙(Weber’s law)
      사람의 시각은 어두운 부분의 밝기 변화를 부드럽지 않고 단절되게 감지한다.
      그래서 어두운 부분의 화질이 떨어져 보이는 현상이 발생한다.
      따라서 이를 부드럽게 감지하도록 하려면 어두운 부분을 더 풍부하게 표현할 필요가 있다.
      따라서 모니터 하드웨어적으로 이런 변환을 해준다.
    
  
  Pow(color, 2.2)이면 감마(Gamma)가 2.2라고 한다.




Gamma Correction(감마 보정)이란?


  이미지를 디스크에 저장할...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 - 진공 청소기, 먼지 시뮬레이션</title>
    <link href="https://rito15.github.io/posts/unity-million-dust-simulation/" rel="alternate" type="text/html" title="유니티 - 진공 청소기, 먼지 시뮬레이션" />
    <published>2021-09-27T17:00:00+09:00</published>
  
    <updated>2021-09-27T17:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-million-dust-simulation/</id>
    <content src="https://rito15.github.io/posts/unity-million-dust-simulation/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Study" />
    
  

  
    <summary>
      





      목표


  수십만 개의 먼지를 렌더링한다.
  먼지들의 움직임을 시뮬레이션한다.
  진공 청소기로 먼지들을 예쁘게 빨아들인다.






주요 개념


Compute Buffer

  큰 병렬 데이터를 GPU에 전달하거나 쉐이더끼리 공유하기 위해 사용한다.
  Vert/Frag, Compute Shader에서 StructuredBuffer&amp;lt;T&amp;gt; 타입 변수로 사용할 수 있다.


Graphics.DrawMeshInstancedIndirect()

  컴퓨트 버퍼의 메시 데이터를 GPU Instancing을 적용하여 대규모로 렌더링할 수 있다.


Compute Shader

  GPGPU를 통해 병렬적으로 연산을 적용할 수 있다.






1. 10만개의 먼지 만들기


렌더링될 메시의 버...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 쉐이더 - 랜덤 함수들</title>
    <link href="https://rito15.github.io/posts/unity-shader-random-functions/" rel="alternate" type="text/html" title="유니티 쉐이더 - 랜덤 함수들" />
    <published>2021-09-26T21:19:00+09:00</published>
  
    <updated>2021-09-26T21:19:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-shader-random-functions/</id>
    <content src="https://rito15.github.io/posts/unity-shader-random-functions/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Shader Memo" />
    
  

  
    <summary>
      





      Memo


float Random(float2 seed)
{
    return frac(sin(dot(seed, float2(73.867, 25.241))) * 39482.17593);
}

float RandomRange(float2 seed, float min, float max)
{
    float t = frac(sin(dot(seed, float2(73.867, 25.241))) * 39482.17593);
    return lerp(min, max, t);
}

float3 RandomRGB(float2 seed)
{
    float r = frac(sin(dot(seed, float2(12.586, 25.241))) * 39482.17593);
    float g = frac(c...
    </summary>
  

  </entry>

  
  <entry>
    <title>자료구조 - 힙(Heap), 우선순위 큐(Priority Queue)</title>
    <link href="https://rito15.github.io/posts/heap-priority-queue/" rel="alternate" type="text/html" title="자료구조 - 힙(Heap), 우선순위 큐(Priority Queue)" />
    <published>2021-09-24T21:03:00+09:00</published>
  
    <updated>2021-09-24T21:03:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/heap-priority-queue/</id>
    <content src="https://rito15.github.io/posts/heap-priority-queue/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Algorithm" />
    
    <category term="Data Structure" />
    
  

  
    <summary>
      





      트리 자료 구조




트리(Tree)


  재귀적 계층 구조
  노드로 이루어져 있다.
  최초의 루트 노드에서부터 시작하며, 하나의 부모 노드는 여러 개의 자식 노드를 가진다.






이진 트리(Binary Tree)


  각 노드가 최대 두 개의 자식만 가질 수 있는 트리 구조






포화 이진 트리(Perfect Binary Tree)


  모든 잎 노드(Leaf Node : 자식이 없는 노드)가 같은 계층에 위치한 노드
  완전한 삼각형 꼴을 이룬 이진 트리 구조를 의미한다.






완전 이진 트리(Complete Binary Tree)


  마지막 계층 이전까지의 계층이 포화 이진 트리를 이룬 구조
  마지막 계층은 왼쪽에서부터 채워지는 구조
  일차원 배열을 통해 표현될 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# XmlReader</title>
    <link href="https://rito15.github.io/posts/cs-xml-reader/" rel="alternate" type="text/html" title="C# XmlReader" />
    <published>2021-09-21T21:52:00+09:00</published>
  
    <updated>2021-09-21T21:52:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-xml-reader/</id>
    <content src="https://rito15.github.io/posts/cs-xml-reader/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      XML


eXTensible Markup Language의 약자로, W3C에서 개발된 마크업 언어.

XML의 대표적인 파생 언어로 HTML이 있다.

기본적인 XML 파일의 확장자는 .xml이다.



XML 문법



   
…


  예시
  
    패킷 데이터 목록 정의
  

  &amp;lt;?xml version="1.0" encoding="utf-8" ?&amp;gt;

&amp;lt;!-- Packet Data List --&amp;gt;
&amp;lt;packets&amp;gt; &amp;lt;!-- 루트 태그 --&amp;gt;
    &amp;lt;packet name="Echo"&amp;gt;
    &amp;lt;/packet&amp;gt;
    
    &amp;lt;packet name="Number"&amp;gt;
        &amp;lt;int name="number...
    </summary>
  

  </entry>

</feed>



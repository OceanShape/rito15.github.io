

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-10-08T03:37:10+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>유니티 쉐이더 - 실수 타입들</title>
    <link href="https://rito15.github.io/posts/unity-shader-real-number-types/" rel="alternate" type="text/html" title="유니티 쉐이더 - 실수 타입들" />
    <published>2021-10-07T00:48:00+09:00</published>
  
    <updated>2021-10-07T00:48:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-shader-real-number-types/</id>
    <content src="https://rito15.github.io/posts/unity-shader-real-number-types/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Shader Memo" />
    
  

  
    <summary>
      





      Memo


[1] float

  32비트
  
    유효 숫자 : 6자리
  
  실수 중 정확도가 가장 높다.
  실수 중 연산이 가장 느리다.
  
    정확해야 하는 경우, 대개 사용된다.
  
  예시 : 정점 위치, UV, 복합 스칼라 연산




[2] half

  16비트
  유효 숫자 : 3자리
  
    표현 범위 : -60,000.0 ~ +60,000.0
  
  예시 : 방향 벡터, HDR 색상




[3] fixed

  11비트
  정밀도 : 1/256
  
    표현 범위 : -2.0 ~ +2.0
  
  연산이 가장 빠르다.
  
    작은 범위에서 한정된 LDR 색상 등에 사용된다.
  
  예시 : Albedo, Emission, Normal




Ref...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 - Vert/Frag 쉐이더에서 Receive Shadow, Cast Shadow 구현하기</title>
    <link href="https://rito15.github.io/posts/unity-shader-receive-and-cast-shadow/" rel="alternate" type="text/html" title="유니티 - Vert/Frag 쉐이더에서 Receive Shadow, Cast Shadow 구현하기" />
    <published>2021-10-07T00:01:00+09:00</published>
  
    <updated>2021-10-07T00:01:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-shader-receive-and-cast-shadow/</id>
    <content src="https://rito15.github.io/posts/unity-shader-receive-and-cast-shadow/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Shader Study" />
    
  

  
    <summary>
      





      Surface Shader


  쉐이더를 빠르게 작성할 수 있도록 다양한 편의를 제공한다.
  Surface 쉐이더 함수는 #pragma surface Surface쉐이더함수명으로 등록한다.
  미리 만들어진 라이팅을 간편히 적용할 수 있다.
  커스텀 라이트를 작성하는 것도 어렵지 않다.
  Receive Shadow, Cast Shadow는 자동으로 적용된다.
  Surface 쉐이더 함수는 기본적으로 Fragment 쉐이더 함수에 대응되며, 필요하다면 Vertex 쉐이더 함수를 따로 추가할 수 있다.





   
Surface Shader Example


  Shader "Custom/BasicSurfaceShader"
{
    Properties
    {
        _Color (...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# 배열에 같은 값을 넣으면서 선언하기</title>
    <link href="https://rito15.github.io/posts/cs-memo-linq/" rel="alternate" type="text/html" title="C# 배열에 같은 값을 넣으면서 선언하기" />
    <published>2021-10-06T22:00:00+09:00</published>
  
    <updated>2021-10-06T22:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-memo-linq/</id>
    <content src="https://rito15.github.io/posts/cs-memo-linq/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      Memo


// 인덱스 0부터 99까지 정수 1로 채우기
int[] arr = Enumerable.Repeat(1, 100).ToArray();


물론 LINQ를 쓰는 만큼, 중간 버퍼의 가비지는 감안해야 한다.



.NET 5.0 버전이라면 Array.Fill() 메소드를 사용하면 된다.

int[] arr = new int[100];
Array.Fill(arr, 1); // 배열 전체에 1로 채우기


    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 - 컴퓨트 버퍼를 통한 GPU 인스턴싱</title>
    <link href="https://rito15.github.io/posts/unity-compute-buffer-gpu-instancing/" rel="alternate" type="text/html" title="유니티 - 컴퓨트 버퍼를 통한 GPU 인스턴싱" />
    <published>2021-10-06T15:15:00+09:00</published>
  
    <updated>2021-10-07T01:08:09+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-compute-buffer-gpu-instancing/</id>
    <content src="https://rito15.github.io/posts/unity-compute-buffer-gpu-instancing/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Shader Study" />
    
  

  
    <summary>
      





      GPU Instancing


[1] 컴퓨트 버퍼 - 메시 데이터

  그려낼 메시의 정보를 컴퓨트 버퍼에 저장한다.
  컴퓨트 버퍼의 stride는 4 byte(sizeof(uint))이다.
  컴퓨트 버퍼의 크기는 20 byte(uint 5개)이며, 각각의 데이터는 메시에 대한 정보를 담고 있다.


Mesh mesh;                     // 그려낼 메시
int subMeshIndex = 0;          // 기본 : 0
int instanceCount = 100_000;   // 생성할 인스턴스의 개수
uint[] argsData = new uint[5]; // 메시 데이터

argsData[0] = (uint)mesh.GetIndexCount(subMeshIndex);
a...
    </summary>
  

  </entry>

  
  <entry>
    <title>레이캐스트 - 평면(Plane)</title>
    <link href="https://rito15.github.io/posts/raycast-to-plane/" rel="alternate" type="text/html" title="레이캐스트 - 평면(Plane)" />
    <published>2021-10-03T22:22:00+09:00</published>
  
    <updated>2021-10-04T04:13:50+09:00</updated>
  
    <id>https://rito15.github.io/posts/raycast-to-plane/</id>
    <content src="https://rito15.github.io/posts/raycast-to-plane/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Algorithm" />
    
    <category term="Algorithms" />
    
  

  
    <summary>
      





      레이캐스트(Raycast)



  공간 상의 한 점에서부터 목표 지점까지 가상의 광선을 발사하여, 광선에 닿는 물체의 표면을 검출한다.




평면(Plane)




평면 위의 점 P와 평면의 법선 벡터 N을 알고 있으면 평면을 정의할 수 있으며,

평면 위의 임의의 점 X를 가정하여 dot(N, P - X) = 0을 통해 평면의 방정식을 정의할 수 있다.



직선과 평면의 접점 찾기


점 A에서 점 B를 향해 광선을 발사하여, 광선(직선)과 평면이 만나는 지점을 찾는다.



위와 같이 A, B, P, N이 주어졌을 때,

길이 d를 알아내고 이를 통해 직선과 평면의 접점 C를 알아내야 한다.



평면의 정의에 의해 다음과 같은 식을 얻을 수 있다.

\[dot(N, P - C) = 0\]
...
    </summary>
  

  </entry>

</feed>



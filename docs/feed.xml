

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-10-12T04:43:16+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>유니티 - 스크립트의 실행 순서를 보장할 수 없는 경우, 종속적인 작업 처리하기</title>
    <link href="https://rito15.github.io/posts/unity-process-after-initalization/" rel="alternate" type="text/html" title="유니티 - 스크립트의 실행 순서를 보장할 수 없는 경우, 종속적인 작업 처리하기" />
    <published>2021-10-12T04:00:00+09:00</published>
  
    <updated>2021-10-12T04:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-process-after-initalization/</id>
    <content src="https://rito15.github.io/posts/unity-process-after-initalization/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      요약

A 클래스가 B 클래스에 종속적인 작업을 수행할 때,

B 클래스가 초기화 작업을 완료하기 전에 A 클래스가 작업을 요청하면 에러가 발생할 수 있다.

예를 들면 서로 다른 클래스의 Awake(), Start(), OnEnable() 호출 순서를 보장할 수 없는 경우를 생각해볼 수 있다.

이런 경우의 해결 방안을 알아본다.



상황 예시


[1] PlayerManager 클래스


  Player 클래스들을 리스트에 담아 관리하며, 추가/제거할 수 있는 API를 제공한다.


class PlayerManager : MonoBehaviour
{
    private List&amp;lt;Player&amp;gt; playerList;

    private void Awake()
    {
        ...
    </summary>
  

  </entry>

  
  <entry>
    <title>Sphere Cast to Sphere</title>
    <link href="https://rito15.github.io/posts/sphere-cast-to-sphere/" rel="alternate" type="text/html" title="Sphere Cast to Sphere" />
    <published>2021-10-09T18:26:00+09:00</published>
  
    <updated>2021-10-10T04:33:45+09:00</updated>
  
    <id>https://rito15.github.io/posts/sphere-cast-to-sphere/</id>
    <content src="https://rito15.github.io/posts/sphere-cast-to-sphere/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Algorithm" />
    
    <category term="Algorithms" />
    
  

  
    <summary>
      





      Sphere Cast



  
    공간 상의 한 점에서부터 목표 지점까지 구체를 전진시켜, 구체 표면에 닿는 물체 표면을 검출한다.
  
  
    레이캐스트와는 달리 구체의 반지름을 고려해야 한다.
  




Sphere Cast to Sphere



  
    대상 물체가 구체인 경우에 대해서만 검사한다.
  
  
    충돌 여부와 충돌 지점을 알아내는 것이 목표이다.
  




[1] 충돌 여부 판정

충돌 지점을 계산하기 전에, 우선 충돌 여부를 판정할 필요가 있다.


  
    A : 캐스트 시작 지점
    B : 캐스트 종료 지점
    S : 검사 대상 구체의 중심 위치
    r1 : 캐스트 구체의 반지름
    r2 : 구체 S의 반지름
    d : 점 S에서 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 쉐이더 - 실수 타입들</title>
    <link href="https://rito15.github.io/posts/unity-shader-real-number-types/" rel="alternate" type="text/html" title="유니티 쉐이더 - 실수 타입들" />
    <published>2021-10-07T00:48:00+09:00</published>
  
    <updated>2021-10-07T00:48:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-shader-real-number-types/</id>
    <content src="https://rito15.github.io/posts/unity-shader-real-number-types/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Shader Memo" />
    
  

  
    <summary>
      





      Memo


[1] float

  32비트
  
    유효 숫자 : 6자리
  
  실수 중 정확도가 가장 높다.
  실수 중 연산이 가장 느리다.
  
    정확해야 하는 경우, 대개 사용된다.
  
  예시 : 정점 위치, UV, 복합 스칼라 연산




[2] half

  16비트
  유효 숫자 : 3자리
  
    표현 범위 : -60,000.0 ~ +60,000.0
  
  예시 : 방향 벡터, HDR 색상




[3] fixed

  11비트
  정밀도 : 1/256
  
    표현 범위 : -2.0 ~ +2.0
  
  연산이 가장 빠르다.
  
    작은 범위에서 한정된 LDR 색상 등에 사용된다.
  
  예시 : Albedo, Emission, Normal




Ref...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 - Vert/Frag 쉐이더에서 Receive Shadow, Cast Shadow 구현하기</title>
    <link href="https://rito15.github.io/posts/unity-shader-receive-and-cast-shadow/" rel="alternate" type="text/html" title="유니티 - Vert/Frag 쉐이더에서 Receive Shadow, Cast Shadow 구현하기" />
    <published>2021-10-07T00:01:00+09:00</published>
  
    <updated>2021-10-07T00:01:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-shader-receive-and-cast-shadow/</id>
    <content src="https://rito15.github.io/posts/unity-shader-receive-and-cast-shadow/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Shader Study" />
    
  

  
    <summary>
      





      Surface Shader


  쉐이더를 빠르게 작성할 수 있도록 다양한 편의를 제공한다.
  Surface 쉐이더 함수는 #pragma surface Surface쉐이더함수명으로 등록한다.
  미리 만들어진 라이팅을 간편히 적용할 수 있다.
  커스텀 라이트를 작성하는 것도 어렵지 않다.
  Receive Shadow, Cast Shadow는 자동으로 적용된다.
  Surface 쉐이더 함수는 기본적으로 Fragment 쉐이더 함수에 대응되며, 필요하다면 Vertex 쉐이더 함수를 따로 추가할 수 있다.





   
Surface Shader Example


  Shader "Custom/BasicSurfaceShader"
{
    Properties
    {
        _Color (...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# 배열에 같은 값을 넣으면서 선언하기</title>
    <link href="https://rito15.github.io/posts/cs-memo-linq/" rel="alternate" type="text/html" title="C# 배열에 같은 값을 넣으면서 선언하기" />
    <published>2021-10-06T22:00:00+09:00</published>
  
    <updated>2021-10-06T22:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-memo-linq/</id>
    <content src="https://rito15.github.io/posts/cs-memo-linq/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      Memo


// 인덱스 0부터 99까지 정수 1로 채우기
int[] arr = Enumerable.Repeat(1, 100).ToArray();


물론 LINQ를 쓰는 만큼, 중간 버퍼의 가비지는 감안해야 한다.



.NET 5.0 버전이라면 Array.Fill() 메소드를 사용하면 된다.

int[] arr = new int[100];
Array.Fill(arr, 1); // 배열 전체에 1로 채우기


    </summary>
  

  </entry>

</feed>





<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Game Programmer</subtitle>
  <updated>2021-11-22T20:59:11+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>유니티 - 드로우 콜과 배칭 개념 간단 정리</title>
    <link href="https://rito15.github.io/posts/unity-draw-call-and-batching/" rel="alternate" type="text/html" title="유니티 - 드로우 콜과 배칭 개념 간단 정리" />
    <published>2021-11-22T20:13:00+09:00</published>
  
    <updated>2021-11-22T20:13:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-draw-call-and-batching/</id>
    <content src="https://rito15.github.io/posts/unity-draw-call-and-batching/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Optimization" />
    
  

  
    <summary>
      





      1. CPU와 GPU의 상호작용


CPU에서 GPU에 명령하기

  일반적으로 CPU에서 렌더링, 상태 변경 등의 명령을 GPU에 전달한다.
  그런데 GPU가 바쁘게 작업하는 도중이라면, CPU는 GPU의 작업이 끝나기를 하염없이 기다리게 될 수 있다.
  따라서 커맨드 패턴(Command Pattern)과 메시지 큐(Message Queue)에 의한 비동기 방식을 활용한다.
  CPU에서 GPU에 전달할 명령(Command)을 임시 공간에 담아 두고, GPU가 여유 될 때 명령을 하나씩 꺼내어 처리한다.


Command Buffer(커맨드 버퍼)

  CPU의 각 스레드에서는 GPU에 전달할 렌더링 관련 명령을 모듈화하여 커맨드 버퍼에 차곡차곡 쌓아 임시로 저장한다.
  그리고 GPU의 공유 커...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 - FixedUpdate()에서 이동, 회전 구현 시 버벅임 현상 해결하기</title>
    <link href="https://rito15.github.io/posts/unity-fixed-update-and-stuttering/" rel="alternate" type="text/html" title="유니티 - FixedUpdate()에서 이동, 회전 구현 시 버벅임 현상 해결하기" />
    <published>2021-11-22T00:23:00+09:00</published>
  
    <updated>2021-11-22T00:23:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-fixed-update-and-stuttering/</id>
    <content src="https://rito15.github.io/posts/unity-fixed-update-and-stuttering/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Tips" />
    
  

  
    <summary>
      





      Update()와 FixedUpdate()


Update()

Update() 메소드는 프레임 당 한 번씩 호출된다.

그리고 이동, 회전 등을 구현할 경우 프레임 간의 호출 간격을 고려하고

단위 시간 당 일정한 수치로 기능을 구현하기 위해 Time.deltaTime을 사용한다.



FixedUpdate()

리지드바디를 사용할 때, 즉 물리 엔진의 기능을 이용할 때 사용하는 메소드.

FixedUpdate() 메소드는 Fixed Time Step 주기(기본 0.02초)마다 한 번씩 호출되도록 보정된다.

그냥 ‘호출된다’가 아니고, ‘호출되도록 보정된다’.

왜냐하면, FixedUpdate()의 호출은 Update()를 호출하는 게임 루프와 별도의 루프, 혹은 멀티스레드에 의해 발생하지 않기 때...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 - Time.deltaTime과 Time.fixedDeltaTime의 올바른 이해</title>
    <link href="https://rito15.github.io/posts/unity-deltatime-and-fixeddeltatime/" rel="alternate" type="text/html" title="유니티 - Time.deltaTime과 Time.fixedDeltaTime의 올바른 이해" />
    <published>2021-11-21T23:45:00+09:00</published>
  
    <updated>2021-11-21T23:45:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-deltatime-and-fixeddeltatime/</id>
    <content src="https://rito15.github.io/posts/unity-deltatime-and-fixeddeltatime/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Tips" />
    
  

  
    <summary>
      





      deltaTime과 fixedDeltaTime


deltaTime

Time.deltaTime을 통해 참조할 수 있다.

이전 프레임의 발생 시각과 현재 프레임의 발생 시각 사이의 시간 간격,

즉 이전 프레임의 수행에 걸린 시간을 의미한다.

Update() 내에서 시간의 진행에 따른 일정한 기능을 구현하기 위해 Time.deltaTime을 이용해 보정한다.



fixedDeltaTime

Time.fixedDeltaTime을 통해 참조할 수 있다.

기본적으로 물리 업데이트 발생 주기, 즉 Fixed Time Step 값을 의미한다.

마찬가지로 FixedUpdate() 내에서 Time.fixedDeltaTime을 이용해 보정한다.



Frame Rate


‘프레임률’이라고도 부르며, 초당 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>(Amplify) Screen Effect - Chromatic Aberration</title>
    <link href="https://rito15.github.io/posts/unity-amplify-screen-chromatic-aberration/" rel="alternate" type="text/html" title="(Amplify) Screen Effect - Chromatic Aberration" />
    <published>2021-11-20T01:01:00+09:00</published>
  
    <updated>2021-11-20T01:01:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-amplify-screen-chromatic-aberration/</id>
    <content src="https://rito15.github.io/posts/unity-amplify-screen-chromatic-aberration/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="Amplify Shader" />
    
  

  
    <summary>
      





      Summary


  
    색수차 효과
  
  
    스크린 이펙트 적용 애셋 : Link
  




Preview






Properties



  Red Offset
    
      R 채널 색상의 화면 UV 진행 방향
    
  
  Green Offset
    
      G 채널 색상의 화면 UV 진행 방향
    
  
  Blue Offset
    
      B 채널 색상의 화면 UV 진행 방향
    
  
  Intensity
    
      색수차 효과 적용 강도
    
  
  Circle Range Power
    
      화면 내에서 원형 효과 범위에 대한 Power 지수 값
      작을수록 화면 전범위에, 클수록 화면 가장자리에만 색수차 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 - 쉐이더에서 파티클 시스템 커스텀 데이터(Custom Data) 사용하기</title>
    <link href="https://rito15.github.io/posts/unity-particle-system-custom-data/" rel="alternate" type="text/html" title="유니티 - 쉐이더에서 파티클 시스템 커스텀 데이터(Custom Data) 사용하기" />
    <published>2021-11-19T15:00:00+09:00</published>
  
    <updated>2021-11-19T15:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-particle-system-custom-data/</id>
    <content src="https://rito15.github.io/posts/unity-particle-system-custom-data/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Particle System" />
    
  

  
    <summary>
      





      커스텀 데이터(Custom Data)


  파티클 시스템의 Custom Data 모듈에서 지정한 값을 쉐이더로 가져와 사용할 수 있다.




1. 파티클 시스템 설정


[1] Custom Data 모듈

  
    Custom Data 모듈에 체크한다.
  
  
    Mode를 Vector 또는 Color로 설정한다.
  
  
    Vector로 설정한 경우, 사용할 채널 개수(Number of Components), 각 채널의 값을 지정한다.
  






[2] Renderer 모듈

  Custom Vertex Streams에 치크한다.







  
    우측 하단의 + 버튼을 눌러 알맞은 커스텀 데이터를 목록에 추가한다.
  
  
    Custom Data 모듈에서 지...
    </summary>
  

  </entry>

</feed>



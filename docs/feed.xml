

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-02-12T16:24:59+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>OpenGL 공부 - 16 - Transform, Input</title>
    <link href="https://rito15.github.io/posts/opengl-study-16/" rel="alternate" type="text/html" title="OpenGL 공부 - 16 - Transform, Input" />
    <published>2021-02-12T15:11:00+09:00</published>
  
    <updated>2021-02-12T15:11:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/opengl-study-16/</id>
    <content src="https://rito15.github.io/posts/opengl-study-16/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="OpenGL" />
    
    <category term="OpenGL Study" />
    
  

  
    <summary>
      





      목표


  오브젝트 기본 트랜스폼 정의하기
  키보드 입력 처리하기




트랜스폼 정의


트랜스폼의 3요소(위치, 회전, 크기)를 정의한다.

glm::vec3 position(0.0f);
glm::vec3 rotation(0.0f);
glm::vec3 scale(1.0f);


그리고 모델 행렬에 트랜스폼 연산을 모두 넣어준다.

modelMatrix = glm::translate(modelMatrix, position);
modelMatrix = glm::rotate(modelMatrix, glm::radians(rotation.x), glm::vec3(1.f, 0.f, 0.f));
modelMatrix = glm::rotate(modelMatrix, glm::radians(rotation.y...
    </summary>
  

  </entry>

  
  <entry>
    <title>ILSpy로 유니티 내부 구현 뜯어보기</title>
    <link href="https://rito15.github.io/posts/unity-ilspy/" rel="alternate" type="text/html" title="ILSpy로 유니티 내부 구현 뜯어보기" />
    <published>2021-02-12T05:32:00+09:00</published>
  
    <updated>2021-02-12T05:32:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-ilspy/</id>
    <content src="https://rito15.github.io/posts/unity-ilspy/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      다운로드


  https://github.com/icsharpcode/ILSpy/releases
  vsix를 받을 경우, 비주얼 스튜디오의 확장으로 추가하여 [도구] - [ILSpy]를 통해 바로 실행할 수 있다.




사용법


  
    ILSpy를 실행한다.
  
  
    File - Open으로 대상 어셈블리(dll, exe 등)를 불러온다.
  
  
    검색을 통해 원하는 클래스, 메소드 등을 빠르게 찾을 수 있다.
  




유니티 구현 뜯어보기


C:\Program Files\유니티 버전\Editor\Data\Managed\UnityEngine



  위 경로에 유니티 주요 dll들이 들어있다.
  평소 자주 사용하는 기능들은 주로 UnityEngine.CoreModu...
    </summary>
  

  </entry>

  
  <entry>
    <title>텍스트 메쉬 프로(TMPro) 사용하기</title>
    <link href="https://rito15.github.io/posts/textmeshpro-usage/" rel="alternate" type="text/html" title="텍스트 메쉬 프로(TMPro) 사용하기" />
    <published>2021-02-12T02:09:00+09:00</published>
  
    <updated>2021-02-12T02:09:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/textmeshpro-usage/</id>
    <content src="https://rito15.github.io/posts/textmeshpro-usage/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      특징


  
    SDF(Signed Distance Field)를 이용하여 UGUI 텍스트보다 외곽선을 더 깔끔하게 표현한다.
  
  
    마테리얼을 이용하여 다양한 효과를 줄 수 있다.
  
  
    UGUI 텍스트에 비해 성능이 좋다.
  
  
    미리 고해상도의 Font Texture Atlas를 생성하여 사용하기 때문에 실시간으로 크기가 변경되어도 픽셀을 부드럽게 나타낼 수 있다.
  




폰트 애셋 생성하기


1. 필요 리소스 임포트


  [Window] - [TextMeshPro] - [Import Essential Resources] - [Import]




2. 폰트 준비


  
    한글을 지원하는 폰트 파일(.ttf)을 유니티 프로젝트로 가져온다.
  ...
    </summary>
  

  </entry>

  
  <entry>
    <title>OpenGL 공부 - 15 - View Projection Matrix</title>
    <link href="https://rito15.github.io/posts/opengl-study-15/" rel="alternate" type="text/html" title="OpenGL 공부 - 15 - View Projection Matrix" />
    <published>2021-02-11T17:05:00+09:00</published>
  
    <updated>2021-02-12T05:31:38+09:00</updated>
  
    <id>https://rito15.github.io/posts/opengl-study-15/</id>
    <content src="https://rito15.github.io/posts/opengl-study-15/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="OpenGL" />
    
    <category term="OpenGL Study" />
    
  

  
    <summary>
      





      목표


  View, Projection 행렬 만들고 적용하기




공간 변환




공간 변환 과정을 간단히 설명하면 다음과 같다.

1. Model Transformation


  Model -&amp;gt; World


모델링의 피벗이 원점인 Local Space(Model Space 또는 Object Space)에 Model Matrix를 곱하면 월드의 특정 좌표가 원점인 World Space의 좌표로 변환된다.



2. View Transformation


  World -&amp;gt; View


카메라의 위치, 방향을 정의한 뒤 World Space에 View Matrix를 곱해주면 View Space로 변환된다.

View Space에서는 카메라의 좌표가 원점이며, 카메라를 통해 공간을 바...
    </summary>
  

  </entry>

  
  <entry>
    <title>OpenGL 공부 - 14</title>
    <link href="https://rito15.github.io/posts/opengl-study-14/" rel="alternate" type="text/html" title="OpenGL 공부 - 14" />
    <published>2021-02-10T15:20:00+09:00</published>
  
    <updated>2021-02-10T15:20:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/opengl-study-14/</id>
    <content src="https://rito15.github.io/posts/opengl-study-14/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="OpenGL" />
    
    <category term="OpenGL Study" />
    
  

  
    <summary>
      





      목표


  Model Matrix에 대한 이해
  이동, 회전, 크기 변경




공부 내용


공통

glm의 모델 매트릭스를 선언하는 것으로 시작한다.

glm::mat modelMatrix(1.0f);


openGL의 Transformation은 기본적으로 4x4 행렬과 vec3로 이루어진다.

4x4 행렬과 곱해지려면 벡터 또한 vec4여야 하므로, vec3를 전달하면 내부적으로 vec4(vec3, 1.)을 만들어 연산한다.

변환행렬은 서로 곱하여 하나의 변환행렬로 사용할 수 있다.

그런데 만약 이동행렬 뒤에 크기행렬을 곱하면 이동값 또한 크기가 변하기 때문에

이동, 회전, 크기 행렬을 곱하여 사용할 때는 크기, 회전, 이동 순서로 행렬을 곱하여 사용한다.



크기(Scale)



...
    </summary>
  

  </entry>

</feed>





<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-06-12T04:08:59+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Singleton Pattern(싱글톤 패턴)</title>
    <link href="https://rito15.github.io/posts/singleton-pattern/" rel="alternate" type="text/html" title="Singleton Pattern(싱글톤 패턴)" />
    <published>2021-06-11T17:17:00+09:00</published>
  
    <updated>2021-06-11T17:17:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/singleton-pattern/</id>
    <content src="https://rito15.github.io/posts/singleton-pattern/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Algorithm" />
    
    <category term="Design Pattern" />
    
  

  
    <summary>
      





      Singleton Pattern


특징

  정적 참조로부터 인스턴스 참조를 가져올 수 있다.
  특정 클래스에 단 한 개의 객체만 존재하도록 보장할 수 있다.


사용처

  프로그램 내에 반드시 하나만 존재해야 하는 클래스


고려사항

  싱글톤 객체 생성 타이밍을 고려해야 한다. (정적 or 동적)
  기본적으로 스레드 안전하지 않으므로, 추가적인 처리가 필요하다.




싱글톤 인스턴스를 통한 호출(공통)

class SingletonTest
{
    public static void Method()
    {
        // 클래스명.Instance.멤버참조
        SingletonClass.Instance.Method();
    }
}




Source Code


[1]...
    </summary>
  

  </entry>

  
  <entry>
    <title>마우스 커서가 UI 위에 있는지 검사하는 간단한 코드</title>
    <link href="https://rito15.github.io/posts/unity-check-cursor-over-ui/" rel="alternate" type="text/html" title="마우스 커서가 UI 위에 있는지 검사하는 간단한 코드" />
    <published>2021-06-10T02:22:00+09:00</published>
  
    <updated>2021-06-10T02:22:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-check-cursor-over-ui/</id>
    <content src="https://rito15.github.io/posts/unity-check-cursor-over-ui/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      private static bool IsPointerOverUI()
    =&amp;gt; UnityEngine.EventSystems.EventSystem.current.IsPointerOverGameObject();


    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 이벤트 함수는 어떻게 실행되는 것일까?</title>
    <link href="https://rito15.github.io/posts/unity-event-functions/" rel="alternate" type="text/html" title="유니티 이벤트 함수는 어떻게 실행되는 것일까?" />
    <published>2021-06-06T05:05:00+09:00</published>
  
    <updated>2021-06-06T17:07:01+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-event-functions/</id>
    <content src="https://rito15.github.io/posts/unity-event-functions/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      Unity Event Functions


유니티엔진에서 ‘스크립트’를 작성한다고 하면, 보통 MonoBahaviour를 상속받는 클래스의 스크립트를 작성하는 것을 떠올릴 것이다.

그리고 자연스럽게 이 클래스 내에 Awake(), Start(), Update() 등의 메소드를 작성하게 된다.

심지어 비주얼 스튜디오 같은 개발 환경에서는 이런 메소드들에 대해 자동 완성도 해주고, 메소드 위에는 Unity 메시지라는 글자도 띄워준다.

이런 메소드들은 ‘Unity Event Function’, ‘Unity Message’ 또는 ‘Magic Method’라고 불린다.



그런데 생각해보면 이 메소드들은 MonoBehaviour 또는 그 부모 클래스로부터 상속받은 메소드도 아닌데,

어떻게 유니티가 알아...
    </summary>
  

  </entry>

  
  <entry>
    <title>.NET 환경의 컴파일 과정 - CLR, CIL, JIT, AOT</title>
    <link href="https://rito15.github.io/posts/cs-dotnet-compile/" rel="alternate" type="text/html" title=".NET 환경의 컴파일 과정 - CLR, CIL, JIT, AOT" />
    <published>2021-06-06T04:43:00+09:00</published>
  
    <updated>2021-06-07T23:22:17+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-dotnet-compile/</id>
    <content src="https://rito15.github.io/posts/cs-dotnet-compile/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      .NET 환경의 컴파일 과정


예전의 C, C++의 경우 개별 환경이 프로그램의 실행 시간에 영향을 미치는 문제가 있었다.

하지만 Java가 나오면서 컴파일된 바이트코드는 윈도우, 리눅스, 그 어떤 실행환경이든 JVM만 실행 가능하다면 실행할 수 있다는 장점을 통해 인기를 끌었고,

마이크로소프트는 이를 이용해 기존 문제를 해결할 수 있도록 .NET 환경에 가상 머신을 만들어서

.NET 환경의 언어로 개발된 IL(Intermediate Language, 중간 언어) 코드들은 .NET Framework가 설치된 어떠한 환경에서도 실행할 수 있도록 하였다.

대표적인 예시로 VB .NET, C#이 있다.



CLR(Common Language Runtime, 공통 언어 런타임)은 이 가상머신의 구성...
    </summary>
  

  </entry>

  
  <entry>
    <title>Method Chaining &amp; Generic(메소드 체인 패턴)</title>
    <link href="https://rito15.github.io/posts/method-chaning-pattern/" rel="alternate" type="text/html" title="Method Chaining &amp; Generic(메소드 체인 패턴)" />
    <published>2021-05-28T22:02:00+09:00</published>
  
    <updated>2021-05-30T18:51:30+09:00</updated>
  
    <id>https://rito15.github.io/posts/method-chaning-pattern/</id>
    <content src="https://rito15.github.io/posts/method-chaning-pattern/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Algorithm" />
    
    <category term="Design Pattern" />
    
  

  
    <summary>
      





      메소드 체이닝 패턴


특징

  메소드가 객체를 반환하는 형태로 작성한다.
  문장을 마치지 않고 메소드 호출을 이어나갈 수 있다.
  가독성을 향상시킬 수 있다.




주의사항

  한 문장에 여러번의 메소드 호출이 존재할 수 있으므로, 에러가 발생할 경우 정확한 지점을 한 번에 찾기 힘들다.
  C# 구조체의 메소드를 체이닝으로 구현할 경우, 매 번 구조체 전체의 복제가 발생하므로 바람직하지 않다.




예시

class Box
{
    private float width;
    private float height;

    public Box SetWidth(float width)
    {
        this.width = width;
        return this;
    ...
    </summary>
  

  </entry>

</feed>



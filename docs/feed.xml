

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-03-08T16:33:04+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>컴파일, 게임 시작 시 실행되는 애트리뷰트 정리</title>
    <link href="https://rito15.github.io/posts/unity-memo-init-events/" rel="alternate" type="text/html" title="컴파일, 게임 시작 시 실행되는 애트리뷰트 정리" />
    <published>2021-03-08T03:03:00+09:00</published>
  
    <updated>2021-03-08T03:03:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-memo-init-events/</id>
    <content src="https://rito15.github.io/posts/unity-memo-init-events/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      공통 특징



  
    클래스 또는 메소드 상단에 애트리뷰트를 명시한다.
  
  
    컴포넌트로 넣지 않고, 스크립트로만 존재해도 실행된다.
  
  
    정적 클래스나 상속에 관계 없이 동작한다.
  
  
    메소드 애트리뷰트는 정적 메소드에만 동작한다.
  




컴파일, 플레이모드 진입 시 실행


Note

  EditorApplication.isPlaying으로 현재 에디터 모드를 구분하여 활용할 수 있다.




[InitializeOnLoad]


  
    using UnityEditor;
  
  
    클래스 애트리뷰트
  
  
    정적 생성자가 호출되므로, 정적 생성자에 원하는 코드를 작성한다.
  
  
    실행 타이밍 : 컴파일, 플레이모드 진입...
    </summary>
  

  </entry>

  
  <entry>
    <title>Scene Auto Saver (현재 씬 자동 저장)</title>
    <link href="https://rito15.github.io/posts/unity-toy-scene-auto-saver/" rel="alternate" type="text/html" title="Scene Auto Saver (현재 씬 자동 저장)" />
    <published>2021-03-08T02:22:00+09:00</published>
  
    <updated>2021-03-08T16:31:51+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-toy-scene-auto-saver/</id>
    <content src="https://rito15.github.io/posts/unity-toy-scene-auto-saver/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Toys" />
    
  

  
    <summary>
      





      Note


  
    일정 시간 주기로 현재 활성화된 씬을 자동 저장한다.
  
  
    씬이 저장되지 않은 상태일 때만 타이머가 동작한다.
  


How To Use


  스크립트 2개를 모두 다운받아 유니티 프로젝트에 넣는다.
  
    [Window] - [Rito] - [Scene Auto Saver]를 통해 윈도우를 연다.
  
  On에 체크 해제되어 있을 경우, 체크한다.
  Show Log 옵션으로 자동 저장 시 로그 출력 여부를 설정할 수 있다.
  Save Cycle 옵션으로 저장 주기를 설정할 수 있다. (기본 : 10초, 최소 : 5초)




Preview




Download


  Scene Auto Saver.zip


Source Code


  https:...
    </summary>
  

  </entry>

  
  <entry>
    <title>커스텀 에디터 윈도우</title>
    <link href="https://rito15.github.io/posts/unity-memo-custom-editor-window/" rel="alternate" type="text/html" title="커스텀 에디터 윈도우" />
    <published>2021-03-08T00:00:00+09:00</published>
  
    <updated>2021-03-08T00:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-memo-custom-editor-window/</id>
    <content src="https://rito15.github.io/posts/unity-memo-custom-editor-window/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      Note


  에디터 윈도우를 직접 만들어 사용할 수 있다.


Preview






Source Code Example


#if UNITY_EDITOR

using UnityEngine;
using UnityEditor;

public class ExampleWindow : EditorWindow
{
    private bool boolValue;
    private float floatValue;
    private Vector3 vector3Value;

    [MenuItem("Window/Rito/Example Window")] // 메뉴 등록
    private static void Init()
    {
        // 현재 활성화된 윈도우 가져오며, 없으면 새로 생성
...
    </summary>
  

  </entry>

  
  <entry>
    <title>bool 타입 필드를 인스펙터에서 버튼처럼 사용하기</title>
    <link href="https://rito15.github.io/posts/unity-memo-bool-as-a-button/" rel="alternate" type="text/html" title="bool 타입 필드를 인스펙터에서 버튼처럼 사용하기" />
    <published>2021-03-07T01:33:00+09:00</published>
  
    <updated>2021-03-08T03:55:02+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-memo-bool-as-a-button/</id>
    <content src="https://rito15.github.io/posts/unity-memo-bool-as-a-button/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Memo" />
    
  

  
    <summary>
      





      인스펙터의 버튼


컴포넌트의 인스펙터에서 버튼을 사용하고 싶을 때가 있다.

예를 들면 플레이 모드로 진입하지 않고 에디터 모드에서 메소드를 바로 호출 하고 싶을 때.

그리고 실제로 커스텀 에디터를 이용해 버튼을 만들 수도 있다.



하지만 잠깐 테스트용으로 쓰려는데 스크립트 하나 더 만들고, 커스텀 에디터 선언하고, …

심지어 에디터 GUI좀 쓰려면 EditorGUI, EditorUtility, EditorGUILayout, GUIUtility, GUILayout, … 뭐가 이렇게 다양하고 헷갈리게 만들어 놨는지..

어쨌든 커스텀 에디터 만들어서 if(GUILayout.Button()){} 으로 버튼 하나 달아서 사용할 수 있지만,

가끔씩 이게 참 번거롭다.



bool 필드를 버튼처럼 ...
    </summary>
  

  </entry>

  
  <entry>
    <title>UniRx (Reactive Extensions for Unity)</title>
    <link href="https://rito15.github.io/posts/unity-study-unirx/" rel="alternate" type="text/html" title="UniRx (Reactive Extensions for Unity)" />
    <published>2021-03-06T20:14:00+09:00</published>
  
    <updated>2021-03-08T03:55:02+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-study-unirx/</id>
    <content src="https://rito15.github.io/posts/unity-study-unirx/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Study" />
    
  

  
    <summary>
      





      개요


Rx란?


  Reactive Extensions
  .NET에도 다양한 언어로 구현되어 있다.
  절차적 프로그래밍에서 다루기 쉽지 않은 비동기 프로그래밍을 손쉽게 다루기 위한 패러다임
  비동기 데이터 스트림을 중심으로 동작한다.
  스트림 내의 데이터에 변화가 발생했을 때 반응형으로 기능이 동작하는 방식을 사용한다.
  Observer Pattern + Iterator Pattern + Functional Programming




UniRx

  .NET의 Rx를 유니티에서 사용할 수 없다는 한계를 극복하기 위해 만들어졌다.
  유니티의 코루틴, 주요 이벤트 함수, UGUI 등과 상호작용하기 편하게 구현되어 있다.


using UniRx;
using UniRx.Triggers;

...
    </summary>
  

  </entry>

</feed>





<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-03-30T01:23:41+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Static Readonly vs. Const</title>
    <link href="https://rito15.github.io/posts/memo-cs-static-readonly-vs-const/" rel="alternate" type="text/html" title="Static Readonly vs. Const" />
    <published>2021-03-30T00:50:00+09:00</published>
  
    <updated>2021-03-30T00:50:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/memo-cs-static-readonly-vs-const/</id>
    <content src="https://rito15.github.io/posts/memo-cs-static-readonly-vs-const/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Memo" />
    
    <category term="Csharp Memo" />
    
  

  
    <summary>
      





      공통점


  런타임에 값을 변경할 수 없다.




차이점


Static Readonly


  
    필드 선언문 또는 정적 생성자에서만 값을 초기화할 수 있다.
  
  
    값을 초기화하지 않으면 해당 타입의 기본값으로 초기화된다.
  
  
    런타임 초기에 값이 고정된다.
  
  
    값이 정해지면 변하지 않지만, 결국 변수이기 때문에 참조 오버헤드가 발생한다.
  




Const


  
    필드 선언문에서만 값을 초기화할 수 있다.
  
  
    값을 초기화해야만 한다.
  
  
    컴파일 타임에 값이 고정된다.
  
  
    리터럴처럼 사용될 수 있다.(예 : switch문의 case 값)
  
  
    어셈블리가 나뉘었을 때(const 필드가 존...
    </summary>
  

  </entry>

  
  <entry>
    <title>Voxel System(유니티에서 마인크래프트 구현하기)</title>
    <link href="https://rito15.github.io/posts/unity-study-voxel/" rel="alternate" type="text/html" title="Voxel System(유니티에서 마인크래프트 구현하기)" />
    <published>2021-03-26T20:40:00+09:00</published>
  
    <updated>2021-03-29T22:55:18+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-study-voxel/</id>
    <content src="https://rito15.github.io/posts/unity-study-voxel/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Study" />
    
  

  
    <summary>
      





      목차


  목표
  1. 복셀 기본
  2. 청크와 맵 데이터
  3. 텍스쳐 입히기
  4. 월드에서 청크 생성 및 관리하기
  




목표



  유튜브 강좌를 따라가며 구현한다.




유니티엔진에서 마인크래프트와 같은 복셀 시스템을 구현한다.

모든 맵과 사물은 큐브 형태를 띠고 있으며, 생성하거나 파괴할 수 있다.

각각의 큐브를 개별 오브젝트로 렌더링할 경우 부하가 굉장히 크기 때문에,

일정 영역의 큐브들을 모아 하나의 청크(Chunk)이자 하나의 메시로 관리하는 것이 핵심이다.



1. 복셀 기본


큐브의 정점 데이터 정의


  복셀 시스템에서 사용하기 위해, 육면체 내에서 각 정점들의 인덱스 순서와 상대 위치를 미리 약속된 값으로 정의한다.






LUT(LookUp Ta...
    </summary>
  

  </entry>

  
  <entry>
    <title>Prime Number(소수)</title>
    <link href="https://rito15.github.io/posts/memo-cs-prime-number/" rel="alternate" type="text/html" title="Prime Number(소수)" />
    <published>2021-03-26T18:12:00+09:00</published>
  
    <updated>2021-03-26T18:12:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/memo-cs-prime-number/</id>
    <content src="https://rito15.github.io/posts/memo-cs-prime-number/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Memo" />
    
    <category term="Csharp Memo" />
    
  

  
    <summary>
      





      Memo


1. 소수인지 확인하기

/// &amp;lt;summary&amp;gt; 지정한 수가 소수인지 확인 &amp;lt;/summary&amp;gt;
public static bool IsPrime(int value)
{
    bool isEvenNumber = (value % 2) == 0;

    // 짝수일 경우 2만 소수
    if (isEvenNumber) return value == 2;

    // 1은 소수 아님
    if (value == 1) return false;

    // 제곱근까지만 확인
    int sqrtNum = (int)Math.Sqrt(value);

    // 제곱근보다 작은 홀수들을 순회하여, 약수가 존재하면 소수가 아님
    for (int i = 3; i &amp;lt;...
    </summary>
  

  </entry>

  
  <entry>
    <title>Cloaking(Refraction)</title>
    <link href="https://rito15.github.io/posts/unity-urp-sg-cloaking/" rel="alternate" type="text/html" title="Cloaking(Refraction)" />
    <published>2021-03-25T20:40:00+09:00</published>
  
    <updated>2021-03-25T20:40:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-urp-sg-cloaking/</id>
    <content src="https://rito15.github.io/posts/unity-urp-sg-cloaking/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="URP Shader Graph" />
    
  

  
    <summary>
      





      Summary



  
    뒤의 풍경을 왜곡시켜 보여주는 클로킹 쉐이더
  
  
    Render Pipeline Asset에서 Opaque Texture에 체크해야 한다.
  
  
    Opaque Texture를 사용할 때는 쉐이더그래프의 마스터 노드 Surface를 Transparent로 설정해야 한다.
  


Preview






Options



  
    
      프로퍼티
      설명
    
  
  
    
      Normal Map
      노멀맵 텍스쳐(없을 경우 기본 노멀 벡터 사용)
    
    
      Refraction
      왜곡 강도
    
    
      Fresnel Color
      프레넬 색상
    
    
...
    </summary>
  

  </entry>

  
  <entry>
    <title>노멀맵에서 노멀 벡터 추출하기</title>
    <link href="https://rito15.github.io/posts/unity-urp-sg-memo-normal-map/" rel="alternate" type="text/html" title="노멀맵에서 노멀 벡터 추출하기" />
    <published>2021-03-25T17:00:00+09:00</published>
  
    <updated>2021-03-25T17:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-urp-sg-memo-normal-map/</id>
    <content src="https://rito15.github.io/posts/unity-urp-sg-memo-normal-map/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity Shader" />
    
    <category term="URP Shader Graph Memo" />
    
  

  
    <summary>
      





      Memo



  
    Tangent, Bitangent, Normal Vector로 이루어진 3x3 행렬과 샘플링된 노멀맵 벡터를 곱해줌으로써, 노멀맵으로부터 노멀 벡터를 추출하여 사용할 수 있다.
  
  
    행렬을 만들 때 행벡터를 조립하여 만들지, 열벡터를 조립하여 만들지 여부에 주의해야 한다.
  
  
    행렬과 벡터를 곱할 때 벡터가 앞에 나오면 행벡터, 뒤에 나오면 열벡터로 사용됨에 주의해야 한다.
  
  
    T, B, N 벡터의 공간을 반드시 일치시켜줘야 한다.
  
  
    각 벡터들의 공간은 노멀맵의 사용 대상에 따라 달라진다.
    
      예 : 월드 라이팅 연산을 할 때는 World Space
    
  








References


  ...
    </summary>
  

  </entry>

</feed>



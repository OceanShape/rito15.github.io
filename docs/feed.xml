

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-09-04T20:47:04+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>유니티 - 폴더 애셋으로부터 폴더 전체 경로 구하기</title>
    <link href="https://rito15.github.io/posts/unity-find-folder-path-from-folder-asset/" rel="alternate" type="text/html" title="유니티 - 폴더 애셋으로부터 폴더 전체 경로 구하기" />
    <published>2021-09-04T19:59:00+09:00</published>
  
    <updated>2021-09-04T19:59:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-find-folder-path-from-folder-asset/</id>
    <content src="https://rito15.github.io/posts/unity-find-folder-path-from-folder-asset/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor Memo" />
    
  

  
    <summary>
      





      1. 삽질



   
…


  아무 생각 없이 재귀로 폴더도 찾고, 메타 파일도 찾고, Regex로 guid도 찾고…

  정신 차려보니 아래와 같은 소스 코드를 짜고 있었다.

  /// &amp;lt;summary&amp;gt; 지정한 폴더 애셋의 전체 경로 찾기 &amp;lt;/summary&amp;gt;
private string FindFolderAssetFullPath(DefaultAsset folderAsset)
{
    // Note: Assets 디렉토리로부터 하위 폴더 전부 순회하며 폴더 이름 일치하는 경로 탐색

    DirectoryInfo rootDirectory = Directory.CreateDirectory(Application.dataPath);
    string found = null;

...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# 하위 폴더, 파일의 전체 경로 찾기</title>
    <link href="https://rito15.github.io/posts/cs-memo-find-internal-path/" rel="alternate" type="text/html" title="C# 하위 폴더, 파일의 전체 경로 찾기" />
    <published>2021-09-04T19:45:00+09:00</published>
  
    <updated>2021-09-04T19:45:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-memo-find-internal-path/</id>
    <content src="https://rito15.github.io/posts/cs-memo-find-internal-path/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      Summary


  재귀를 이용하여 특정 폴더 하위 경로에 있는 파일, 폴더 전체 경로 찾기




Source Code


Usage

string folder = FindFolderFullPath(@"c:\MyFolder", "FolderName");
string file = FindFileFullPath(@"c:\MyFolder", "FileName.txt");




Code

/// &amp;lt;summary&amp;gt; 특정 폴더의 모든 하위 경로에서 이름이 일치하는 폴더 경로 찾기 &amp;lt;/summary&amp;gt;
private string FindFolderFullPath(string rootFolderPath, string folderName)
{
    DirectoryInfo rootDirect...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# 비동기 Task를 사용하면서 흔히 발생하는 실수</title>
    <link href="https://rito15.github.io/posts/cs-async-task-mistakes/" rel="alternate" type="text/html" title="C# 비동기 Task를 사용하면서 흔히 발생하는 실수" />
    <published>2021-09-04T04:09:00+09:00</published>
  
    <updated>2021-09-04T04:09:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-async-task-mistakes/</id>
    <content src="https://rito15.github.io/posts/cs-async-task-mistakes/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Threading" />
    
  

  
    <summary>
      





      Mistake


private static void Main()
{
    Task t = Task.Run(() =&amp;gt; TaskBody(3));

    t.Wait(); // TaskBody(3)의 종료를 대기하려고 시도

    Console.WriteLine("End");
}

static async void TaskBody(int count)
{
    for (int i = 0; i &amp;lt; count; i++)
    {
        await Task.Delay(500);
        Console.WriteLine($"[{i}] Thread : {Thread.CurrentThread.ManagedThreadId}");
    }
}


위의 소스 코드는 얼핏 보면 문제가 없어 보...
    </summary>
  

  </entry>

  
  <entry>
    <title>동적 계획법(Dynamic Programming, DP)</title>
    <link href="https://rito15.github.io/posts/dynamic-programming/" rel="alternate" type="text/html" title="동적 계획법(Dynamic Programming, DP)" />
    <published>2021-09-02T16:40:00+09:00</published>
  
    <updated>2021-09-02T16:40:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/dynamic-programming/</id>
    <content src="https://rito15.github.io/posts/dynamic-programming/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Algorithm" />
    
    <category term="Algorithms" />
    
  

  
    <summary>
      





      개념


동적 계획법

문제를 여러 개의 하위 문제들로 나누어 해결 및 기록한 뒤

이를 이용해 최종적인 문제를 해결해나가는 방법.



다시 말해,

문제 해결 과정을 메모리에 기록하고 이를 바탕으로 이후의 문제를 해결해나가는 방법이다.

한 번 기록한 적이 있다면 다시 계산할 필요 없이 곧바로 답을 도출해낼 수 있다.



메모이제이션(Memoization)

동적 계획법의 핵심 개념.

하위 문제의 답을 구한 뒤 메모리에 저장하는 것을 의미한다.

이렇게 저장된 값은 동일한 하위 문제의 결과값이 필요할 때 재계산 없이 곧바로 사용될 수 있다.



예제 - 피보나치



  동적 계획법의 기초 예제로 많이 볼 수 있는 피보나치.


Fibonacci(0) = 0
Fibonacci(1) = 1
Fi...
    </summary>
  

  </entry>

  
  <entry>
    <title>C# Foreach 구문 심층 파헤치기</title>
    <link href="https://rito15.github.io/posts/cs-grammar-foreach/" rel="alternate" type="text/html" title="C# Foreach 구문 심층 파헤치기" />
    <published>2021-09-02T16:00:00+09:00</published>
  
    <updated>2021-09-03T14:25:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-grammar-foreach/</id>
    <content src="https://rito15.github.io/posts/cs-grammar-foreach/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Grammar" />
    
  

  
    <summary>
      





      Foreach 구문



  컬렉션의 요소를 간편히 순차 탐색할 수 있는 구문


List&amp;lt;int&amp;gt; list = new List&amp;lt;int&amp;gt;();

foreach (int item in list)
{
    Console.WriteLine(item);
}




Foreach 구문이 실제로 생성하는 코드?



  위의 소스 코드는 실제로 다음과 같은 코드를 생성한다고 한다.


List&amp;lt;int&amp;gt; list = new List&amp;lt;int&amp;gt;();

List&amp;lt;int&amp;gt;.Enumerator enumerator = list.GetEnumerator();
while (enumerator.MoveNext())
{
    int item = enumerator.Curren...
    </summary>
  

  </entry>

</feed>



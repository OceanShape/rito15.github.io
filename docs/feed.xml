

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-04-14T23:15:01+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Quick Sort(빠른 정렬)</title>
    <link href="https://rito15.github.io/posts/algorithm-quick-sort/" rel="alternate" type="text/html" title="Quick Sort(빠른 정렬)" />
    <published>2021-04-07T22:00:00+09:00</published>
  
    <updated>2021-04-07T22:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/algorithm-quick-sort/</id>
    <content src="https://rito15.github.io/posts/algorithm-quick-sort/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Algorithm" />
    
    <category term="Sort Algorithm" />
    
  

  
    <summary>
      





      Summary



  
    
      시간복잡도
      평균 \(O(n log n)\), 최악 \(O(n^2)\)
    
    
      공간복잡도
      \(O(n)\)
    
    
      정렬 특징
      불안정 정렬
    
  


특징

  분할 정복
  재귀




Details


메소드 구성

QuickSort(arr, left, right)

  배열의 left ~ right 인덱스 내에서만 정렬을 수행한다.


Partition(arr, left, right)

  배열의 left ~ right 인덱스 내에서 피벗을 선정한다.
  내부적으로 정렬을 수행하고, 피벗의 인덱스를 리턴한다.




정렬 과정

[1] QuickSort(arr, 0, arr.L...
    </summary>
  

  </entry>

  
  <entry>
    <title>O(logn) 거듭제곱 알고리즘</title>
    <link href="https://rito15.github.io/posts/algorithm-pow/" rel="alternate" type="text/html" title="O(logn) 거듭제곱 알고리즘" />
    <published>2021-04-06T18:00:00+09:00</published>
  
    <updated>2021-04-06T18:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/algorithm-pow/</id>
    <content src="https://rito15.github.io/posts/algorithm-pow/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Algorithm" />
    
  

  
    <summary>
      





      Summary



  
    일반적으로 \(O(n)\) 시간복잡도로 수행하는 거듭제곱 계산을 \(O(log_{2}n)\) 의 시간복잡도로 수행할 수 있는 알고리즘
  
  
    2진수 연산을 이용한다.
  




Details


\(a^n\)을 계산하는 가장 쉬운 방법은 \(a\)를 \(n\) 번 곱하는 것이다.

예를 들어 \(4^9\)을 구하려면 \(4 \cdot 4 \cdot 4 \cdot 4 \cdot 4 \cdot 4 \cdot 4 \cdot 4 \cdot 4\)를 계산하면 된다.

하지만 이렇게 되면 \(n - 1\) 번의 곱셈을 수행하므로 시간복잡도는 \(O(n)\)에 해당한다.



거듭제곱의 특징은 같은 숫자(밑)을 연달아 곱한다는 것이다.

이때 지수를 살펴보면 곱셈이 아닌...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티의 멀티스레딩과 Job의 활용</title>
    <link href="https://rito15.github.io/posts/unity-study-multithread-job/" rel="alternate" type="text/html" title="유니티의 멀티스레딩과 Job의 활용" />
    <published>2021-04-04T22:00:00+09:00</published>
  
    <updated>2021-04-04T22:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-study-multithread-job/</id>
    <content src="https://rito15.github.io/posts/unity-study-multithread-job/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Study" />
    
  

  
    <summary>
      





      유니티에서의 멀티스레딩

유니티엔진에서는 기본적으로 모든 CPU 연산이 메인 스레드에서 이루어진다.

그렇다고 다중 스레드를 사용할 수 없다는 것은 아니지만

메인 스레드가 아닌 다른 스레드에서 유니티의 메인 로직에 접근할 수 없도록 막혀있다.

다시 말해, 다른 스레드에서는 게임오브젝트, 컴포넌트 등에 접근하면 에러가 발생한다.

예를 들어

private async void TaskTest()
{
    await Task.Run(() =&amp;gt;
    {
        transform.Translate(1f, 0f, 0f);
    });
}


이런 메소드를 실행하면



이런 에러를 만날 수 있다.



따라서 다른 스레드에서 유니티 메인 로직에 접근해야 한다면 MainThreadDispat...
    </summary>
  

  </entry>

  
  <entry>
    <title>파티클 시스템 예제 - 11 - Sword Effect</title>
    <link href="https://rito15.github.io/posts/unity-particle-system-example-11-sword-effect/" rel="alternate" type="text/html" title="파티클 시스템 예제 - 11 - Sword Effect" />
    <published>2021-03-30T23:23:00+09:00</published>
  
    <updated>2021-03-30T23:23:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-particle-system-example-11-sword-effect/</id>
    <content src="https://rito15.github.io/posts/unity-particle-system-example-11-sword-effect/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Particle System" />
    
  

  
    <summary>
      





      목차



  목표
  준비물
  1. 하이라키 구성
  2. Glow 이펙트
  3. Sparkle 이펙트
  4. Aura 이펙트
  5. 결과




Preview






목표



  검 모델링에 부착하여 사용할 수 있는 이펙트(무기 강화 이펙트) 만들기




준비물



  검 모델링
    
      https://assetstore.unity.com/packages/3d/props/weapons/free-low-poly-swords-189978
    
  





  Sparkle, PointGlow 텍스쳐를 사용하는 Additive 마테리얼
    
      Sparkle_PointGlow.zip
    
  




1. 하이라키 구성


위의 검 모델링 무료 애셋을 사용하...
    </summary>
  

  </entry>

  
  <entry>
    <title>Static Readonly vs. Const</title>
    <link href="https://rito15.github.io/posts/memo-cs-static-readonly-vs-const/" rel="alternate" type="text/html" title="Static Readonly vs. Const" />
    <published>2021-03-30T00:50:00+09:00</published>
  
    <updated>2021-03-30T00:50:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/memo-cs-static-readonly-vs-const/</id>
    <content src="https://rito15.github.io/posts/memo-cs-static-readonly-vs-const/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Memo" />
    
    <category term="Csharp Memo" />
    
  

  
    <summary>
      





      공통점


  런타임에 값을 변경할 수 없다.




차이점


Static Readonly


  
    필드 선언문 또는 정적 생성자에서만 값을 초기화할 수 있다.
  
  
    값을 초기화하지 않으면 해당 타입의 기본값으로 초기화된다.
  
  
    런타임 초기에 값이 고정된다.
  
  
    값이 정해지면 변하지 않지만, 결국 변수이기 때문에 참조 오버헤드가 발생한다.
  




Const


  
    필드 선언문에서만 값을 초기화할 수 있다.
  
  
    값을 초기화해야만 한다.
  
  
    컴파일 타임에 값이 고정된다.
  
  
    리터럴처럼 사용될 수 있다.(예 : switch문의 case 값)
  
  
    어셈블리가 나뉘었을 때(const 필드가 존...
    </summary>
  

  </entry>

</feed>





<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://rito15.github.io/</id>
  <title>Rito15</title>
  <subtitle>Unity Csharp Developer</subtitle>
  <updated>2021-08-25T05:02:26+09:00</updated>
  <author>
    <name>Rito15</name>
    <uri>https://rito15.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://rito15.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://rito15.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 Rito15 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>유니티 에디터 GUI - 여러 개의 커브를 겹쳐 그리기</title>
    <link href="https://rito15.github.io/posts/unity-editor-draw-multiple-curves/" rel="alternate" type="text/html" title="유니티 에디터 GUI - 여러 개의 커브를 겹쳐 그리기" />
    <published>2021-08-25T03:00:00+09:00</published>
  
    <updated>2021-08-25T03:00:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-editor-draw-multiple-curves/</id>
    <content src="https://rito15.github.io/posts/unity-editor-draw-multiple-curves/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor Memo" />
    
  

  
    <summary>
      





      Note


EditorGUI.CurveField()를 통해 AnimationCurve를 에디터에 그릴 수 있다.

그런데 일반적인 방법으로는 하나의 커브 필드에 하나의 커브만 그려진다.

커브 필드에는 불투명한 배경 색상이 존재하기 때문이다.


  (0.337f, 0.337f, 0.337f, 1f)






따라서 이를 해결하기 위해서는, 리플렉션을 이용한 편법을 사용해야 한다.

private static FieldInfo fiCurveBGColor;
private static Color defaultCurveBGColor;

private void DrawSomeCurveField()
{
    // 리플렉션을 통해 배경 색상 필드 정보 참조
    if (fiCurveBGColor == nu...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 에디터의 특정 영역 마우스 클릭 방지하기</title>
    <link href="https://rito15.github.io/posts/unity-editor-block-mouse-click/" rel="alternate" type="text/html" title="유니티 에디터의 특정 영역 마우스 클릭 방지하기" />
    <published>2021-08-25T02:59:00+09:00</published>
  
    <updated>2021-08-25T02:59:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-editor-block-mouse-click/</id>
    <content src="https://rito15.github.io/posts/unity-editor-block-mouse-click/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor Memo" />
    
  

  
    <summary>
      





      Memo


Rect rect = ....; // 마우스 클릭 방지할 영역

if (rect.Contains(Event.current.mousePosition))
{
    if(Event.current.type == EventType.MouseDown)
        Event.current.Use();
}

// 이후 해당 영역에서의 모든 마우스 클릭은 무시(Button, Value Fields, ...)



  위의 방식을 이용해서, 컨트롤의 색상을 변경시키지 않는 DisabledGroup을 구현할 수 있다.


    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 에디터 스크립팅 - 버전 호환 시 고려사항들</title>
    <link href="https://rito15.github.io/posts/unity-editor-scripting-version-compatability/" rel="alternate" type="text/html" title="유니티 에디터 스크립팅 - 버전 호환 시 고려사항들" />
    <published>2021-08-23T20:00:00+09:00</published>
  
    <updated>2021-08-24T23:48:29+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-editor-scripting-version-compatability/</id>
    <content src="https://rito15.github.io/posts/unity-editor-scripting-version-compatability/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor" />
    
  

  
    <summary>
      





      EditorGUILayout.Space(float)



   
.


  
    
      2019.3 미만의 버전에서는 .Space()만 존재하고 .Space(float)가 존재하지 않는다.
    
    
      따라서 .Space()를 통해서는 높이 8의 고정된 여백만 넣을 수 있다.
    
    
      이에 대응하기 위해서는 다음과 같이 사용하면 된다.
    
  

  private static void Space(float height)
{
#if UNITY_2019_3_OR_NEWER
    EditorGUILayout.Space(height);
#else
    GUILayoutUtility.GetRect(1f, height);
#endif
}
  

  
    G...
    </summary>
  

  </entry>

  
  <entry>
    <title>유니티 에디터 다크모드 여부 스크립트로 확인하기</title>
    <link href="https://rito15.github.io/posts/unity-dark-mode-in-script/" rel="alternate" type="text/html" title="유니티 에디터 다크모드 여부 스크립트로 확인하기" />
    <published>2021-08-22T22:48:00+09:00</published>
  
    <updated>2021-08-22T22:48:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/unity-dark-mode-in-script/</id>
    <content src="https://rito15.github.io/posts/unity-dark-mode-in-script/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="Unity" />
    
    <category term="Unity Editor Memo" />
    
  

  
    <summary>
      





      Memo


확인된 버전


  2019.4.9f1




[1] 다크모드 여부 확인

EditorGUIUtility.isProSkin;

// true : 다크모드
// false : 일반모드(Light)




[2] 모드 변경하기

UnityEditorInternal.InternalEditorUtility.SwitchSkinAndRepaintAllViews();


    </summary>
  

  </entry>

  
  <entry>
    <title>(Shorts) C# Foreach가 실제로 생성하는 소스코드</title>
    <link href="https://rito15.github.io/posts/cs-list-foreach-code/" rel="alternate" type="text/html" title="(Shorts) C# Foreach가 실제로 생성하는 소스코드" />
    <published>2021-08-21T17:22:00+09:00</published>
  
    <updated>2021-08-21T17:22:00+09:00</updated>
  
    <id>https://rito15.github.io/posts/cs-list-foreach-code/</id>
    <content src="https://rito15.github.io/posts/cs-list-foreach-code/" />
    <author>
      <name>Rito15</name>
    </author>

  
    
    <category term="C#" />
    
    <category term="C# Memo" />
    
  

  
    <summary>
      





      Memo


Source Code

private List&amp;lt;int&amp;gt; list = new List&amp;lt;int&amp;gt;(10);

foreach (var item in list)
{
    Console.WriteLine(item);
}




Generated Code

private List&amp;lt;int&amp;gt; list = new List&amp;lt;int&amp;gt;(10);

List&amp;lt;int&amp;gt;.Enumerator enumerator = list.GetEnumerator();

while (enumerator.MoveNext())
{
    int item = enumerator.Current;
    Console.WriteLine(item);
}




정리


  .GetEnumera...
    </summary>
  

  </entry>

</feed>



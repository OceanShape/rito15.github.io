[
  
  {
    "title": "OpenGL 공부 - 17 - Ambient, Diffuse Lighting",
    "url": "/posts/opengl-study-17/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-13 15:32:00 +0900",
    





    "snippet": "목표  Ambient, Diffuse 라이팅 구현공부 내용버텍스에 노멀 정보 추가struct Vertex{    glm::vec3 position;    glm::vec3 color;    glm::vec2 texcoord;    glm::vec3 normal;};Vertex vertices[] ={    // Position                    // Color                     // TexCoord            // Normal                                 ..."
  },
  
  {
    "title": "1인칭, 3인칭 전환 가능한 캐릭터 제작하기 [작성 중]",
    "url": "/posts/fps-tps-character/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp, fps, tps, controller",
    "date": "2021-02-12 18:06:00 +0900",
    





    "snippet": "목차            하이라키 구성                  스크립트 기초 작성                  1인칭 이동, 회전                  3인칭 이동, 회전                  카메라 전환                  점프                  애니메이션 적용하기                  부드러운 애니메이션 적용하기 : 블렌딩, 러프                  버그 수정                  카메라 전환 시 시점 방향 공유하기                 ..."
  },
  
  {
    "title": "쿨타임 아이콘 UI 만들기",
    "url": "/posts/cooldown-icon-ui/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp, ui, cooldown",
    "date": "2021-02-12 17:13:00 +0900",
    





    "snippet": "목표구현1. 하이라키 구성[1] Outline  Image 컴포넌트 : 원하는 모양의 스프라이트 사용, 아웃라인으로 지정할 색상 적용[2] Mask  RectTransform : Anchor Preset [stretch &amp;amp; stretch] 설정  Left, Top, Right, Bottom 4픽셀 설정  Image 컴포넌트 : Outline과 같은 스프라이트 사용  Mask 컴포넌트 : [Show Mask Graphic] 체크 해제[3] Icon  RectTransform : Anchor Preset [stret..."
  },
  
  {
    "title": "OpenGL 공부 - 16 - Transform, Input",
    "url": "/posts/opengl-study-16/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-12 15:11:00 +0900",
    





    "snippet": "목표  오브젝트 기본 트랜스폼 정의하기  키보드 입력 처리하기트랜스폼 정의트랜스폼의 3요소(위치, 회전, 크기)를 정의한다.glm::vec3 position(0.0f);glm::vec3 rotation(0.0f);glm::vec3 scale(1.0f);그리고 모델 행렬에 트랜스폼 연산을 모두 넣어준다.modelMatrix = glm::translate(modelMatrix, position);modelMatrix = glm::rotate(modelMatrix, glm::radians(rotation.x), glm::vec3(1..."
  },
  
  {
    "title": "ILSpy로 유니티 내부 구현 뜯어보기",
    "url": "/posts/unity-ilspy/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp, ilspy",
    "date": "2021-02-12 05:32:00 +0900",
    





    "snippet": "다운로드  https://github.com/icsharpcode/ILSpy/releases  vsix를 받을 경우, 비주얼 스튜디오의 확장으로 추가하여 [도구] - [ILSpy]를 통해 바로 실행할 수 있다.사용법      ILSpy를 실행한다.        File - Open으로 대상 어셈블리(dll, exe 등)를 불러온다.        검색을 통해 원하는 클래스, 메소드 등을 빠르게 찾을 수 있다.  유니티 구현 뜯어보기C:\\Program Files\\유니티 버전\\Editor\\Data\\Managed\\UnityEngine..."
  },
  
  {
    "title": "텍스트 메쉬 프로(TMPro) 사용하기",
    "url": "/posts/textmeshpro-usage/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp, ugui, ui, text, textmeshpro",
    "date": "2021-02-12 02:09:00 +0900",
    





    "snippet": "특징      SDF(Signed Distance Field)를 이용하여 UGUI 텍스트보다 외곽선을 더 깔끔하게 표현한다.        마테리얼을 이용하여 다양한 효과를 줄 수 있다.        UGUI 텍스트에 비해 성능이 좋다.        미리 고해상도의 Font Texture Atlas를 생성하여 사용하기 때문에 실시간으로 크기가 변경되어도 픽셀을 부드럽게 나타낼 수 있다.  폰트 애셋 생성하기1. 필요 리소스 임포트  [Window] - [TextMeshPro] - [Import Essential Resources..."
  },
  
  {
    "title": "OpenGL 공부 - 15 - View Projection Matrix",
    "url": "/posts/opengl-study-15/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-11 17:05:00 +0900",
    





    "snippet": "목표  View, Projection 행렬 만들고 적용하기공간 변환공간 변환 과정을 간단히 설명하면 다음과 같다.1. Model Transformation  Model -&amp;gt; World모델링의 피벗이 원점인 Local Space(Model Space 또는 Object Space)에 Model Matrix를 곱하면 월드의 특정 좌표가 원점인 World Space의 좌표로 변환된다.2. View Transformation  World -&amp;gt; View카메라의 위치, 방향을 정의한 뒤 World Space에 Vi..."
  },
  
  {
    "title": "OpenGL 공부 - 14",
    "url": "/posts/opengl-study-14/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-10 15:20:00 +0900",
    





    "snippet": "목표  Model Matrix에 대한 이해  이동, 회전, 크기 변경공부 내용공통glm의 모델 매트릭스를 선언하는 것으로 시작한다.glm::mat modelMatrix(1.0f);openGL의 Transformation은 기본적으로 4x4 행렬과 vec3로 이루어진다.4x4 행렬과 곱해지려면 벡터 또한 vec4여야 하므로, vec3를 전달하면 내부적으로 vec4(vec3, 1.)을 만들어 연산한다.변환행렬은 서로 곱하여 하나의 변환행렬로 사용할 수 있다.그런데 만약 이동행렬 뒤에 크기행렬을 곱하면 이동값 또한 크기가 변하기 때..."
  },
  
  {
    "title": "유니티 에디터 종료 확인 다이얼로그 만들기",
    "url": "/posts/unity-editor-exit-dialog/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, editor, dialog, csharp",
    "date": "2021-02-10 13:50:00 +0900",
    





    "snippet": "Memo기본적으로 유니티 에디터를 종료할 때는 확인창이 뜨지 않고 바로 종료된다.만약 실수로 닫기 버튼을 눌러버린다면 그대로 종료되어 버린다.그런데 유니티 에디터는 에디터의 종료도 이벤트로 구분하여, 메소드를 추가할 수 있도록 구현해놓았기 때문에이를 이용해 에디터의 종료를 시도할 경우 확인창을 띄우도록 할 수 있다.[InitializeOnLoad]public class EditorExitDialog{    static EditorExitDialog()    {        EditorApplication.wantsToQuit ..."
  },
  
  {
    "title": "OpenGL 공부 - 13 - Texture",
    "url": "/posts/opengl-study-13/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-10 01:30:00 +0900",
    





    "snippet": "목표  폴리곤에 텍스쳐 씌워보기(1장, 여러 장)1. 텍스쳐 한 장 사용이미지 준비  프로젝트 디렉토리 내에 Images 폴더를 만들고 PNG 이미지 파일을 준비한다.소스코드 작성  위치 : VertexAttribPointer ~ Main Loop 사이[1] 이미지 로드int imageWidth = 0;int imageHeight = 0;unsigned char* image = SOIL_load_image(&quot;Images/MoonCat.png&quot;,    &amp;amp;imageWidth, &amp;amp;ima..."
  },
  
  {
    "title": "Custom Mouse Events",
    "url": "/posts/unity-custom-mouse-events/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin, mouse",
    "date": "2021-02-08 21:54:00 +0900",
    





    "snippet": "구현 동기유니티 모노비헤이비어는 OnMouse로 시작하는 이벤트 메소드들을 작성하여 사용할 수 있습니다.이 이벤트 메소드들은 레이캐스트 기반으로 동작하며, 해당 마우스 동작이 발생하면 메소드가 호출됩니다.하지만 여러가지 단점들이 있습니다.  마우스 좌클릭에 대해서만 동작합니다.  이벤트 메소드 작성 시, 비워놓거나 해당 이벤트가 발생하지 않는 상황에도 성능을 소모합니다.  컴포넌트를 비활성화하거나, 심지어 게임오브젝트를 비활성화해도 성능을 소모합니다.  마우스가 닿은 정확한 위치를 알 수 없습니다.  대상을 레이어로 필터링할 ..."
  },
  
  {
    "title": "OpenGL 공부 - 12 - New Beginning 3",
    "url": "/posts/opengl-study-12/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-08 16:12:00 +0900",
    





    "snippet": "목표  기본 렌더링 세팅  기본 도형 렌더링공부 내용테스트를 위해 렌더링 옵션들 설정// main.cpp - in main()glEnable(GL_DEPTH_TEST);glEnable(GL_CULL_FACE);glCullFace(GL_BACK);glFrontFace(GL_CCW); // 시계 반대 방향으로 구성된 폴리곤을 전면으로 설정// 픽셀 블렌딩 연산 지정glEnable(GL_BLEND);glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);// GL_LINE : 폴리곤을 선으로 그리기..."
  },
  
  {
    "title": "OpenGL 공부 - 11 - New Beginning 2",
    "url": "/posts/opengl-study-11/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-07 16:12:00 +0900",
    





    "snippet": "목표  프로그램 및 쉐이더 객체 생성  파일에 쉐이더 작성, 불러와 컴파일공부 내용Current Source Codesvertex_core.glsl#version 440layout (location = 0) in vec3 vertex_position;layout (location = 1) in vec3 vertex_color;layout (location = 2) in vec3 vertex_texcoord;out vec3 vs_position;out vec3 vs_color;out vec2 vs_texcoord;void mai..."
  },
  
  {
    "title": "OpenGL 공부 - 10 - New Beginning",
    "url": "/posts/opengl-study-10/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-06 15:20:00 +0900",
    





    "snippet": "목표  다른 강좌로 새롭게 시작  GLM, SOIL2 설치새로운 시작새로운 강좌를 선택한 김에 기존의 파일들을 날려버리고 구조 변경공부 내용GLM ?  OpenGL Mathematics, 수학 라이브러리.  http://glm.g-truc.net/0.9.8/index.html 에서 받을 수 있다.      이제는 익숙하게 Dependencies 폴더에 넣고 GLM 포함경로 설정    libs.h에 아래처럼 추가#include &amp;lt;GLM/glm.hpp&amp;gt;#include &amp;lt;GLM/vec2.hpp&..."
  },
  
  {
    "title": "각종 그래프 모음",
    "url": "/posts/mathematics-graph-compilation/",
    "categories": "Mathematics, Graph",
    "tags": "mathematics, graph",
    "date": "2021-02-06 05:25:00 +0900",
    





    "snippet": "sin xcos xtan xasin xacos xatan xsin(acos x), cos(asin x)asin(cos x)acos(sin x)sin(e^x)cos(e^x)atan(e^x)asin( e^(-x) )e^xe^(1-x)e^(1-x) * x"
  },
  
  {
    "title": "0~1 구간 가속, 감속 그래프 모음",
    "url": "/posts/mathematics-graph-accel_01/",
    "categories": "Mathematics, Graph",
    "tags": "mathematics, graph",
    "date": "2021-02-06 05:25:00 +0900",
    





    "snippet": "1. 가속\\(x^{n}\\) 기본 가속 모델\\(\\sin\\left(\\cos^{-1}\\left(x-1\\right)\\right)\\)\\(x^{2}\\left(3-2x\\right)\\)\\(\\sin\\left(\\pi\\left(x-0.5\\right)\\right)\\cdot0.5+0.5\\)\\(\\sin^{-1}\\left(2x-1\\right)\\cdot\\frac{1}{\\pi}+0.5\\)2. 가속 이후 감속\\(x^{a}\\left(1-x^{b}\\right)c\\)  a &amp;gt; 0  b &amp;gt; 0"
  },
  
  {
    "title": "유니티 투명 쉐이더와 스텐실 개념 익히기 [작성 중]",
    "url": "/posts/unity-transparent-stencil/",
    "categories": "Unity Shader, Shader Study",
    "tags": "unity, csharp, shader, graphics, transparent, alpha, stencil",
    "date": "2021-02-06 01:29:00 +0900",
    





    "snippet": "불투명과 투명불투명(Opaque)과 투명(Transparent) 오브젝트는 그려지는 타이밍도, 그리기 위한 고려사항도 다르다.유니티에서는 오브젝트를 렌더링하는 순서를 렌더 큐(Render Queue)를 통해 정수 값으로 지정하는데, 지정한 값이 작은 순서대로 그리게 되며 기본적으로 Opaque는 2000, Transparent는 3000의 값을 가진다.따라서 불투명 오브젝트가 전부 그려진 후에 투명 오브젝트가 그려진다.Z-buffer카메라로부터 픽셀마다 가장 가까운 오브젝트까지의 거리를 (0.0 ~ 1.0) 값으로 기록해놓는 ..."
  },
  
  {
    "title": "유니티 쉐이더 모음",
    "url": "/posts/unity-shader-compilation/",
    "categories": "Unity Shader, Shader Study",
    "tags": "unity, csharp, shader, graphics, transparent, stencil",
    "date": "2021-02-06 01:25:00 +0900",
    





    "snippet": "Render Depth  단순히 뎁스만 색상으로 보여주는 쉐이더Shader &quot;Render Depth&quot;{    Properties    {        _Multiplier(&quot;Multiplier&quot;, Float) = 50    }    SubShader    {        Tags { &quot;RenderType&quot; = &quot;Opaque&quot; }        Pass         {            CGPROGRAM            #pragma vertex ver..."
  },
  
  {
    "title": "OpenGL 공부 - 09 - uniform, VAO",
    "url": "/posts/opengl-study-09/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-05 15:20:00 +0900",
    





    "snippet": "목표  uniform 변수, VAO에 대한 이해 및 사용1. uniformuniform이란?  OpenGL에서 쉐이더로 전달하는 글로벌 변수쉐이더에서 uniform 변수 선언 및 사용#shader fragment#version 330 corelayout(location = 0) out vec4 color;uniform vec4 u_Color;void main(){	color = u_Color;};  uniform 변수는 기본적으로 u_를 붙여 네이밍한다.OpenGL에서 uniform 변수 선언 및 전달      glGetUni..."
  },
  
  {
    "title": "유니티 스크립트 최적화",
    "url": "/posts/unity-script-optimization/",
    "categories": "Unity, Unity Optimization",
    "tags": "unity, csharp, optimize, optimization, performance",
    "date": "2021-02-04 19:30:00 +0900",
    





    "snippet": "목차  1. GetComponent(), Find() 메소드 사용 줄이기  2. 비어있는 유니티 이벤트 메소드 방치하지 않기  3. 필요하지 않은 경우, new로 생성하지 않기  4. 필요하지 않은 경우, 리턴하지 않기  5. StartCoroutine() 자주 호출하지 않기  6. 코루틴의 yield 캐싱하기  7. 컬렉션 재사용하기  8. StringBuilder 사용하기  9. 구조체 사용하기  10. 빌드 이후 Debug.Log() 사용하지 않기  11. Transform 변경은 한번에  12. LINQ 사용하지 않기 ..."
  },
  
  {
    "title": "유니티 프로파일링을 통한 최적화",
    "url": "/posts/unity-profiling/",
    "categories": "Unity, Unity Optimization",
    "tags": "unity, csharp, profiling, optimization",
    "date": "2021-02-04 19:30:00 +0900",
    





    "snippet": "목차  1. Note  2. Tools  3. Unity Profiler          Custom Profiler Tags      CPU &amp;amp; GPU Boundary      CPU Boundary      GPU Boundary        4. Memory Profiler  5. ReferencesNote  프로파일링은 1차적으로 에디터에서 수행하지만, 타겟 디바이스에서 실제로 실행하며 진행하는 프로파일링이 가장 중요하다.  [Edit - Project Settings - Quliaty - Other]에서..."
  },
  
  {
    "title": "유니티 에디터 프로파일러",
    "url": "/posts/unity-profiler-window/",
    "categories": "Unity, Unity Optimization",
    "tags": "unity, csharp, profiling",
    "date": "2021-02-04 17:50:00 +0900",
    





    "snippet": "목차  1. Unity Profiler  2. CPU Usage          Timeline View      Hierarchy View      Show Related Objects      Call Stack      Show Calls      Deep Profile        3. GPU Usage  4. Rendering  5. MemoryUnity Profiler[Window] - [Analysis] - [Profiler]를 통해 프로파일러 윈도우를 열 수 있다.CPU, GPU(Rendering), Memory..."
  },
  
  {
    "title": "C++ Smart Debugging",
    "url": "/posts/cpp-smart-debugging/",
    "categories": "C++, C++ Memo",
    "tags": "cpp",
    "date": "2021-02-04 16:56:00 +0900",
    





    "snippet": "NoteC++에는 미리 정의된 동적 매크로가 있다.__FILE__  해당 위치의 소스파일 경로를 문자열로 가져온다.__LINE__  해당 위치의 줄 번호를 정수로 가져온다.그리고 매크로의 매개변수를 무조건 스트링으로 변환하여 가져올 수 있는 방법이 존재한다.#define MACRO(x) #x  x에 위치한 코드를 문자열로 변환하여 가져온다.이를 이용하면 해당 소스코드와 실행 위치 정보를 간단히 출력할 수 있다.#include &amp;lt;iostream&amp;gt;using namespace std;#define ShowC..."
  },
  
  {
    "title": "OpenGL 공부 - 08 - Debugging",
    "url": "/posts/opengl-study-08/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-04 15:45:00 +0900",
    





    "snippet": "목표  OpenGL 내에서 디버깅하기공부 내용  OpenGL 내에서 에러가 발생하거나 코드를 잘못 작성한 경우, 친절한 에러 메시지보다는 그저 검은 화면을 볼 가능성이 높다.  그래서 디버깅을 하려면, OpenGL에서 제공하는 몇몇 메소드와 매크로를 활용해야 한다.      glGetError          에러가 발생한 경우 에러 플래그를 리턴한다.                  return GLenum      에러 플래그 - GL_NO_ERROR - GL_INVALID_ENUM - GL_INVALID_VALUE - GL..."
  },
  
  {
    "title": "OpenGL 공부 - 07 - Index Buffer",
    "url": "/posts/opengl-study-07/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-03 16:32:00 +0900",
    





    "snippet": "목표  인덱스 버퍼의 사용과 이해공부 내용삼각형 그리기  삼각형을 하나 그리려면, 버텍스 3개가 필요하다.float positions[6] ={    -0.5f, -0.5f,     0.0f,  0.5f,     0.5f, -0.5f,};  GPU는 전달받은 버텍스들을 순서대로 확인하여 3개씩 짝지어서 하나의 폴리곤을 그려준다.  이 때, 3개의 버텍스가 순서대로 시계 반대 방향으로 위치해야 폴리곤의 전면이 그려진다.사각형 그리기  사각형을 하나 그리려면 삼각형이 2개 필요하므로, 결국 버텍스 6개가 필요하다.      그런데..."
  },
  
  {
    "title": "인스펙터에 오토 프로퍼티 표시하기",
    "url": "/posts/show-property-on-inspector/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp, property",
    "date": "2021-02-02 17:08:00 +0900",
    





    "snippet": "Memopublic GameObject Property1 =&amp;gt; Field1;private GameObject Field1;이렇게 다른 필드와 연결된 프로퍼티라면public GameObject Property1 =&amp;gt; field1;[SerializeField]private GameObject field1;대상 필드에 [SerializeField]를 붙여서 인스펙터에 표시할 수 있다.하지만[SerializeField]public GameObject Property2 { get; private set; }이런..."
  },
  
  {
    "title": "OpenGL 공부 - 06 - Shaders With a File",
    "url": "/posts/opengl-study-06/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-02 14:21:00 +0900",
    





    "snippet": "목표  쉐이더를 파일로 분리하여, 파일로부터 읽어와 사용하기공부 내용쉐이더 파일 작성하기  솔루션 디렉터리 - [Resources/Shaders] 폴더 생성  Shaders 폴더 내에 [Basic.shader] 파일 생성  속성 - 디버깅 - 작업 디렉터리에 $(ProjectDir)가 포함되어 있으므로 상대경로에서 불러오기 가능  기존의 쉐이더 코드를 옮겨와 약간 수정하여 내용 작성#shader vertex#version 330 corelayout(location = 0) in vec4 position;void main(){ ..."
  },
  
  {
    "title": "Vertex/Fragment Shader Bible [예정]",
    "url": "/posts/unity-vertex-fragment-shader-bible/",
    "categories": "Unity Shader, Shader Study",
    "tags": "unity, csharp, shader",
    "date": "2021-02-02 01:00:00 +0900",
    





    "snippet": "Vertex/Fragment Shader 구성  TODO  References  "
  },
  
  {
    "title": "Surface Shader Bible [작성 중]",
    "url": "/posts/unity-surface-shader-bible/",
    "categories": "Unity Shader, Shader Study",
    "tags": "unity, csharp, shader",
    "date": "2021-02-02 01:00:00 +0900",
    





    "snippet": "Surface Shader 기본 구성Shader &quot;Custom/SurfaceShader01&quot;{    Properties    {        _Color (&quot;Color&quot;, Color) = (1,1,1,1)        _MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; {}    }    SubShader    {        Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }        LOD ..."
  },
  
  {
    "title": "멀티패스 쉐이더 코드 깔끔하게 작성하기",
    "url": "/posts/unity-smart-multipass-code/",
    "categories": "Unity Shader, Shader Study",
    "tags": "unity, csharp, shader",
    "date": "2021-02-02 00:00:00 +0900",
    





    "snippet": "Shader &quot;A/B&quot;{    Properties    {        _MainTex (&quot;Texture&quot;, 2D) = &quot;black&quot; {}    }    CGINCLUDE    #include &quot;UnityCG.cginc&quot;    struct appdata    {        float4 vertex : POSITION;        float2 uv : TEXCOORD0;    };    struct v2f    {        float4 pos:SV_P..."
  },
  
  {
    "title": "C++ 스택 메모리 동적 할당",
    "url": "/posts/cpp-stack-memory-allocation/",
    "categories": "C++, C++ Memo",
    "tags": "cpp",
    "date": "2021-02-01 18:45:00 +0900",
    





    "snippet": "Memo      _alloca          스택에 메모리를 동적으로 할당해준다.      함수의 리턴으로 전달하면 안된다.      블록이 종료되면 자동으로 할당 해제된다.      공간 할당 불가능한 경우 Stack Overflow 에러가 발생할 수 있으니 주의      예외가 발생한 경우 구조적 예외처리(SEH)로 받아야 함                  size_t size      할당할 배열 크기(길이 * sizeof(타입))              return void*      할당된 배열의 주소(타입 캐스팅..."
  },
  
  {
    "title": "OpenGL 공부 - 05 - Shader",
    "url": "/posts/opengl-study-05/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-01 17:42:00 +0900",
    





    "snippet": "목표  OpenGL의 쉐이더에 대한 이해  간단한 vertex, fragment 쉐이더 작성, 컴파일 및 실행OpenGL의 쉐이더      Vertex&amp;amp;Fragment Shader          OpenGL에서 거의 90%의 비중을 차지            Vertex Shader          하나의 정점 당 한 번씩 실행된다.      layout을 통해 정점 속성의 위치를 입력받는다.      입력 : 정점 데이터      출력 : 클립 스페이스의 정점 데이터            Fragment Shad..."
  },
  
  {
    "title": "UI 드래그 앤 드롭으로 옮기기",
    "url": "/posts/unity-ui-drag-and-drop/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp, ui, memo, drag, drop",
    "date": "2021-02-01 03:00:00 +0900",
    





    "snippet": "기능  UI의 헤더(윗부분)를 따로 구성했을 때, 헤더를 드래그 했을 때만 옮기기사용법  헤더 UI는 UI의 자식으로 구성한다.  PopupUIHeader 스크립트를 헤더 UI의 컴포넌트로 넣어준다./// &amp;lt;summary&amp;gt; 헤더 드래그 앤 드롭에 의한 UI 이동 구현 &amp;lt;/summary&amp;gt;public class PopupUIHeader : MonoBehaviour,    IPointerDownHandler, IBeginDragHandler, IDragHandler{    priva..."
  },
  
  {
    "title": "팝업 UI 관리 시스템 구현하기",
    "url": "/posts/popup-ui-management-system/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp, ui, stack",
    "date": "2021-01-31 20:23:00 +0900",
    





    "snippet": "게임의 UI  온라인 PC게임을 예로 들었을 때, 다양한 형태의 UI들이 존재한다.  화면 예시 : Smilegate RPG ‘LostARK’1. 전체화면 UI  크기가 화면 전체에 해당하는 UI  예 : 상점, 캐시 샵2. 고정형 UI  고정된 위치에 항상 존재하는 UI  예 : 하단 바, 퀵슬롯, 미니맵, 채팅창3. 추적형 UI  게임 내 요소들(캐릭터, 몬스터, 건물 등)의 위치를 실시간으로 추적하여 따라다니는 UI  예 : 체력 바, 이름, 말풍선4. 안내형 UI  화면 한켠에 잠시 나타났다가 사라지는 형태의 UI  게..."
  },
  
  {
    "title": "OpenGL 공부 - 04 - VAO, VBO, Attributes",
    "url": "/posts/opengl-study-04/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-01-31 13:31:00 +0900",
    





    "snippet": "목표  Vertex Attributes, Layout, VBO, VAO에 대한 이해Attributes, VAO, VBO  버텍스 버퍼에는 버텍스 좌표, 텍스쳐 좌표, 노멀 벡터 등 여러 데이터가 float 값으로 들어갈 수 있다.  하지만 그 자체로는 그저 메모리에 올라가는 값일 뿐이기 때문에 각각의 데이터가 어떤 역할을 하고, 길이는 얼마나 갖고 있고, 시작 위치는 어디인지 OpenGL에 알려줘야 한다.      VAO(Vertex Array Object)          하나 이상의 VBO를 담을 수 있는 객체      개..."
  },
  
  {
    "title": "입력 바인딩 시스템 만들기",
    "url": "/posts/input-binding-system/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp, input, binding",
    "date": "2021-01-30 16:18:00 +0900",
    





    "snippet": "목표  에디터 및 인게임에서 언제든 기능에 연결된 사용자 마우스, 키보드 바인딩을 변경할 수 있는 기능 구현  전체 입력 바인딩을 직렬화하여 저장하고 불러올 수 있는 기능 구현유니티의 입력 시스템  유니티에는 2가지 Input System이 있다.  첫 번째는 Input.Get~ 꼴의 메소드를 이용해 이번 프레임에 해당 입력이 있었는지 검사하는 레거시 시스템      두 번째는 2019년 소개된 New Input System.    New Input System을 사용하려면          패키지 매니저에서 Input Syst..."
  },
  
  {
    "title": "OpenGL 공부 - 03 - Vertex, VBO",
    "url": "/posts/opengl-study-03/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-01-29 22:07:00 +0900",
    





    "snippet": "목표  버텍스, 버텍스 버퍼에 대한 이해렌더링 파이프라인 요약      Vertex Shader          입력 : 정점 목록      정점들을 오브젝트 스페이스에서 MVP 변환을 통해 클립 스페이스까지 변환한다.            Shape Assembly          정점을 조립하여 렌더링을 할 수 있는 최소 단위(Primitive : 점, 선, 삼각형 등)로 만든다.            Geometry Shader          입력 : 프리미티브 목록      프리미티브 당 한 번씩 수행한다.      프리..."
  },
  
  {
    "title": "스크립트 템플릿(Script Templates)",
    "url": "/posts/script-templates/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp, script, templates",
    "date": "2021-01-29 16:55:00 +0900",
    





    "snippet": "개념  Project - 우클릭 - Create를 통해 만드는 스크립트 또는 텍스트의 템플릿을 미리 지정하는 기능  스크립트 템플릿의 저장 경로 :C:\\Program Files\\유니티 버전\\Editor\\Data\\Resources\\ScriptTemplates  각각의 유니티 버전마다 따로 저장된다.  한가지 팁은, 스크립트 템플릿에 한 글자라도 애초에 한글이 작성되어 있지 않으면 나중에 한글 주석이라도 작성했을 때 인코딩이 깨져버릴 수 있으니 스크립트 템플릿 내에 아주 짧은 한글 주석을 적어 놓는게 좋다는 것규칙  각각의 템플릿..."
  },
  
  {
    "title": "OpenGL 공부 - 02 - 초기 세팅",
    "url": "/posts/opengl-study-02/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-01-28 22:09:00 +0900",
    





    "snippet": "목표  GLEW 설치 및 적용GLEW 설치  GLEW : OpenGL Extension Wrangler Library  http://glew.sourceforge.net      Binary 다운로드    프로젝트의 Dependency 폴더 내로 GLEW 폴더 복사          glew-2.1.0 폴더를 통째로 가져와서 GLEW로 이름을 변경해준다.        GLEW/doc/index.html - Usage 탭에 들어가면 초기 사용법이 있다.참조 추가  헤더          프로젝트 속성 - C/C++ - 일반 - 추가..."
  },
  
  {
    "title": "C# 파일 입출력",
    "url": "/posts/csharp-fileio/",
    "categories": "Csharp, Csharp Memo",
    "tags": "csharp, file, io",
    "date": "2021-01-28 21:10:00 +0900",
    





    "snippet": "간단 정리파일에 쓰려면  대상이 string, string[], byte[] 타입 중 하나여야 한다.  파일의 전체 경로(&quot;폴더경로\\파일명.확장자&quot;)가 필요하다.한 파일에 대한 연속 입출력 횟수에 따라  한번에 읽거나 쓰려면 File.Read(), File.Write() 메소드를 사용한다.  여러 번에 걸쳐 읽거나 쓰려면 스트림 객체를 사용한다.Namespaceusing System.IO;Path// \\ 대신 /를 써도 \\로 자동 변환string   filePath = @&quot;C:\\folder\\fileN..."
  },
  
  {
    "title": "OpenGL 공부 - 01 - 시작",
    "url": "/posts/opengl-study-01/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-01-28 00:10:00 +0900",
    





    "snippet": "목표  OpenGL 기초 세팅OpenGL?      OpenGL 자체는 API가 아닌, 각종 OpenGL 라이브러리를 개발하기 위해 Khronos Group이 개발 및 유지 관리하는 설명서이다.        OpenGL은 각 함수의 출력과 수행 방법을 정의한다.        실제로 OpenGL 라이브러리를 개발하는 사람들은 일반적으로 그래픽카드 제조업체이다.        OpenGL은 기본적으로 C언어로 작성되었으며, 각종 확장 라이브러리는 C++로 작성된 경우가 많다.  OpenGL 라이브러리 종류GL(Graphics Lib..."
  },
  
  {
    "title": "Unlit 쉐이더그래프로 만드는 Stylized Lit 쉐이더",
    "url": "/posts/unlit-stylized-lit-shadergraph/",
    "categories": "Unity Shader, Shader Graph Study",
    "tags": "unity, csharp, shader, shadergraph",
    "date": "2021-01-27 22:00:00 +0900",
    





    "snippet": "동기  유나이트 서울 2020의 위 세션을 보고, 쉐이더그래프만을 이용해 비슷하게 만들어 봐야겠다고 생각했다.목표  URP 쉐이더그래프 중 Unlit 그래프를 이용해 직접 Stylized Lit 쉐이더 만들기1. 서브그래프 준비  영상에서 보면, SmoothStep과 비슷한 연산을 더 저렴하게 할 수 있게 해주는 LinearStep을 다룬다.  LinearStep을 함수화하여 자주 사용하는 코드가 나오기에, 서브그래프로 만들어주었다.  그런데 실제로 이 세션의 코드를 보면 LinearStep 내에 threshold, smoot..."
  },
  
  {
    "title": "Frame Rate Checker",
    "url": "/posts/frame-rate-checker/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2021-01-24 17:00:00 +0900",
    





    "snippet": "Note  실제 FPS 값을 실시간, 최근 N개의 평균, 최소, 최댓값으로 확인할 수 있습니다.  게임 진행 동안 텍스트의 위치, 색상, 크기, GUI 표시 상태를 실시간으로 변경할 수 있습니다.PreviewSource Code  https://github.com/rito15/Unity_ToysDownload  FrameRateChecker.zip"
  },
  
  {
    "title": "잡 시스템(Job System)",
    "url": "/posts/job-system/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp, job, burst",
    "date": "2021-01-24 13:15:00 +0900",
    





    "snippet": "개념  유니티에서 안전한 멀티스레딩을 구현하는 시스템  스레드를 별도로 생성하지 않으며, 유니티의 워커스레드에 작업을 지시할 수 있게 한다.  잡 대기열에 잡을 배치하면 워커 스레드가 잡 대기열에서 항목을 가져와 실행한다.  Native Container를 이용해 잡의 수행 결과를 메인 스레드와 공유한다.  버스트 컴파일러를 이용하여 추가적인 성능 향상을 기대할 수 있다.장점  다수의 작은 작업들을 처리하기에 좋으며, 속도가 빠르다.  스레드를 추가로 만들고 관리하지 않아도 되므로 메모리를 절약할 수 있다.  유니티 콘솔을 이..."
  },
  
  {
    "title": "전장의 안개(Fog of War)",
    "url": "/posts/fog-of-war/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp",
    "date": "2021-01-20 21:00:00 +0900",
    





    "snippet": "목차  1. 개념  2. 구현 방법  3. 타일맵을 이용한 구현  4. 구현 결과  5. 프로파일링, 최적화  6. Reference개념  맵과 크기가 동일한 RGBA(0, 0, 0, a)의 텍스쳐를 이용해 지정한 유닛들의 주변시야를 표현한다.  지정한 유닛이 현재 위치한 원형 범위 내 영역들은 a = 0,  지정한 유닛이 한 번이라도 위치했던 영역들은 a = 0.5~0.8,  지정한 유닛이 한 번도 방문하지 않은 영역은 a = 1로 표현한다.[스타크래프트2 게임 플레이 화면]구현 방법[1] 카메라와 지상 사이에 검정색 Pla..."
  },
  
  {
    "title": "레이 마칭(Ray Marching)",
    "url": "/posts/ray-marching/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp",
    "date": "2021-01-19 23:15:00 +0900",
    





    "snippet": "레이 마칭이란?      폴리곤의 정점 정보를 이용하는 기존의 3D 렌더링 방식과는 달리, 레이를 전진시켜(Ray Marching) 표면의 정보를 얻어 오브젝트를 그려내는 기법        레이 마칭의 모든 모델링들은 폴리곤이 아닌 거리 함수(SDF : Signed Distance Function)로 표면의 정보가 계산된다.    한 점(RO : Ray Origin, 위의 그림에서 Camera)에서 스크린의 각각의 픽셀을 향한 방향(RD : Ray Direction, 위의 그림에서 Image)들을 향해레이 캐스팅을 하여, 각 ..."
  },
  
  {
    "title": "Pixelater",
    "url": "/posts/pixelater/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2021-01-19 22:56:00 +0900",
    





    "snippet": "Note  렌더 텍스쳐의 해상도를 강제로 변경하여 화면을 픽셀화시킵니다.  스크립트를 카메라에 부착하여 사용합니다.PreviewReference  https://www.youtube.com/watch?v=5rMkh9sl2bMSource Code  https://github.com/rito15/Unity_ToysDownload  Pixelater.zip"
  },
  
  {
    "title": "AfterImage(Motion Trail)",
    "url": "/posts/afterImage/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2021-01-18 22:56:00 +0900",
    





    "snippet": "Note  게임오브젝트가 지나간 자리에 잔상을 생성합니다.  하위 게임오브젝트에도 렌더러가 있는 경우, 잔상을 함께 생성할 수 있습니다.How To Use  대상 게임오브젝트에 Mesh Renderer가 존재하는 경우, MeshAfterImage 스크립트를 부착합니다.  Skinned Mesh Renderer가 존재하는 경우, SkinnedMeshAfterImage 스크립트를 부착합니다.      After Image Material 필드에 동봉된 AfterImage 마테리얼을 지정합니다.    After Image Gradi..."
  },
  
  {
    "title": "Custom Attributes",
    "url": "/posts/custom-attributes/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, custom, attribute",
    "date": "2021-01-17 22:18:00 +0900",
    





    "snippet": "Download  https://github.com/rito15/Unity_Custom_AttributesMemoBox  필드의 상단에 상자 및 메모를 표시합니다.            매개변수      설명                  Contents      메모에 적을 내용을 기록합니다. 스트링을 콤마로 구분할 경우 각각 개행됩니다.              FontSize      글자 크기 (기본 : 12)              LineSpacing      줄 간격 (기본 : 2)              TextCo..."
  },
  
  {
    "title": "Unlit 쉐이더그래프로 만드는 Custom Lit 쉐이더",
    "url": "/posts/unlit-custom-lit-shadergraph/",
    "categories": "Unity Shader, Shader Graph Study",
    "tags": "unity, csharp, shader, shadergraph",
    "date": "2021-01-16 22:14:00 +0900",
    





    "snippet": "목표  URP 쉐이더그래프 중 Unlit 그래프를 이용해 직접 Lit 쉐이더 만들기1. Diffuse 구현  커스텀 함수를 이용하여 메인라이트의 방향, 색상, 감쇠를 얻어낸다.Custom_Mainlight.hlslvoid MainLight_half(float3 WorldPos, out half3 Direction, out half3 Color, out half DistanceAtten, out half ShadowAtten){    #if SHADERGRAPH_PREVIEW        Direction = half3(0.5,..."
  },
  
  {
    "title": "비헤이비어 트리(Behavior Tree)",
    "url": "/posts/behavior-tree/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp",
    "date": "2021-01-05 00:26:00 +0900",
    





    "snippet": "개념  FSM (Finite State Machine)의 단점을 보완하기 위해 만들어진 기법  FSM에서는 상태 전이 조건을 모두 각각의 상태에서 검사하지만, BT에서는 상태 동작 뿐만 아니라 전이 조건도 노드로 관리한다.  노드 그래프를 통해 시각화하거나 params, 빌더 패턴 등을 활용하여 스크립트 내에서도 가독성 좋게 구성할 수 있다.  기본적으로 Leaf, Decorator, Composite 노드를 기반으로 하며, 구현은 많이 다를 수 있다.          Leaf : 동작을 수행하는 노드. 대표적으로 Action..."
  },
  
  {
    "title": "Lighting Models",
    "url": "/posts/lighting-models/",
    "categories": "Unity Shader, Shader Study",
    "tags": "unity, csharp, shader, graphics",
    "date": "2020-11-16 17:14:00 +0900",
    





    "snippet": "Vectors  L (Light) : 정점에서 광원을 향하는 방향의 벡터  N (Normal) : 정점의 노멀 벡터  V (View) : 정점에서 카메라를 향하는 방향의 벡터  R (Reflect) : 노멀벡터를 법선으로 하여 계산한 L의 반사 벡터 ( 2N(NdL)-L )      H (Half) : 블린퐁에서 사용, L와 V의 중간 벡터 ( normalize(L + V) )    NdL = dot(N, L) : 기본 램버트 공식  NdV = dot(N, V) : 림라이트에서 사용  RdV = dot(R, V) : 퐁 스페큘..."
  },
  
  {
    "title": "Singleton MonoBehavior",
    "url": "/posts/singleton-monobehavior/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2020-07-08 15:30:00 +0900",
    





    "snippet": "Note  단순한 상속만으로 모노비헤이비어 클래스를 싱글톤으로 만들어주는 클래스입니다.How To Use  클래스명이 Apple일 때 예시로, 다음과 같이 상속받아 사용합니다.public class Apple : Rito.SingletonMonoBehavior&amp;lt;Apple&amp;gt;{    // Awake 메소드는 반드시 이렇게 작성해야 합니다.    protected override void Awake()    {        base.Awake();        // .. 기타 코드    }}Preview  ..."
  },
  
  {
    "title": "Unity Editor-only Debug",
    "url": "/posts/unity-editor-only-debug/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2020-07-06 15:00:00 +0900",
    





    "snippet": "Note  유니티엔진의 콘솔 디버그는 빌드 이후에도 작동하여, 성능을 많이 소모할 수 있습니다.  이를 방지할 수 있게, 유니티 에디터에서만 작동하도록 래핑된 Debug 클래스입니다.How To Use  스크립트 상단에 다음과 같이 작성합니다.using Debug = Rito.Debug;Source Code  https://github.com/rito15/Unity_ToysDownload  Debug_UnityEditorConditional.zip"
  },
  
  {
    "title": "Getcomponent Attributes",
    "url": "/posts/getcomponent-attributes/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2020-04-12 23:30:00 +0900",
    





    "snippet": "Note  GetComponent(), Find() 종류의 메소드들을 필드/프로퍼티 애트리뷰트로 제공합니다.Catalog/* ******************************************************************************** * *                                    참고사항                                       * * ************************************************************..."
  },
  
  {
    "title": "Save Transform During Play",
    "url": "/posts/save-transform-during-play/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2020-04-11 18:10:00 +0900",
    





    "snippet": "Note      기존에는 플레이 모드에서 트랜스폼의 위치, 회전, 크기를 변경하여도플레이 모드가 종료되면 변경사항이 저장되지 않습니다.        따라서 컴포넌트를 간단히 추가하기만 하면 플레이 모드를 종료해도트랜스폼의 변경사항이 저장되도록 하는 컴포넌트를 제작했습니다.  How to Use      원하는 게임오브젝트에 SaveTransformDuringPlay 컴포넌트를 추가하고, On에 체크합니다.        플레이 모드에서 On, 각각의 Space 옵션을 수정해도 수정사항이 적용됩니다.        인스펙터에서 P..."
  }
  
]


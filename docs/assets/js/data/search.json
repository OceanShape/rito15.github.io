[
  
  {
    "title": "Job System",
    "url": "/posts/job-system/",
    "categories": "Unity, Study",
    "tags": "unity, csharp, job, burst",
    "date": "2021-01-24 13:15:00 +0900",
    





    "snippet": "개념  유니티에서 안전한 멀티스레딩을 구현하는 시스템  스레드를 별도로 생성하지 않으며, 유니티의 워커스레드에 작업을 지시할 수 있게 한다.  잡 대기열에 잡을 배치하면 워커 스레드가 잡 대기열에서 항목을 가져와 실행한다.  Native Container를 이용해 잡의 수행 결과를 메인 스레드와 공유한다.  버스트 컴파일러를 이용하여 추가적인 성능 향상을 기대할 수 있다.장점  다수의 작은 작업들을 처리하기에 좋으며, 속도가 빠르다.  스레드를 추가로 만들고 관리하지 않아도 되므로 메모리를 절약할 수 있다.  유니티 콘솔을 이..."
  },
  
  {
    "title": "Fog of War",
    "url": "/posts/fog-of-war/",
    "categories": "Unity, Study",
    "tags": "unity, csharp",
    "date": "2021-01-19 23:15:00 +0900",
    





    "snippet": "개념  맵 전체에 걸쳐 RGBA(0, 0, 0, a)의 텍스쳐를 씌워 시야를 표현한다.  지정한 유닛이 현재 위치한 영역들은 a = 0,  지정한 유닛이 한 번이라도 위치했던 영역들은 a = 0.5~0.8,  지정한 유닛이 한 번도 방문하지 않은 영역은 a = 1로 표현한다.구현 방법[1] 카메라와 지상 사이에 안개 플레인 사용      시야의 역할을 해줄 검정색 플레인을 카메라와 지상 사이에 위치시킨다.        맵 전체를 좌표 형태의 2차원배열로 관리하여, 유닛들이 현재 위치한 영역, 방문했던 영역, 한 번도 방문하지 ..."
  },
  
  {
    "title": "Ray Marching",
    "url": "/posts/ray-marching/",
    "categories": "Unity, Study",
    "tags": "unity, csharp",
    "date": "2021-01-19 23:15:00 +0900",
    





    "snippet": "레이 마칭이란?      폴리곤의 정점 정보를 이용하는 기존의 3D 렌더링 방식과는 달리, 레이를 전진시켜(Ray Marching) 표면의 정보를 얻어 오브젝트를 그려내는 기법        레이 마칭의 모든 모델링들은 폴리곤이 아닌 거리 함수(SDF : Signed Distance Function)로 표면의 정보가 계산된다.    한 점(RO : Ray Origin, 위의 그림에서 Camera)에서 스크린의 각각의 픽셀을 향한 방향(RD : Ray Direction, 위의 그림에서 Image)들을 향해레이 캐스팅을 하여, 각 ..."
  },
  
  {
    "title": "Custom Attributes",
    "url": "/posts/custom-attributes/",
    "categories": "Unity, Toys",
    "tags": "unity, csharp, custom, attribute",
    "date": "2021-01-17 22:18:00 +0900",
    





    "snippet": "Download  https://github.com/rito15/Unity_Custom_AttributesMemoBox  필드의 상단에 상자 및 메모를 표시합니다.            매개변수      설명                  Contents      메모에 적을 내용을 기록합니다. 스트링을 콤마로 구분할 경우 각각 개행됩니다.              FontSize      글자 크기 (기본 : 12)              LineSpacing      줄 간격 (기본 : 2)              TextCo..."
  },
  
  {
    "title": "Behavior Tree",
    "url": "/posts/behavior-tree/",
    "categories": "Unity, Study",
    "tags": "unity, csharp",
    "date": "2021-01-05 00:26:00 +0900",
    





    "snippet": "개념  FSM (Finite State Machine)의 단점을 보완하기 위해 만들어진 기법  FSM에서는 상태 전이 조건을 모두 각각의 상태에서 검사하지만, BT에서는 상태 동작 뿐만 아니라 전이 조건도 노드로 관리한다.  노드 그래프를 통해 시각화하거나 params, 빌더 패턴 등을 활용하여 스크립트 내에서도 가독성 좋게 구성할 수 있다.  기본적으로 Leaf, Decorator, Composite 노드를 기반으로 하며, 구현은 많이 다를 수 있다.          Leaf : 동작을 수행하는 노드. 대표적으로 Action..."
  },
  
  {
    "title": "Getcomponent Attributes",
    "url": "/posts/getcomponent-attributes/",
    "categories": "Unity, Toys",
    "tags": "unity, csharp, plugin",
    "date": "2020-04-12 23:30:00 +0900",
    





    "snippet": "Note  GetComponent(), Find() 종류의 메소드들을 필드/프로퍼티 애트리뷰트로 제공합니다.  https://github.com/rito15/Unity_GetComponent-AttributesCatalog/* ******************************************************************************** * *                                    참고사항                                       * * ***..."
  },
  
  {
    "title": "Save Transform During Play",
    "url": "/posts/save-transform-during-play/",
    "categories": "Unity, Toys",
    "tags": "unity, csharp, plugin",
    "date": "2020-04-11 18:10:00 +0900",
    





    "snippet": "설명      기존에는 플레이 모드에서 트랜스폼의 위치, 회전, 크기를 변경하여도플레이 모드가 종료되면 변경사항이 저장되지 않습니다.        따라서 컴포넌트를 간단히 추가하기만 하면 플레이 모드를 종료해도트랜스폼의 변경사항이 저장되도록 하는 컴포넌트를 제작했습니다.  사용법      원하는 게임오브젝트에 SaveTransformDuringPlay 컴포넌트를 추가하고, On에 체크합니다.        플레이 모드에서 On, 각각의 Space 옵션을 수정해도 수정사항이 적용됩니다.        인스펙터에서 Position S..."
  }
  
]


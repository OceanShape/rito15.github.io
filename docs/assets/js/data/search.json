[
  
  {
    "title": "마우스 이벤트를 통과시킬 수 있는 컨트롤 만들기",
    "url": "/posts/memo-cs-winform-pass-through-mouse-events/",
    "categories": "Memo, Csharp Winform Memo",
    "tags": "csharp, winform",
    "date": "2021-05-09 01:30:00 +0900",
    





    "snippet": "목표  마우스 이벤트를 모두 무시할 수 있는 컨트롤(버튼, 레이블 등) 만들기방법      특정 컨트롤 클래스(Button, Label, …)를 상속받는 클래스를 작성한다.        아래와 같이 프로퍼티와 메소드를 작성한다.  public bool Ignored { get; set; } = false;protected override void WndProc(ref Message m){    const int WM_NCHITTEST = 0x0084;    const int HTTRANSPARENT = (-1);    if (..."
  },
  
  {
    "title": "윈폼 중복 실행 방지",
    "url": "/posts/memo-cs-winform-prevent-duplication/",
    "categories": "Memo, Csharp Winform Memo",
    "tags": "csharp, winform",
    "date": "2021-05-06 02:02:00 +0900",
    





    "snippet": "Memo  Program.cs에서 Main() 메소드 지우고 아래 내용 복붙하기/// &amp;lt;summary&amp;gt;/// 해당 응용 프로그램의 주 진입점입니다./// &amp;lt;/summary&amp;gt;[STAThread]static void Main(){    if (!IsDuplicated())        RunApplication();}// 이미 실행 중인 프로세스(중복 프로세스)가 있는지 확인private static bool IsDuplicated(){    try    {        int p..."
  },
  
  {
    "title": "Notify Icon 사용하기",
    "url": "/posts/memo-cs-winform-notifyicon/",
    "categories": "Memo, Csharp Winform Memo",
    "tags": "csharp, winform",
    "date": "2021-05-06 02:02:00 +0900",
    





    "snippet": "Memo1. 도구  NotifyIcon 추가  ContextMenuStrip 추가2. 속성  Form - Icon에 .ico 아이콘 파일 등록  NotifyIcon - Icon에 아이콘 등록(안하면 컨텍스트 안생김)  NotifyIcon - ContextMenuStrip 연결3. 필드, 메소드 추가//FormClosing 이벤트로 종료 가능 여부private bool closeAllowed = false;private void ShowForm(){    // 폼 등장    this.Show();    //창의 속성을 최소화-&..."
  },
  
  {
    "title": "깃 관련 메모 모음",
    "url": "/posts/memo-git/",
    "categories": "Memo",
    "tags": "memo, git, github",
    "date": "2021-05-03 17:00:00 +0900",
    





    "snippet": "Git 구성[1] Local[1-1] Working Directory  작업 디렉토리 : 윈도우 내 폴더  git add 명령어를 통해 변경된 파일들을 Staging Area로 옮길 수 있다.[1-2] Staging Area  커밋할 대상들을 저장하는 임시 저장소  파일 변경사항 스냅샷을 안전하게 보관하지는 않는다.  git commit 명령어를 통해 스테이징 영역 내의 파일들을 .git Directory로 옮길 수 있다.[1-3] .git Directory (History)  커밋 히스토리를 저장한다.  커밋 버전별로 내용을..."
  },
  
  {
    "title": "커스텀 에디터로 인스펙터에 Private 필드 나타내기",
    "url": "/posts/unity-editor-show-private-fields/",
    "categories": "Unity, Unity Editor",
    "tags": "unity, editor, csharp",
    "date": "2021-04-29 20:30:00 +0900",
    





    "snippet": "Memo커스텀 에디터를 통해서 private 필드를 인스펙터에 표시하려면 일단 두 가지 방법이 있다.1. 내부 클래스로 작성커스텀 에디터 클래스를 대상 모노비헤이비어 클래스의 내부에 작성하면 private 필드에도 접근할 수 있다.public partial class RadialMenu : MonoBehaviour{    [CustomEditor(typeof(RadialMenu))]    public class RadialMenuEditor : UnityEditor.Editor    {        private RadialM..."
  },
  
  {
    "title": "Radial Menu 만들기",
    "url": "/posts/unity-study-radial-menu/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp",
    "date": "2021-04-26 18:00:00 +0900",
    





    "snippet": "목표  극좌표계를 이용하여 원형 분포 형태의 메뉴 UI 만들기Preview직교 좌표계  Cartesian Coordinate System유니티2D에서 사용하는 좌표계는 x, y 축으로 이루어진 직교 좌표계이다.데카르트 좌표계라고도 하며, x, y 값을 통해 좌표를 표현한다.극좌표계  Polar Coordinate System직교 좌표계와는 달리, 거리(radius)와 각도(angle)를 통해 특정 좌표를 표현한다.이 때 거리는 중심으로부터의 거리, 각도는 직교 좌표계의 +X 축으로부터의 각도를 의미한다.좌표가 중심을 기준으로 ..."
  },
  
  {
    "title": "브레즌햄(픽셀에 직선 그리기) 알고리즘",
    "url": "/posts/bresenham-algorithm/",
    "categories": "Algorithm",
    "tags": "algorithm, csharp",
    "date": "2021-04-25 17:32:00 +0900",
    





    "snippet": "Summary직선을 그릴 때 직선 위의 점들은 실수 값을 가질 수밖에 없다.그래서 불연속 정수 값만을 갖는 픽셀에 직선을 그릴 때는실수 값의 소수점을 버리거나 반올림하여 정수로 변환해야 하는데,브레즌햄 알고리즘은 실수 연산 없이 정수 연산만으로 직선을 그릴 수 있게 해준다.Details2가지 경우로 나눈다.  기울기 절댓값이 1 미만인 경우  기울기 절댓값이 1 이상인 경우1번의 경우에는 x 좌표를 1씩 증가 또는 감소시키며 해당하는 y 좌표를 구하고,2번의 경우에는 y 좌표를 1씩 증가 또는 감소시키며 해당하는 x 좌표를 구..."
  },
  
  {
    "title": "Debug.Log에 색상 넣기",
    "url": "/posts/unity-memo-color-debug-log/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp",
    "date": "2021-04-25 17:10:00 +0900",
    





    "snippet": "Memo  &amp;lt;color=&amp;gt;&amp;lt;/color&amp;gt; 태그를 사용하여 로그 메시지에 색상을 넣을 수 있다.  color= 뒤에는 색상 이름 또는 HTML 색상코드를 입력한다.Debug.Log(&quot;Default&quot;);Debug.Log(&quot;&amp;lt;color=white&amp;gt;White&amp;lt;/color&amp;gt;&quot;);Debug.Log(&quot;&amp;lt;color=grey&amp;gt;Grey&amp;lt;/color&amp;gt;&q..."
  },
  
  {
    "title": "Drag and Drop Recorder",
    "url": "/posts/unity-toy-drag-and-drop-recorder/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2021-04-19 21:00:00 +0900",
    





    "snippet": "Summary  드래그 앤 드롭으로 게임오브젝트를 커서를 따라 이동시킨다.  이동 경로를 기록하고, 반복재생할 수 있다.How To Use  빈 게임오브젝트에 DDRecorder 컴포넌트를 추가한다.  드래그 앤 드롭으로 이동시킬 게임오브젝트에 콜라이더와 DDTarget 컴포넌트를 추가한다.  DDRecorder 컴포넌트의 Replay Target 필드에 반복 재생시킬 게임오브젝트를 등록한다.  스페이스바를 누를 때마다 등록된 경로대로 타겟 게임오브젝트가 이동한다.PreviewDownload  Drag and Drop Reco..."
  },
  
  {
    "title": "RPG Inventory System(RPG 게임용 인벤토리 제작하기)",
    "url": "/posts/unity-study-rpg-inventory/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp",
    "date": "2021-04-15 22:00:00 +0900",
    





    "snippet": "개요  RPG 게임에서 사용할 수 있는 기본적인 인벤토리를 제작한다.클래스 구성1. 인벤토리  Inventory : 전체 아이템들을 관리하고, 인벤토리 내부의 실질적 동작들을 담당한다.2. 아이템  Item : 인벤토리의 각 슬롯에 들어가는 실제 아이템. 각각의 아이템이 개별적으로 갖는 데이터들을 보관한다.          CountableItem : 수량을 셀 수 있는 아이템                  PortionItem : 소모 아이템(포션)                    EquipmentItem : 장비 아이템 ..."
  },
  
  {
    "title": "Quick Sort(빠른 정렬)",
    "url": "/posts/algorithm-quick-sort/",
    "categories": "Algorithm, Sort Algorithm",
    "tags": "algorithm, csharp",
    "date": "2021-04-07 22:00:00 +0900",
    





    "snippet": "Summary            시간복잡도      평균 \\(O(n log n)\\), 최악 \\(O(n^2)\\)              공간복잡도      \\(O(n)\\)              정렬 특징      불안정 정렬      특징  분할 정복  재귀Details메소드 구성QuickSort(arr, left, right)  배열의 left ~ right 인덱스 내에서만 정렬을 수행한다.Partition(arr, left, right)  배열의 left ~ right 인덱스 내에서 피벗을 선정한다.  내부적으로 정렬을 ..."
  },
  
  {
    "title": "O(logn) 거듭제곱 알고리즘",
    "url": "/posts/algorithm-pow/",
    "categories": "Algorithm",
    "tags": "algorithm, csharp",
    "date": "2021-04-06 18:00:00 +0900",
    





    "snippet": "Summary      일반적으로 \\(O(n)\\) 시간복잡도로 수행하는 거듭제곱 계산을 \\(O(log_{2}n)\\) 의 시간복잡도로 수행할 수 있는 알고리즘        2진수 연산을 이용한다.  Details\\(a^n\\)을 계산하는 가장 쉬운 방법은 \\(a\\)를 \\(n\\) 번 곱하는 것이다.예를 들어 \\(4^9\\)을 구하려면 \\(4 \\cdot 4 \\cdot 4 \\cdot 4 \\cdot 4 \\cdot 4 \\cdot 4 \\cdot 4 \\cdot 4\\)를 계산하면 된다.하지만 이렇게 되면 \\(n - 1\\) 번의 곱셈을 수행하므로 ..."
  },
  
  {
    "title": "유니티의 멀티스레딩과 Job의 활용",
    "url": "/posts/unity-study-multithread-job/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp, multithread, job",
    "date": "2021-04-04 22:00:00 +0900",
    





    "snippet": "유니티에서의 멀티스레딩유니티엔진에서는 기본적으로 모든 CPU 연산이 메인 스레드에서 이루어진다.그렇다고 다중 스레드를 사용할 수 없다는 것은 아니지만메인 스레드가 아닌 다른 스레드에서 유니티의 메인 로직에 접근할 수 없도록 막혀있다.다시 말해, 다른 스레드에서는 게임오브젝트, 컴포넌트 등에 접근하면 에러가 발생한다.예를 들어private async void TaskTest(){    await Task.Run(() =&amp;gt;    {        transform.Translate(1f, 0f, 0f);    });}이..."
  },
  
  {
    "title": "파티클 시스템 예제 - 11 - Sword Effect",
    "url": "/posts/unity-particle-system-example-11-sword-effect/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-03-30 23:23:00 +0900",
    





    "snippet": "목차  목표  준비물  1. 하이라키 구성  2. Glow 이펙트  3. Sparkle 이펙트  4. Aura 이펙트  5. 결과Preview목표  검 모델링에 부착하여 사용할 수 있는 이펙트(무기 강화 이펙트) 만들기준비물  검 모델링          https://assetstore.unity.com/packages/3d/props/weapons/free-low-poly-swords-189978        Sparkle, PointGlow 텍스쳐를 사용하는 Additive 마테리얼          Sparkle_Point..."
  },
  
  {
    "title": "Static Readonly vs. Const",
    "url": "/posts/memo-cs-static-readonly-vs-const/",
    "categories": "Memo, Csharp Memo",
    "tags": "csharp",
    "date": "2021-03-30 00:50:00 +0900",
    





    "snippet": "공통점  런타임에 값을 변경할 수 없다.차이점Static Readonly      필드 선언문 또는 정적 생성자에서만 값을 초기화할 수 있다.        값을 초기화하지 않으면 해당 타입의 기본값으로 초기화된다.        런타임 초기에 값이 고정된다.        값이 정해지면 변하지 않지만, 결국 변수이기 때문에 참조 오버헤드가 발생한다.  Const      필드 선언문에서만 값을 초기화할 수 있다.        값을 초기화해야만 한다.        컴파일 타임에 값이 고정된다.        리터럴처럼 사용될 수 있다..."
  },
  
  {
    "title": "Voxel System(유니티에서 마인크래프트 구현하기)",
    "url": "/posts/unity-study-voxel/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp",
    "date": "2021-03-26 20:40:00 +0900",
    





    "snippet": "목차  목표  1. 복셀 기본  2. 청크와 맵 데이터  3. 텍스쳐 입히기  4. 월드에서 청크 생성 및 관리하기  5. 지형 만들기  6. 캐릭터 컨트롤러 만들기  목표  유튜브 강좌를 따라가며 구현한다.유니티엔진에서 마인크래프트와 같은 복셀 시스템을 구현한다.모든 맵과 사물은 큐브 형태를 띠고 있으며, 생성하거나 파괴할 수 있다.각각의 큐브를 개별 오브젝트로 렌더링할 경우 부하가 굉장히 크기 때문에,일정 영역의 큐브들을 모아 하나의 청크(Chunk)이자 하나의 메시로 관리하는 것이 핵심이다.1. 복셀 기본큐브의 정점 데이..."
  },
  
  {
    "title": "Prime Number(소수)",
    "url": "/posts/memo-cs-prime-number/",
    "categories": "Memo, Csharp Memo",
    "tags": "csharp",
    "date": "2021-03-26 18:12:00 +0900",
    





    "snippet": "Memo1. 소수인지 확인하기/// &amp;lt;summary&amp;gt; 지정한 수가 소수인지 확인 &amp;lt;/summary&amp;gt;public static bool IsPrime(int value){    bool isEvenNumber = (value % 2) == 0;    // 짝수일 경우 2만 소수    if (isEvenNumber) return value == 2;    // 1은 소수 아님    if (value == 1) return false;    // 제곱근까지만 확인    int sqrt..."
  },
  
  {
    "title": "Cloaking(Refraction)",
    "url": "/posts/unity-urp-sg-cloaking/",
    "categories": "Unity Shader, URP Shader Graph",
    "tags": "unity, csharp, urp, shadergraph",
    "date": "2021-03-25 20:40:00 +0900",
    





    "snippet": "Summary      뒤의 풍경을 왜곡시켜 보여주는 클로킹 쉐이더        Render Pipeline Asset에서 Opaque Texture에 체크해야 한다.        Opaque Texture를 사용할 때는 쉐이더그래프의 마스터 노드 Surface를 Transparent로 설정해야 한다.  PreviewOptions            프로퍼티      설명                  Normal Map      노멀맵 텍스쳐(없을 경우 기본 노멀 벡터 사용)              Refraction    ..."
  },
  
  {
    "title": "노멀맵에서 노멀 벡터 추출하기",
    "url": "/posts/unity-urp-sg-memo-normal-map/",
    "categories": "Unity Shader, URP Shader Graph Memo",
    "tags": "unity, csharp, urp, shadergraph",
    "date": "2021-03-25 17:00:00 +0900",
    





    "snippet": "Memo      Tangent, Bitangent, Normal Vector로 이루어진 3x3 행렬과 샘플링된 노멀맵 벡터를 곱해줌으로써, 노멀맵으로부터 노멀 벡터를 추출하여 사용할 수 있다.        행렬을 만들 때 행벡터를 조립하여 만들지, 열벡터를 조립하여 만들지 여부에 주의해야 한다.        행렬과 벡터를 곱할 때 벡터가 앞에 나오면 행벡터, 뒤에 나오면 열벡터로 사용됨에 주의해야 한다.        T, B, N 벡터의 공간을 반드시 일치시켜줘야 한다.        각 벡터들의 공간은 노멀맵의 사용 대상에 ..."
  },
  
  {
    "title": "Directional Dissolve (2 Color)",
    "url": "/posts/unity-urp-sg-directional-dissolve/",
    "categories": "Unity Shader, URP Shader Graph",
    "tags": "unity, csharp, urp, shadergraph",
    "date": "2021-03-25 00:00:00 +0900",
    





    "snippet": "Summary      디졸브 방향을 직접 지정할 수 있는 디졸브 쉐이더        디졸브 효과 색상 2가지를 지정할 수 있다.        포스트 프로세싱 Bloom 효과가 반드시 필요하다.  PreviewOptions            프로퍼티      설명                  Main Texture      메인 텍스쳐              Tint Color      메인 텍스쳐에 곱할 색상              Color A      디졸브 첫 번째 영역의 색상              Color B ..."
  },
  
  {
    "title": "파티클 시스템 예제 - 10 - Magic Circle",
    "url": "/posts/unity-particle-system-example-10-magic-circle/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-03-23 17:12:00 +0900",
    





    "snippet": "목차  목표  준비물  1. Magic Circle 이펙트  2. Circle Loop 이펙트  3. Dust 이펙트  4. Burn 이펙트  5. 다양한 연출 효과Preview목표  예쁜 마법진 이펙트 만들기  Trail 활용하기  Duration, Delay 활용하여 다양한 연출 효과 만들기준비물MagicCircle_Resources.zip      텍스쳐 : 마법진, Point, Trail        Trail 텍스쳐는 다양한 텍스쳐들을 사용하여 서로 다른 효과를 낼 수 있다.          Default-Partic..."
  },
  
  {
    "title": "파티클 시스템 예제 - 09 - Rainfall",
    "url": "/posts/unity-particle-system-example-09-rainfall/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-03-23 17:10:00 +0900",
    





    "snippet": "목차  목표  준비물  씬 준비  1. Rainfall 이펙트  2. Splash 이펙트  3. Ripple 이펙트  4. 결과Preview[1][2]목표      비내리는 이펙트 만들기        빗줄기가 바닥에 충돌했을 때 물 튀기는 이펙트, 파문이 번져나가는 이펙트 만들기  준비물Rainfall_Resources.zip  빗줄기에 사용할 Droplet 텍스쳐          좌우 크기를 많이 줄여서 길쭉하게 사용하기 때문에 무엇이든 상관 없다.      기본값인 Default-Particle System도 가능     ..."
  },
  
  {
    "title": "베지어 곡선(Bezier Curve)",
    "url": "/posts/unity-study-bezier-curve/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp, curve",
    "date": "2021-03-20 19:19:00 +0900",
    





    "snippet": "베지어 곡선  점과 점 사이의 선형 보간(Lerp, Linear interpolation)을 이용해 그려내는 곡선1차 베지어 곡선      Linear Curve        2개의 점        단순히 두 점 사이의 선형 보간을 통해, 직선을 그린다.  2차 베지어 곡선      Quadratic Curve        3개의 점 P0, P1, P2        Lerp(P0, P1, t)를 통해 보간된 지점 P01을 구한다.        Lerp(P1, P2, t)를 통해 보간된 지점 P02를 구한다.        P01..."
  },
  
  {
    "title": "트랜스폼과 방향벡터의 회전",
    "url": "/posts/unity-memo-rotation/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp, rotation",
    "date": "2021-03-19 17:08:00 +0900",
    





    "snippet": "Memo유니티엔진에서의 회전  각 축에 회전이 적용되는 순서는 Z축 -&amp;gt; X축 -&amp;gt; Y축트랜스폼을 자신의 축으로 회전시킬 때Local Rotation(Euler) X, Y, Z 값 중 회전시키려는 축을 제외하고 모두 0이라면(예 : X축으로 회전시키려는데 (34f, 0f, 0f)인 상태)해당 축의 오일러 값만 변경시키면 다른 축에 영향을 받지 않고 정상적으로 회전할 수 있다.정확히는, 유니티엔진의 회전 순서에 따라Z축 회전일 경우 X, Y 오일러 값에 상관 없이 회전이 가능하고X축 회전일 경우 Z 값이..."
  },
  
  {
    "title": "파티클 시스템 예제 - 08 - Meteor Swarm [TODO]",
    "url": "/posts/unity-particle-system-example-08-meteor-swarm/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-03-16 17:10:00 +0900",
    





    "snippet": "Preview"
  },
  
  {
    "title": "파티클 시스템 예제 - 07 - Fireworks",
    "url": "/posts/unity-particle-system-example-07-fireworks/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-03-16 17:10:00 +0900",
    





    "snippet": "목차  목표  준비물  1. Fireworks 이펙트  2. SubEmitter - Birth  3. SubEmitter - Death  4. SubEmitter - Death Flash  5. 완성Preview목표      서브 이미터 모듈 이해하기        불꽃놀이 이펙트 완성하기  준비물  동그란 텍스쳐와 Additive 마테리얼1. Fireworks 이펙트불꽃을 하늘로 쏘아올리는, 간단한 형태의 이펙트를 우선 제작한다.준비      하이라키 - 우클릭 - [Effects] - [Particle System]을 통해 ..."
  },
  
  {
    "title": "포스트 프로세싱 적용하기",
    "url": "/posts/unity-memo-post-processing/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp, postprocessing",
    "date": "2021-03-16 17:00:00 +0900",
    





    "snippet": "1. Built-in Pipeline      Package Manager - [Post Processing] 설치        레이어 - [Post Processing] 추가    메인 카메라          컴포넌트 추가 : Post-process Layer      Volume blending - Layer : [Post Processing] 설정        빈 게임오브젝트 추가 : “Volume”          레이어 설정 : [Post Processing]      컴포넌트 추가 : Post-process Volu..."
  },
  
  {
    "title": "Stencil Silhouette Shader",
    "url": "/posts/unity-shader-script-stencil-silhouette/",
    "categories": "Unity Shader, Shader Scripts",
    "tags": "unity, csharp, shader, shaderlab",
    "date": "2021-03-15 17:20:00 +0900",
    





    "snippet": "Summary  가려질 경우 단색이 드러나는 실루엣 쉐이더  Ref 2번 사용PreviewSource Code   Silhouette.shader  Shader &quot;Custom/Silhouette&quot;{    Properties    {        _SilhouetteColor (&quot;Silhouette Color&quot;, Color) = (1, 0, 0, 0.5)        [Space]        _Color (&quot;Color&quot;, Color) = (1,1,1,1)        _Ma..."
  },
  
  {
    "title": "Stencil Mask Shader",
    "url": "/posts/unity-shader-script-stencil-mask/",
    "categories": "Unity Shader, Shader Scripts",
    "tags": "unity, csharp, shader, shaderlab",
    "date": "2021-03-15 17:10:00 +0900",
    





    "snippet": "Summary  스텐실 마스크 &amp;amp; 마스크로 가려야 드러나는 타겟 쉐이더  Ref 1번 사용PreviewSource Code   StencilTarget01.shader  Shader &quot;Custom/StencilTarget01&quot;{    Properties    {        _Color (&quot;Color&quot;, Color) = (1,1,1,1)        _MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; {}    }    S..."
  },
  
  {
    "title": "Customizable Transparent Shader",
    "url": "/posts/unity-shader-script-transparent-custom/",
    "categories": "Unity Shader, Shader Scripts",
    "tags": "unity, csharp, shader, shaderlab",
    "date": "2021-03-15 17:00:00 +0900",
    





    "snippet": "Summary  알파 블렌딩, ZTest 등의 옵션을 마테리얼에서 설정할 수 있는 반투명 쉐이더Source CodeShader &quot;Custom/CustomizableTransparent&quot;{    Properties    {        _MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; {}                _Color (&quot;Color&quot;, Color) = (1,1,1,1)        _Alpha (&quot;Alpha&quot;..."
  },
  
  {
    "title": "2-Pass Transparent Shader",
    "url": "/posts/unity-shader-script-transparent-2pass/",
    "categories": "Unity Shader, Shader Scripts",
    "tags": "unity, csharp, shader, shaderlab",
    "date": "2021-03-15 17:00:00 +0900",
    





    "snippet": "Summary  2패스로 작성하여 내부가 드러나는 알파 소팅 문제가 발생하지 않는 쉐이더Source CodeShader &quot;Custom/Transparent2Pass&quot;{    Properties    {        _MainTex(&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; {}        _Alpha(&quot;Alpha&quot;, Range(0, 1)) = 0.5    }    SubShader    {        Tags { &quot;RenderType..."
  },
  
  {
    "title": "Particle Shader",
    "url": "/posts/unity-shader-script-particle/",
    "categories": "Unity Shader, Shader Scripts",
    "tags": "unity, csharp, shader, shaderlab",
    "date": "2021-03-15 16:00:00 +0900",
    





    "snippet": "Summary  블렌딩 옵션 선택 가능한 파티클 쉐이더(기본 : Additive)Source CodeShader &quot;Custom/Particle&quot;{    Properties    {        _TintColor (&quot;Tint Color&quot;, Color) = (1, 1, 1, 1)        _Intensity(&quot;Intensity&quot;, Range(0, 2)) = 1        _MainTex(&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quo..."
  },
  
  {
    "title": "키보드 연속 입력 유지 상태 감지하기",
    "url": "/posts/unity-memo-double-key-press/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp, input",
    "date": "2021-03-14 23:23:00 +0900",
    





    "snippet": "활용  달리기 구현(WW, AA, SS, DD)Source Code/// &amp;lt;summary&amp;gt; 키보드 연속 입력 유지 상태 감지 &amp;lt;/summary&amp;gt;private class KeyForDoublePressDetection{    public KeyCode Key { get; private set; }    /// &amp;lt;summary&amp;gt; 한 번 눌러서 유지한 상태 &amp;lt;/summary&amp;gt;    public bool SinglePressed { g..."
  },
  
  {
    "title": "Custom Editor (커스텀 에디터)",
    "url": "/posts/unity-editor-custom-editor/",
    "categories": "Unity, Unity Editor",
    "tags": "unity, editor, csharp, customeditor",
    "date": "2021-03-13 17:40:00 +0900",
    





    "snippet": "Begin   Custom Editor Example  #if UNITY_EDITORusing System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEditor;[CustomEditor(typeof(SomeScript))]public class SomeScriptEditor : UnityEditor.Editor{    private SomeScript ss;    private void OnEnable()    {..."
  },
  
  {
    "title": "Play Mode Saver (플레이 모드가 끝나도 변경사항 유지)",
    "url": "/posts/unity-editor-plugin-play-mode-saver/",
    "categories": "Unity, Unity Editor Plugins",
    "tags": "unity, editor, csharp, plugin",
    "date": "2021-03-13 17:20:00 +0900",
    





    "snippet": "Note      등록한 컴포넌트의 플레이 모드 내 변경사항을 플레이 모드가 종료되어도 유지시킨다.        변경사항을 적용할 대상 컴포넌트들은 Play Mode Saver 컴포넌트 내에 관리된다.        유니티 에디터 내에서만 동작하며, 빌드 시 Play Mode Saver 컴포넌트는 자동으로 제거된다.        플레이 모드 내에서 Play Mode Saver를 수정한 사항도 플레이 모드가 종료되었을 때 유지된다.  PreviewHow To Use  변경사항 유지를 원하는 컴포넌트에 우클릭 후, Save Play..."
  },
  
  {
    "title": "델리게이트가 특정 메소드를 갖고 있는지 확인하기",
    "url": "/posts/memo-cs-delegate-has-method/",
    "categories": "Memo, Csharp Memo",
    "tags": "csharp, delegate",
    "date": "2021-03-12 21:52:00 +0900",
    





    "snippet": "//using System;//using System.Linq;/// &amp;lt;summary&amp;gt; 델리게이트가 메소드를 갖고 있는지 검사 &amp;lt;/summary&amp;gt;private static bool CheckDelegateHasMethod&amp;lt;DType&amp;gt;(DType @delegate, DType method) where DType : Delegate{    return @delegate?.GetInvocationList()            .Where(d =&amp;gt..."
  },
  
  {
    "title": "Menu Item(메뉴 아이템)",
    "url": "/posts/unity-editor-menu-item/",
    "categories": "Unity, Unity Editor",
    "tags": "unity, editor, csharp, menuitem",
    "date": "2021-03-12 20:10:00 +0900",
    





    "snippet": "메뉴 아이템 기본private const string MenuItemTitle = &quot;Window/Rito/Menu Item&quot;;private const int MenuItemPriority = 123;[MenuItem(MenuItemTitle)]private static void MenuItem1(){    // ..}[MenuItem(MenuItemTitle, false, MenuItemPriority)]private static void MenuItem2(){    // ..}활성화/비활성화 설정privat..."
  },
  
  {
    "title": "Scripting Define Symbol 스크립트로 제어하기",
    "url": "/posts/unity-editor-define-symbol/",
    "categories": "Unity, Unity Editor",
    "tags": "unity, editor, csharp, define, symbol",
    "date": "2021-03-12 18:28:00 +0900",
    





    "snippet": "Scripting Define Symbol?      스크립트에서 #define으로 정의하듯, 프로젝트 전체에서 정의하여 사용할 수 있는 심볼        Project Settings - Player - Other Settings - Scripting Define Symbols        빌드 타겟마다 달라진다.        유니티 에디터 스크립팅을 통해 확인, 추가, 제거할 수 있다.  Source Codeusing System.Text.RegularExpressions;using UnityEditor;public sta..."
  },
  
  {
    "title": "스크립트(.cs), 어셈블리(.dll, .exe) 경로 참조",
    "url": "/posts/memo-cs-get-path/",
    "categories": "Memo, Csharp Memo",
    "tags": "csharp, path",
    "date": "2021-03-12 18:10:00 +0900",
    





    "snippet": "스크립트 경로public static void GetScriptPath([System.Runtime.CompilerServices.CallerFilePath] string filePath = &quot;&quot;){    // 1. Script(.cs) Path    _ = filePath;    // 2. Folder Path    string folderPath = System.IO.Path.GetDirectoryName(filePath);    // 3. Specific Root Folder Path    string ..."
  },
  
  {
    "title": "컴포넌트의 인스펙터 내 순서를 맨 위로 올리기",
    "url": "/posts/unity-editor-component-on-top/",
    "categories": "Unity, Unity Editor",
    "tags": "unity, editor, csharp",
    "date": "2021-03-12 04:04:00 +0900",
    





    "snippet": "bool flag = true;while (flag){    flag = UnityEditorInternal.ComponentUtility.MoveComponentUp(this);    // 맨 위로 올라갔을 경우 false 리턴}"
  },
  
  {
    "title": "메소드 호출과 메소드, 람다식 콜백 호출의 오버헤드",
    "url": "/posts/unity-memo-callback-overhead/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp",
    "date": "2021-03-11 18:11:00 +0900",
    





    "snippet": "테스트 대상[1] 문장(계산식)private static void TestInline(){    for (int i = 0; i &amp;lt; count; i++)    {        _ = Math.Round(2.3f) * Math.Sin(2.5f);        _ = Math.Floor(4.4f) * Math.Log10(6.34f);        _ = Math.Acos(5.5f) * Math.Tan(34.4f);    }}[2] 동일한 문장들을 각각 메소드화하여 호출private static void MethodA(..."
  },
  
  {
    "title": "플레이모드 상태 변경에 따른 동작 구현하기",
    "url": "/posts/unity-editor-playmode-state-change/",
    "categories": "Unity, Unity Editor",
    "tags": "unity, editor, csharp",
    "date": "2021-03-11 03:33:00 +0900",
    





    "snippet": "#if UNITY_EDITORusing System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEditor;namespace Rito{    [InitializeOnLoad]    public class PlayModeStateChangeHandler    {        public static event Action OnExitEditMode;        public static event Action OnEn..."
  },
  
  {
    "title": "Transform Custom Editor(트랜스폼 커스텀 에디터)",
    "url": "/posts/unity-editor-plugin-transform-custom-editor/",
    "categories": "Unity, Unity Editor Plugins",
    "tags": "unity, csharp, plugin, transform",
    "date": "2021-03-10 15:15:00 +0900",
    





    "snippet": "Note      트랜스폼의 커스텀 에디터        트랜스폼의 로컬 정보 뿐만 아니라, 글로벌 위치, 회전, 크기 값을 확인 및 조작할 수 있다.        총 8개의 리셋 버튼으로 트랜스폼의 로컬, 글로벌 값들을 초기화할 수 있다.  Preview  Global - Reset 버튼을 누를 경우  Global Position - Reset 버튼을 누를 경우  Global Rotation - Reset 버튼을 누를 경우  Global Scale - Reset 버튼을 누를 경우Download  CustomTransformEd..."
  },
  
  {
    "title": "Weighted Random Picker (가중치 랜덤 뽑기)",
    "url": "/posts/unity-toy-weighted-random-picker/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin, random",
    "date": "2021-03-09 03:22:00 +0900",
    





    "snippet": "Note      게임에서 각각 n% 확률로 존재하는 요소들의 뽑기를 수행할 때, 단순히 Random.Range()를 통해서는 계산할 수 없다.        이 때, ‘가중치 랜덤 뽑기’를 이용한다.        제네릭을 활용하여, 아이템들과 가중치의 목록을 넣으면 간단히 뽑기를 수행할 수 있도록 작성하였다.        아이템은 중복되게 추가할 수 없다.        내부적으로 System.Random을 사용한다.  가중치 랜덤 뽑기?      각각의 요소에 가중치(Weight)를 부여한다.        뽑기를 수행했을 때 ..."
  },
  
  {
    "title": "Regex (정규표현식)",
    "url": "/posts/memo-cs-regex/",
    "categories": "Memo, Csharp Memo",
    "tags": "csharp, string, regex",
    "date": "2021-03-08 17:42:00 +0900",
    





    "snippet": "MemoUsingusing System.Text.RegularExpressions;정확한 단어 찾기string input = &quot;AA,AAA,AAAA&quot;;string pattern = @&quot;\\bAA\\b&quot;; // 단어 경계를 \\b로 구분string result = Regex.Match(input, pattern).Value;스트링의 오른쪽에서부터 탐색Regex.Match(string, pattern, RegexOptions.RightToLeft)찾은 문자열 주변을 변경 (그룹 사용)string st..."
  },
  
  {
    "title": "컴파일, 게임 시작 시 실행되는 애트리뷰트 정리",
    "url": "/posts/unity-editor-init-events/",
    "categories": "Unity, Unity Editor",
    "tags": "unity, editor, csharp",
    "date": "2021-03-08 03:03:00 +0900",
    





    "snippet": "공통 특징      클래스 또는 메소드 상단에 애트리뷰트를 명시한다.        컴포넌트로 넣지 않고, 스크립트로만 존재해도 실행된다.        정적 클래스나 상속에 관계 없이 동작한다.        메소드 애트리뷰트는 정적 메소드에만 동작한다.  컴파일, 플레이모드 진입 시 실행Note  EditorApplication.isPlaying으로 현재 에디터 모드를 구분하여 활용할 수 있다.[InitializeOnLoad]      using UnityEditor;        클래스 애트리뷰트        정적 생성자가 호..."
  },
  
  {
    "title": "Scene Auto Saver (현재 씬 자동 저장)",
    "url": "/posts/unity-editor-plugin-scene-auto-saver/",
    "categories": "Unity, Unity Editor Plugins",
    "tags": "unity, csharp, plugin, autosave",
    "date": "2021-03-08 02:22:00 +0900",
    





    "snippet": "Note      일정 시간 주기로 현재 활성화된 씬을 자동 저장한다.        씬이 저장되지 않은 상태일 때만 타이머가 동작한다.  How To Use  스크립트 2개를 모두 다운로드 받아 유니티 프로젝트에 넣는다.      [Window] - [Rito] - [Scene Auto Saver]를 통해 윈도우를 연다.    On에 체크/해제하여 기능 실행 여부를 설정할 수 있다.  Show Log 옵션으로 자동 저장 시 로그 출력 여부를 설정할 수 있다.  Save Cycle 옵션으로 저장 주기를 설정할 수 있다. (기본 ..."
  },
  
  {
    "title": "Custom Editor Window(커스텀 에디터 윈도우)",
    "url": "/posts/unity-editor-custom-editor-window/",
    "categories": "Unity, Unity Editor",
    "tags": "unity, editor, csharp, editorwindow",
    "date": "2021-03-08 00:00:00 +0900",
    





    "snippet": "Note  에디터 윈도우를 직접 만들어 사용할 수 있다.PreviewSource Code Example#if UNITY_EDITORusing UnityEngine;using UnityEditor;public class ExampleWindow : EditorWindow{    private bool boolValue;    private float floatValue;    private Vector3 vector3Value;    [MenuItem(&quot;Window/Rito/Example Window&quot;)] //..."
  },
  
  {
    "title": "bool 타입 필드를 인스펙터에서 버튼처럼 사용하기",
    "url": "/posts/unity-memo-bool-as-a-button/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp, button",
    "date": "2021-03-07 01:33:00 +0900",
    





    "snippet": "인스펙터의 버튼컴포넌트의 인스펙터에서 버튼을 사용하고 싶을 때가 있다.예를 들면 플레이 모드로 진입하지 않고 에디터 모드에서 메소드를 바로 호출 하고 싶을 때.그리고 실제로 커스텀 에디터를 이용해 버튼을 만들 수도 있다.하지만 잠깐 테스트용으로 쓰려는데 스크립트 하나 더 만들고, 커스텀 에디터 선언하고, …심지어 에디터 GUI좀 쓰려면 EditorGUI, EditorUtility, EditorGUILayout, GUIUtility, GUILayout, … 뭐가 이렇게 다양하고 헷갈리게 만들어 놨는지..어쨌든 커스텀 에디터 만들..."
  },
  
  {
    "title": "UniRx (Reactive Extensions for Unity)",
    "url": "/posts/unity-study-unirx/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp, unirx",
    "date": "2021-03-06 20:14:00 +0900",
    





    "snippet": "개요Rx란?  Reactive Extensions  절차적 프로그래밍에서 다루기 쉽지 않은 비동기 프로그래밍을 손쉽게 다루기 위한 패러다임  .NET에도 다양한 언어로 구현되어 있다.  비동기 데이터 스트림을 중심으로 동작한다.  스트림 내의 데이터에 변화가 발생했을 때 반응형으로 기능이 동작하는 방식을 사용한다.  시간을 상당히 간단하게 취급할 수 있게 된다.  Observer Pattern + Iterator Pattern + Functional ProgrammingUniRx  .NET의 Rx를 유니티에서 사용할 수 없다는..."
  },
  
  {
    "title": "Model Pivot Resetter (모델 임포트 시 피벗 자동 초기화)",
    "url": "/posts/unity-editor-plugin-model-pivot-resetter/",
    "categories": "Unity, Unity Editor Plugins",
    "tags": "unity, csharp, plugin, model, pivot, postprocessor",
    "date": "2021-03-05 22:22:00 +0900",
    





    "snippet": "Note  모델링 파일을 유니티로 가져올 때 동작하는 애셋포스트프로세서  모델의 회전과 위치를 리셋한다.  모델의 정점 위치를 모두 계산하여, 피벗이 모델의 중심 하단으로 오게 한다.How To Use      스크립트를 유니티 프로젝트 내에 넣는다.        [Window] - [Rito] - [Model Pivot Resetter] - [Activated]를 체크한다.          체크 해제되어 있을 경우 동작하지 않는다.        임포트 할 때마다 대화상자를 통해 선택하게 하려면[Window] - [Rito] ..."
  },
  
  {
    "title": "무한 루프를 방지하는 작은 습관",
    "url": "/posts/unity-memo-prevent-infinite-loop/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp",
    "date": "2021-03-05 04:00:00 +0900",
    





    "snippet": "Note      유니티 엔진에서 무한루프가 발생하면 에디터가 그대로 뻗어버린다.        따라서 혹시나 무한루프가 될 가능성이 있는 코드를 인지했다면, 간단한 체크 로직을 넣어주는 것이 좋다.  while( /* condition */ ){    // codes..}이런 코드에서, 간단히 다음처럼 추가해준다.int loopNum = 0;while( /* condition */ ){    // codes..    if(loopNum++ &amp;gt; 10000)        throw new Exception(&quot;..."
  },
  
  {
    "title": "유니티 쉐이더 프로퍼티 애트리뷰트 모음",
    "url": "/posts/unity-shader-property-attributes/",
    "categories": "Unity Shader, Shader Study",
    "tags": "unity, csharp, shader, enum, toggle, multicompile",
    "date": "2021-03-04 21:58:00 +0900",
    





    "snippet": "Space[Space(10)]  단순 공백을 크기로 지정한다.Header[Header(Header Text)]  헤더 문자열을 지정한다.  큰따옴표로 묶지 않아야 한다.Toggle[Toggle] _MyToggle (&quot;My Toggle&quot;, Float) = 1.0  체크할 경우 1.0, 체크 해제할 경우 0.0으로 값을 받을 수 있다.IntRange[IntRange] _Value(&quot;Value&quot;, Range(0, 100)) = 50  Range를 정수로 지정할 수 있게 한다.PowerSlider[..."
  },
  
  {
    "title": "Depth Texture Renderer (Z-Buffer 렌더러)",
    "url": "/posts/unity-toy-depth-texture-renderer/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2021-03-03 19:08:00 +0900",
    





    "snippet": "Note      현재 메인 카메라의 뎁스 텍스쳐를 화면에 렌더링한다.        각 쉐이더의 ZWrite 여부에 관계 없이 모두 렌더링하는 단점이 있다.        렌더 큐 값이 2500(Skybox) 이하인 오브젝트들만 인식한다.  How to Use      DepthRenderer.cs 스크립트를 메인 카메라에 넣는다.        enabled를 체크/해제하여 화면에 렌더 텍스쳐를 보여줄지 여부를 결정할 수 있다.  Preview  원래 화면  뎁스 텍스쳐 렌더링Download  DepthRenderer.zipSo..."
  },
  
  {
    "title": "파티클 시스템 예제 - 06 - Blue Portal [TODO]",
    "url": "/posts/unity-particle-system-example-06-blue-portal/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-03-03 03:34:00 +0900",
    





    "snippet": "Preview"
  },
  
  {
    "title": "파티클 시스템 예제 - 05 - Dr. Strange Portal",
    "url": "/posts/unity-particle-system-example-05-dr-strange-portal/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-03-03 03:33:00 +0900",
    





    "snippet": "목차  목표  준비물  1. 계층형 파티클 시스템  2. Portal 이펙트 만들기  3. Spiral A 이펙트 만들기  4. Spiral B 이펙트 만들기  5. Burst 이펙트 만들기  6. 완성Preview목표      계층형 파티클 시스템 만들기        닥터 스트레인지 포탈 이펙트 완성하기  준비물  글로우 모양의 동그란 텍스쳐와 Additive 마테리얼1. 계층형 파티클 시스템지금까지는 이펙트 하나 당 파티클 시스템을 하나씩만 사용해서 제작했다.하지만 대부분의 이펙트는 실제로 하나의 파티클 시스템으로 표현하기..."
  },
  
  {
    "title": "Projectile Shooter (투사체 발사 컴포넌트)",
    "url": "/posts/unity-toy-projectile-shooter/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2021-03-02 03:28:00 +0900",
    





    "snippet": "Note      마우스 클릭 시 등록된 게임오브젝트를 생성하여, 지정된 방향으로 발사하는 스크립트        생성된 게임오브젝트는 카메라의 시선에 수직인 평면 방향으로 이동하며, 수명이 다하면 제거된다.        오브젝트 풀링이 적용된다.  How To Use      빈 게임오브젝트를 생성하고, ParticleShooter를 컴포넌트로 넣는다.        발사할 대상 게임오브젝트를 Particle Prefab 필드에 넣는다.        Direction으로 발사할 방향을 지정할 수 있다.        Life Ti..."
  },
  
  {
    "title": "Mouse Chaser (마우스 커서 추적 컴포넌트)",
    "url": "/posts/unity-toy-mouse-chaser/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2021-03-02 03:14:00 +0900",
    





    "snippet": "Note  게임오브젝트가 마우스 커서를 따라오게 하는 스크립트How To Use      마우스 커서를 따라오게 할 게임오브젝트에 컴포넌트로 넣는다.        Distance From Camera를 통해 카메라로부터의 거리를 지정할 수 있다.        Chasing Speed를 통해 마우스를 따라올 속도를 지정할 수 있다.  PreviewSource Code  https://github.com/rito15/Unity_Toys   .  using System.Collections;using System.Collection..."
  },
  
  {
    "title": "파티클 시스템 예제 - 04 - Fire Ball",
    "url": "/posts/unity-particle-system-example-04-fireball/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-03-02 03:03:00 +0900",
    





    "snippet": "목차  목표  준비물  1. 파티클 시스템 제작  2. 서브 이미터 설정  3. Projectile Shooter 적용  4. 결과Preview목표      Sub Emitters(서브 이미터) 모듈 이해하기        파이어볼 이펙트 만들기  준비물  글로우 모양의 동그란 텍스쳐와 Additive 마테리얼      파이어볼을 발사할 수 있게 해줄 스크립트        아래 소스코드를 다운로드하여 프로젝트 내에 넣어둔다.        ProjectileShooter.zip     Source Code  using System..."
  },
  
  {
    "title": "파티클 시스템 예제 - 03 - Firefly",
    "url": "/posts/unity-particle-system-example-03-firefly/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-03-01 22:57:00 +0900",
    





    "snippet": "Preview목표      Light 모듈, Collision 모듈 간단히 사용해보고 이해하기        반딧불이 이펙트 만들기  Firefly Effect마테리얼 준비      Addtive        작은 Glow 모양의 텍스쳐  씬 준비  새로운 씬 생성 (Project 우클릭 - Create - Scene)메인 카메라(Main Camera) 설정  Clear Flags : Solid Color  Background : 검정(RGBA 0, 0, 0, 0)으로 설정파티클 시스템 생성      하이라키 우클릭 - Effe..."
  },
  
  {
    "title": "파티클 시스템 예제 - 02 - Mouse Chaser",
    "url": "/posts/unity-particle-system-example-02-mouse-chaser/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-03-01 21:07:00 +0900",
    





    "snippet": "목차  목표  준비물  1. 기본 준비  2. Heart  3. TwinklePreview기본HeartTwinkle목표  실시간으로 마우스를 따라다니는 예쁜 이펙트 만들기준비물      원하는 모양의 파티클 텍스쳐 (예제에서는 Heart, Twinkle), Additive 마테리얼        파티클이 마우스를 따라오게 만드는 스크립트        아래 소스코드를 다운로드하여 프로젝트 내에 넣어둔다.        MouseChaser.zip     Source Code  using System.Collections;using ..."
  },
  
  {
    "title": "오클루전 컬링",
    "url": "/posts/unity-opt-occlusion-culling/",
    "categories": "Unity, Unity Optimization",
    "tags": "unity, csharp, optimization, performance",
    "date": "2021-03-01 01:40:00 +0900",
    





    "snippet": "프러스텀 컬링 (Frustum Culling)      카메라의 뷰 프러스텀(View Frustum) 영역 밖의 오브젝트들은 렌더링하지 않는 것        따로 설정하지 않아도 유니티 내에서 기본적으로 적용된다.  그냥 이렇게 두어도실제로 이렇게 컬링된다.GIF오클루전 컬링 (Occlusion Culling)      다른 오브젝트에 가려진 오브젝트들은 렌더링하지 않는 것        [Window] - [Rendering] - [Occlusion Culling]        Occlusion Culling 윈도우를 통해 설..."
  },
  
  {
    "title": "UI 위에 게임오브젝트 띄우기",
    "url": "/posts/unity-memo-gameobject-over-ui/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp, ui",
    "date": "2021-02-28 22:30:00 +0900",
    





    "snippet": "Preview  Green : Default  Red : Over UI1. Standard Rendering Pipeline   .  [1] 레이어 준비      [Over UI] 레이어를 만든다.      [2] Over UI 카메라 준비            카메라를 하나 더 만들고, Audio Listener를 제거한다.              메인 카메라와 함께 움직이려면 메인 카메라의 자식으로 둔다.        Over UI 카메라의 Camera 컴포넌트 설정              Clear Flags : Depth..."
  },
  
  {
    "title": "Free Look Camera (자유 시점 카메라)",
    "url": "/posts/unity-toy-free-look-camera/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2021-02-28 17:45:00 +0900",
    





    "snippet": "Note  자유롭게 회전, 이동이 가능한 자유 시점 카메라How To Use  카메라가 존재하는 게임오브젝트에 FreeLookCamera 컴포넌트를 추가한다.  게임 시작 후, Left Alt 키를 눌러 커서가 사라지도록 한다.  WASD 키로 카메라를 움직이며, 마우스 이동을 통해 카메라를 회전시킬 수 있다.PreviewDownload  FreeLookCamera.zipSource Code  https://github.com/rito15/Unity_Toys   .  using System;using System.Collect..."
  },
  
  {
    "title": "Enum 관련 메모",
    "url": "/posts/memo-cs-enum/",
    "categories": "Memo, Csharp Memo",
    "tags": "csharp, enum",
    "date": "2021-02-28 04:00:00 +0900",
    





    "snippet": "enum의 모든 요소를 배열로 가져오기enum MyEnum { A, B }Array allValues = Enum.GetValues(typeof(MyEnum));enum의 마지막 요소 가져오기// System.Linq;MyEnum last =     Enum.GetValues(typeof(EditorWindowType)).Cast&amp;lt;MyEnum&amp;gt;().Last();"
  },
  
  {
    "title": "Undo",
    "url": "/posts/unity-editor-undo/",
    "categories": "Unity, Unity Editor",
    "tags": "unity, csharp, editor",
    "date": "2021-02-28 01:52:00 +0900",
    





    "snippet": "/* 1. 다른 동작과 연계 */// 이름 변경, 기타 등등 수행하기 직전에 호출// 주의 : 게임오브젝트의 변경사항은 트랜스폼이 아니라 게임오브젝트를 넣어야 함Undo.RecordObject(target, &quot;Action&quot;);// 오브젝트 생성 이후에 호출Undo.RegisterCreatedObjectUndo(targetGameObject, &quot;Create New&quot;);/* 2. Undo를 통해 직접 수행 */// 컴포넌트 추가Undo.AddComponent&amp;lt;ComponentType..."
  },
  
  {
    "title": "물리 기반 캐릭터 이동 구현하기",
    "url": "/posts/unity-physics-based-movement/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp, physics, movement",
    "date": "2021-02-25 04:11:00 +0900",
    





    "snippet": "목차  1. 서론  2. 이동 스크립트 분리  3. 요구사항 정리  4. 필드, 프로퍼티 정의  5. 상태 검사 구현  6. 중력 적용  7. 이동 구현  8. 물리 상호작용  9. 구현 결과  10. 소스 코드서론유니티에서 캐릭터 이동을 구현하기 위한 방법들은 다양하다.  Transform  Rigidbody  Character Controller  NavMeshAgent  …트랜스폼, 내비메시 에이전트를 통해 이동을 구현하면 물리 상호작용을 할 수 없고,캐릭터 컨트롤러를 통해 구현해도 다른 콜라이더에 상호작용을 하려면 콜라..."
  },
  
  {
    "title": "파티클 시스템 예제 - 01",
    "url": "/posts/unity-particle-system-example-01/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-02-23 21:15:00 +0900",
    





    "snippet": "Preview1. Twinkles2. Falling Snowflakes3. Rising Hearts목차  1. Twinkles  2. Falling Snowflakes  3. Rising HeartsTwinkles      우선 반짝이는 모양의 텍스쳐와 Additive 마테리얼을 준비한다.    (텍스쳐 및 마테리얼 준비는 설명을 생략하며, 파티클 시스템 게임오브젝트를 생성한 상태라고 가정한다.)  Transform      파티클 시스템 게임오브젝트를 최초로 생성하면 Rotation X 값이 -90으로 설정되어 있다.    ..."
  },
  
  {
    "title": "파티클 시스템 기초 - 05 - 주요 모듈",
    "url": "/posts/unity-particle-system-tutorial-05/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-02-22 22:00:00 +0900",
    





    "snippet": "목차  1. Emission  2. Shape  3. Velocity over Lifetime  4. Color over Lifetime  5. Size over Lifetime  6. Rotation over Lifetime  7. Texture Sheet Animation  References개요  메인 모듈 외의 모듈 중에서 주로 사용되는 모듈들에 대해 소개한다.Emission  파티클의 생성 타이밍과 개수에 관여한다.Rate over Time      초당 생성할 개수를 지정한다.        예시 : [1] vs [4..."
  },
  
  {
    "title": "파티클 시스템 기초 - 04 - 메인 모듈",
    "url": "/posts/unity-particle-system-tutorial-04/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-02-22 18:04:00 +0900",
    





    "snippet": "목차  1. Duration, Looping, Prewarm  2. Start Delay  3. Start Lifetime  4. Start Speed      5. Start Size    6. Start Rotation  7. Flip Rotation  8. Start Color  9. Gravity Modifier      10. Simulation Space    11. Simulation Speed  12. Delta Time  13. Scaling Mode  14. Play On Awake      15. Emitt..."
  },
  
  {
    "title": "파티클 시스템 기초 - 03 - 값의 지정 방법",
    "url": "/posts/unity-particle-system-tutorial-03/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-02-22 17:04:00 +0900",
    





    "snippet": "목차  1. 값(Value)          Constant      Curve      Random Between Two Constants      Random Between Two Curves        2. 색상(Color)          Color      Gradient      Random Between Two Colors      Random Between Two Gradients      Random Color      1. 값(Value)[1] Constant      기본 설정        고정된 상수 값..."
  },
  
  {
    "title": "파티클 시스템 기초 - 02 - 파티클 속성 기초",
    "url": "/posts/unity-particle-system-tutorial-02/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-02-22 15:55:00 +0900",
    





    "snippet": "목차      1. 개요    2. 메인 모듈          Start Lifetime      Start Speed      Start Size      Start Color      Gravity Modifier            3. Emission        4. Shape    5. Renderer개요      파티클 시스템에는 수많은 모듈과 그 속성들이 존재한다.        Duration ~ Ring Buffer Mode 부분은 메인 모듈이라고 부르며 반드시 사용되는 속성들이 존재한다.        Emis..."
  },
  
  {
    "title": "파티클 시스템 기초 - 01 - 파티클 시스템 만들기",
    "url": "/posts/unity-particle-system-tutorial-01/",
    "categories": "Unity, Unity Particle System",
    "tags": "unity, csharp, particle",
    "date": "2021-02-22 15:04:00 +0900",
    





    "snippet": "1. 파티클 시스템 개요      주로 유니티 내에서 VFX(Visual Effect)를 표현하는데 사용한다.        이름이 ‘파티클’이 아니고 ‘파티클 시스템’인 이유는 마치 시스템처럼 하나의 파티클 시스템이 여러 개의 작은 파티클들을 생성 및 관리하기 때문이다.        기본적으로 빈 게임오브젝트에 Particle System 컴포넌트가 추가된 형태로 사용된다.  2. 파티클 시스템 만들기  하이라키 - 우클릭 - Effects - Particle System을 통해 파티클 시스템 게임오브젝트를 생성할 수 있다. ..."
  },
  
  {
    "title": "깃 로컬 리포지토리 초기 세팅하기",
    "url": "/posts/memo-git-local-repo-initialization/",
    "categories": "Memo",
    "tags": "memo, git, github",
    "date": "2021-02-21 00:00:00 +0900",
    





    "snippet": "조건      깃헙 리포지토리를 새로 생성하는 경우        아무런 파일도 만들지 않고 순수한 상태로 리포지토리를 만든 경우 1번에 해당하며,        Readme.md, LICENCE, .gitignore 등의 파일을 만들었다면 2번에 해당한다.  1. 깃헙에 빈 리포지토리를 생성한 경우  로컬 리포지토리로 사용할 디렉토리에는 다른 파일들 존재한다고 가정한다.깃 로컬 리포지토리로 사용하겠다고 선언한다. (.git 폴더 생성)git init업로드할 파일들을 등록한다.git add .커밋을 등록한다.git commit -..."
  },
  
  {
    "title": "Scriptable Object(스크립터블 오브젝트)",
    "url": "/posts/unity-editor-scriptable-object/",
    "categories": "Unity, Unity Editor",
    "tags": "unity, csharp, scriptableobject",
    "date": "2021-02-20 02:02:00 +0900",
    





    "snippet": "형태[CreateAssetMenu(fileName = &quot;TestSO&quot;, menuName = &quot;ScriptableObjects/Test&quot;, order = 1)]public class TestScriptableObject : ScriptableObject{    public int value = 0;}  상단의 메뉴에서 [Assets] - [Create] - [ScriptableObjects] - [Test] 를 통해 생성 할 수 있게 된다.  프로젝트 윈도우에서 우클릭하면 동일한 메뉴를 확인할..."
  },
  
  {
    "title": "OpenGL 공부 - 23 - Mesh, GameObject Class, Multiple Objects",
    "url": "/posts/opengl-study-23/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-19 16:27:00 +0900",
    





    "snippet": "목표  프래그먼트 쉐이더 수정  Mesh 클래스 작성  GameObject 클래스 작성  여러 개의 게임오브젝트 렌더링1. 프래그먼트 쉐이더 수정      각각의 계산이 독립적이고 순차적으로 수행될 수 있도록 변경한다.        바뀐 구조                  1. 색상 계산(텍스쳐, 버텍스 컬러 등)                    2. 라이트 계산(디퓨즈, 스페큘러, 앰비언트 독립적으로)                    3. 최종 색상 조립(디퓨즈, 스페큘러, 앰비언트 독립적)            소스코드/..."
  },
  
  {
    "title": "레이캐스트 성능 테스트",
    "url": "/posts/unity-memo-raycast-overhead/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp, raycast, performance",
    "date": "2021-02-19 16:18:00 +0900",
    





    "snippet": "조건고정  레이캐스트 시작점  레이캐스트 방향  반복 횟수 : 10만 회변동  레이캐스트 종류  레이어마스크  레이캐스트 거리  레이캐스트 도형 크기(Sphere, Box)  레이캐스트 히트 여부결과결론성능에 영향을 주는 것  레이캐스트 종류  레이캐스트 히트 여부성능에 영향을 주지 않는 것  레이어마스크  레이캐스트 거리  레이캐스트 도형 크기(Sphere, Box)추가 - Rigidbody.SweepTestSweepTest ?  콜라이더 표면으로부터 지정한 방향으로 일정 거리 이내에 다른 콜라이더가 존재하는지 검사하는 것검..."
  },
  
  {
    "title": "커스텀 애트리뷰트",
    "url": "/posts/memo-cs-custom-attribute/",
    "categories": "Memo, Csharp Memo",
    "tags": "csharp, custom, attribute",
    "date": "2021-02-19 03:55:00 +0900",
    





    "snippet": "필요 네임스페이스using System;using System.Linq;1. 애트리뷰트 클래스 작성[System.AttributeUsage(System.AttributeTargets.Method)]public class CustomAttribute : System.Attribute{    public string Title { get; }    public CustomAttribute(string t) =&amp;gt; Title = t;}2. 타겟 메소드에 애트리뷰트 장착public class TargetClass{    [..."
  },
  
  {
    "title": "Reflection(리플렉션)",
    "url": "/posts/memo-cs-reflection/",
    "categories": "Memo, Csharp Memo",
    "tags": "csharp, reflection",
    "date": "2021-02-19 03:50:00 +0900",
    





    "snippet": "필요 네임스페이스using System;using System.Reflection;특정 클래스 타입 가져오기Type targetType = Type.GetType(&quot;클래스명&quot;);네임스페이스 내에 있는 클래스 타입 가져오기Type targetType = Type.GetType(&quot;네임스페이스명.클래스명&quot;);다른 어셈블리(예: DLL) 내에 있는 클래스 타입 가져오기Type targetType = Type.GetType(&quot;네임스페이스명.클래스명, 어셈블리명&quot;);// 어셈블리명 예..."
  },
  
  {
    "title": "OpenGL 공부 - 22 - Light Class",
    "url": "/posts/opengl-study-22/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-18 15:13:00 +0900",
    





    "snippet": "목표  DirectionalLight, PointLight 클래스 작성  프래그먼트 쉐이더에서 각 라이트에 맞는 계산 수행1. Directional Light  위치에 관계 없이 방향으로만 작용하는 직광 만들기DirectionalLight 클래스 작성class DirectionalLight{private:    glm::vec3 direction; // 빛의 방향과 반전된 L 벡터 방향    glm::vec3 color;    float intensity;public:    DirectionalLight(const glm::v..."
  },
  
  {
    "title": "유니티 에디터 관련 유용한 팁 모음",
    "url": "/posts/unity-editor-api/",
    "categories": "Unity, Unity Editor",
    "tags": "unity, csharp, editor",
    "date": "2021-02-18 01:50:00 +0900",
    





    "snippet": "   다이얼로그 창 띄우기  bool res1 = EditorUtility.DisplayDialog(&quot;Title&quot;, &quot;Message&quot;, &quot;OK&quot;);bool res2 = EditorUtility.DisplayDialog(&quot;Title&quot;, &quot;Message&quot;, &quot;OK&quot;, &quot;Cancel&quot;);     우클릭 MenuItem 메소드 중복 호출 방지하기            게임오브젝트를 다중 선택하고 우클릭 메뉴를 통..."
  },
  
  {
    "title": "OpenGL 공부 - 21 - Material Class",
    "url": "/posts/opengl-study-21/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-17 22:43:00 +0900",
    





    "snippet": "목표  Material 클래스 작성공부 내용  오브젝트에 적용할 색상과 텍스쳐들을 Material 클래스로 래핑하여 쉐이더에 전달한다.Fragment 쉐이더 수정#version 440#define saturate(x) clamp(x, 0., 1.)struct Material{    vec3 ambient;    vec3 diffuse;    vec3 specular;    sampler2D diffuseMap;};in vec3 vs_position;in vec3 vs_color;in vec2 vs_texcoord;in vec3..."
  },
  
  {
    "title": "게임 서버 엔진",
    "url": "/posts/memo-game-server-engines/",
    "categories": "Memo",
    "tags": "server, engine, gbaas",
    "date": "2021-02-17 21:40:00 +0900",
    





    "snippet": "게임 서버 엔진  완성된 형태의 게임 서버 기능 제공설치형(On-premise, Self-hosted)  ProudNet(국내)          개인 무료 라이센스 제공      마비노기 영웅전, 세븐나이츠 등 190여개 프로젝트에 사용      실시간 대규모 RPG, FPS에 적합      https://www.youtube.com/watch?v=bYB1_qGMRS8&amp;amp;list=PLHmjKJAyeNIdlPra2-dRBhuvqAlun_ir-      http://lab.gamecodi.com/board/zboard..."
  },
  
  {
    "title": "Serverless, BaaS, FaaS",
    "url": "/posts/memo-serverless-baas-faas/",
    "categories": "Memo",
    "tags": "cloud, serverless, baas, faas",
    "date": "2021-02-17 20:40:00 +0900",
    





    "snippet": "애플리케이션 개발 패러다임 변화모놀리스(Monolith)  소프트웨어의 모든 구성요소가 한 프로젝트에 통합된 형태  중앙 집중적 구조  변경이 발생할 경우 전체 애플리케이션을 재배포, 재시작해야 한다.  부분의 장애가 전체 서비스의 장애로 이어지는 경우가 발생한다.  서비스가 커지면 커질수록 전체 시스템 구조 파악이 어려워진다.마이크로 서비스(Micro Service Architecture, MSA)  모놀리스의 단점을 보완하기 위한 구조  애플리케이션을 서비스들의 결합으로 구성한다.  각 서비스는 크기가 작을 뿐, 하나의 모..."
  },
  
  {
    "title": "클라우드 컴퓨팅 3대 서비스",
    "url": "/posts/memo-cloud-computing-services/",
    "categories": "Memo",
    "tags": "cloud, iaas, paas, saas",
    "date": "2021-02-17 20:40:00 +0900",
    





    "snippet": "IaaS, PaaS, SaaS구분  기업과 클라우드 서비스 제공자간의 관리 영역 분할 정도에 따라 구분할 수 있다.선택 예시  IaaS : 인력이 충분하고 자원 및 인프라만 대여하고 싶은 경우  PaaS : 이미 만들어진 런타임, DB 등의 API를 사용하여 본 개발에만 집중하고 싶은 경우  SaaS : 특수목적의 소프트웨어들을 바로 사용하고 싶은 경우IaaS(Infrastructure-as-a-Service)특징      서버 자원, 네트워크, 전력, 스토리지 등의 인프라를 가상화하여 제공한다.        사용한 만큼 지불..."
  },
  
  {
    "title": "매개변수 한정자 ref, in의 성능",
    "url": "/posts/memo-cs-ref-in-performance/",
    "categories": "Memo, Csharp Memo",
    "tags": "csharp, performance",
    "date": "2021-02-16 23:20:00 +0900",
    





    "snippet": "목표  값타입을 매개변수로 전달할 때 매개변수 한정자 사용에 따른 성능 알아보기(string은 참조타입이지만 매개변수로 전달하면 복제되므로 함께 테스트)테스트 대상public struct StructA{    public long a,b,c,d,e,f,g;    public StructA(long value)    {        a = b = c = d = e = f = g = value;    }}public readonly struct StructB{    public readonly long a,b,c,d,e,f,g; ..."
  },
  
  {
    "title": "OpenGL 공부 - 20 - Texture Class",
    "url": "/posts/opengl-study-20/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-16 22:22:00 +0900",
    





    "snippet": "목표  텍스쳐 클래스화하기텍스쳐 클래스 작성기존에 메소드화하여 사용하던 텍스쳐를 클래스화하려고 한다.function.hpp 파일에 LoadTextureImage() 메소드에 작성했던 내용을 클래스로 옮겨 작성한다.class Texture{private:    GLuint id;    GLenum type;    int width;    int height;public:    Texture(const char* fileName, GLenum type);    ~Texture();    inline const GLuint&amp;..."
  },
  
  {
    "title": "쉐이더그래프로 물 쉐이더 만들기 [작성중]",
    "url": "/posts/shadergraph-water/",
    "categories": "Unity Shader, URP Shader Study",
    "tags": "unity, csharp, shader, urp",
    "date": "2021-02-16 03:00:00 +0900",
    





    "snippet": "Preview1. 단순 색상2. 큐브맵 매핑References  https://www.youtube.com/watch?v=gRq-IdShxpU&amp;amp;ab_channel=UnityDownload  2021_0214_Water.zip"
  },
  
  {
    "title": "URP에서 쉐이더 코딩하기 [작성 중]",
    "url": "/posts/unity-urp-shader-coding/",
    "categories": "Unity Shader, URP Shader Study",
    "tags": "unity, csharp, shader, urp",
    "date": "2021-02-15 18:07:00 +0900",
    





    "snippet": "기본 구조  Starting PointShader &quot;RitoURP/VertexFragmentStartPoint&quot;{    Properties    {        _MainTex (&quot;Main Map&quot;, 2D) = &quot;white&quot; {}        _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; {}    }    SubShader    {        Tags         {            &quot;RenderPip..."
  },
  
  {
    "title": "OpenGL 공부 - 19 - Shader, Transform Class",
    "url": "/posts/opengl-study-19/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-15 15:30:00 +0900",
    





    "snippet": "목표  쉐이더, 트랜스폼 클래스화하기1. 쉐이더의 클래스화shader.hpp 작성shader.hpp 파일에 Shader 클래스를 작성한다.기존에 functions.hpp와 main.cpp에서 사용하던 쉐이더 부분을 모두 Shader 클래스로 옮겨준다.// shader.hppclass Shader{private:    GLuint id;    GLuint CompileShader(const GLenum&amp;amp; shaderType, const char* fileDir);    void LinkProgram(const GL..."
  },
  
  {
    "title": "OpenGL 공부 - 18 - Specular, Rim Light",
    "url": "/posts/opengl-study-18/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-14 15:38:00 +0900",
    





    "snippet": "목표  Specular Lighting, Rim Lighting 적용공부 내용필요한 유니폼 변수 전달World View 벡터가 필요하므로, 이를 구하기 위한 카메라 위치를 전달해준다.// main.cppglUniform3fv(glGetUniformLocation(shaderProgram, &quot;cameraPos&quot;), 1, glm::value_ptr(camPos));프래그먼트 쉐이더우선 라이팅 계산을 위한 벡터들을 만들어준다.uniform vec3 lightPos0; // Main Light World Positi..."
  },
  
  {
    "title": "Custom Plane Mesh Generator",
    "url": "/posts/unity-toy-custom-plane-mesh-generator/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, mesh, plane",
    "date": "2021-02-14 03:06:00 +0900",
    





    "snippet": "Note  Plane을 원하는 너비, 해상도로 만들 수 있게 해주는 컴포넌트PreviewHow to Use  빈 게임오브젝트를 생성한다.  PlaneMeshGenerator 컴포넌트를 추가한다.  옵션을 설정하고 마테리얼을 인스펙터의 Material에 넣는다.  Generate 버튼을 누른다.Download  PlaneMeshGenerator.zipSource Code  https://github.com/rito15/Unity_Toys"
  },
  
  {
    "title": "물 쉐이더 만들기",
    "url": "/posts/water-shader/",
    "categories": "Unity Shader, Shader Study",
    "tags": "unity, csharp, shader, graphics, water",
    "date": "2021-02-13 19:24:00 +0900",
    





    "snippet": "목표  서피스 쉐이더로 물 쉐이더 만들기목차  1. 물 쉐이더 기초  2. 프레넬 공식 적용  3. 물 흐르게 하기  4. 스페큘러 적용  5. 파도 만들기  6. 투과율 제어하기  7. 최종 결과준비물  큐브맵 텍스쳐 기반 스카이박스  물 노멀맵 텍스쳐  물에 빠질 로봇물 쉐이더 기초메시는 유니티의 기본적인 Plane을 이용한다.노멀은 노멀맵을 넣어 적용하고, 간단히 float로 타일링이 가능하도록 _Tiling 프로퍼티를 추가한다.그리고 _Strength 프로퍼티를 통해 노멀의 강도를 조절할 수 있게 한다.Shader &q..."
  },
  
  {
    "title": "OpenGL 공부 - 17 - Ambient, Diffuse Lighting",
    "url": "/posts/opengl-study-17/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-13 15:32:00 +0900",
    





    "snippet": "목표  Ambient, Diffuse 라이팅 구현공부 내용버텍스에 노멀 정보 추가struct Vertex{    glm::vec3 position;    glm::vec3 color;    glm::vec2 texcoord;    glm::vec3 normal;};Vertex vertices[] ={    // Position                    // Color                     // TexCoord            // Normal                                 ..."
  },
  
  {
    "title": "1인칭, 3인칭 전환 가능한 캐릭터 제작하기",
    "url": "/posts/unity-fps-tps-character/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp, fps, tps, controller",
    "date": "2021-02-12 18:06:00 +0900",
    





    "snippet": "목차  1. 하이라키 구성  2. 스크립트 기초  3. 1인칭 이동, 회전  4. 3인칭 이동, 회전  5. 카메라 전환  6. 점프  7. 애니메이션 적용  8. 애니메이션 블렌딩  9. 카메라 전환 시 시점 방향 유지하기  10. 3인칭 카메라 줌 구현  11. 점프 버그 수정  12. 이동 스크립트 분리하기  13. 소스 코드하이라키 구성하기위와 같이 캐릭터의 하이라키를 구성한다.따로 지정하지 않는 이상,모든 게임오브젝트는 Position(0, 0, 0), Rotation(0, 0, 0), Scale(1, 1, 1)로 초..."
  },
  
  {
    "title": "쿨타임 아이콘 UI 만들기",
    "url": "/posts/unity-memo-cooldown-icon-ui/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp, ui, cooldown",
    "date": "2021-02-12 17:13:00 +0900",
    





    "snippet": "목표구현1. 하이라키 구성[1] Outline  Image 컴포넌트 : 원하는 모양의 스프라이트 사용, 아웃라인으로 지정할 색상 적용[2] Mask  RectTransform : Anchor Preset [stretch &amp;amp; stretch] 설정  Left, Top, Right, Bottom 4픽셀 설정  Image 컴포넌트 : Outline과 같은 스프라이트 사용  Mask 컴포넌트 : [Show Mask Graphic] 체크 해제[3] Icon  RectTransform : Anchor Preset [stret..."
  },
  
  {
    "title": "OpenGL 공부 - 16 - Transform, Input",
    "url": "/posts/opengl-study-16/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-12 15:11:00 +0900",
    





    "snippet": "목표  오브젝트 기본 트랜스폼 정의하기  키보드 입력 처리하기트랜스폼 정의트랜스폼의 3요소(위치, 회전, 크기)를 정의한다.glm::vec3 position(0.0f);glm::vec3 rotation(0.0f);glm::vec3 scale(1.0f);그리고 모델 행렬에 트랜스폼 연산을 모두 넣어준다.modelMatrix = glm::translate(modelMatrix, position);modelMatrix = glm::rotate(modelMatrix, glm::radians(rotation.x), glm::vec3(1..."
  },
  
  {
    "title": "ILSpy로 유니티 내부 구현 뜯어보기",
    "url": "/posts/unity-memo-ilspy/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp, ilspy",
    "date": "2021-02-12 05:32:00 +0900",
    





    "snippet": "다운로드  https://github.com/icsharpcode/ILSpy/releases  vsix를 받을 경우, 비주얼 스튜디오의 확장으로 추가하여 [도구] - [ILSpy]를 통해 바로 실행할 수 있다.사용법      ILSpy를 실행한다.        File - Open으로 대상 어셈블리(dll, exe 등)를 불러온다.        검색을 통해 원하는 클래스, 메소드 등을 빠르게 찾을 수 있다.  유니티 구현 뜯어보기C:\\Program Files\\유니티 버전\\Editor\\Data\\Managed\\UnityEngine..."
  },
  
  {
    "title": "텍스트 메쉬 프로(TMPro) 사용하기",
    "url": "/posts/unity-memo-textmeshpro/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp, ugui, ui, text, textmeshpro",
    "date": "2021-02-12 02:09:00 +0900",
    





    "snippet": "특징      SDF(Signed Distance Field)를 이용하여 UGUI 텍스트보다 외곽선을 더 깔끔하게 표현한다.        마테리얼을 이용하여 다양한 효과를 줄 수 있다.        UGUI 텍스트에 비해 성능이 좋다.        미리 고해상도의 Font Texture Atlas를 생성하여 사용하기 때문에 실시간으로 크기가 변경되어도 픽셀을 부드럽게 나타낼 수 있다.  폰트 애셋 생성하기1. 필요 리소스 임포트  [Window] - [TextMeshPro] - [Import Essential Resources..."
  },
  
  {
    "title": "OpenGL 공부 - 15 - View Projection Matrix",
    "url": "/posts/opengl-study-15/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-11 17:05:00 +0900",
    





    "snippet": "목표  View, Projection 행렬 만들고 적용하기공간 변환공간 변환 과정을 간단히 설명하면 다음과 같다.1. Model Transformation  Model -&amp;gt; World모델링의 피벗이 원점인 Local Space(Model Space 또는 Object Space)에 Model Matrix를 곱하면 월드의 특정 좌표가 원점인 World Space의 좌표로 변환된다.2. View Transformation  World -&amp;gt; View카메라의 위치, 방향을 정의한 뒤 World Space에 Vi..."
  },
  
  {
    "title": "OpenGL 공부 - 14 - Model Matrix",
    "url": "/posts/opengl-study-14/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-10 15:20:00 +0900",
    





    "snippet": "목표  Model Matrix에 대한 이해  이동, 회전, 크기 변경공부 내용공통glm의 모델 매트릭스를 선언하는 것으로 시작한다.glm::mat modelMatrix(1.0f);openGL의 Transformation은 기본적으로 4x4 행렬과 vec3로 이루어진다.4x4 행렬과 곱해지려면 벡터 또한 vec4여야 하므로, vec3를 전달하면 내부적으로 vec4(vec3, 1.)을 만들어 연산한다.변환행렬은 서로 곱하여 하나의 변환행렬로 사용할 수 있다.그런데 만약 이동행렬 뒤에 크기행렬을 곱하면 이동값 또한 크기가 변하기 때..."
  },
  
  {
    "title": "유니티 에디터 종료 확인 다이얼로그 만들기",
    "url": "/posts/unity-memo-editor-exit-dialog/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, editor, dialog, csharp",
    "date": "2021-02-10 13:50:00 +0900",
    





    "snippet": "Memo기본적으로 유니티 에디터를 종료할 때는 확인창이 뜨지 않고 바로 종료된다.만약 실수로 닫기 버튼을 눌러버린다면 그대로 종료되어 버린다.그런데 유니티 에디터는 에디터의 종료도 이벤트로 구분하여, 메소드를 추가할 수 있도록 구현해놓았기 때문에이를 이용해 에디터의 종료를 시도할 경우 확인창을 띄우도록 할 수 있다.[InitializeOnLoad]public class EditorExitDialog{    static EditorExitDialog()    {        EditorApplication.wantsToQuit ..."
  },
  
  {
    "title": "OpenGL 공부 - 13 - Texture",
    "url": "/posts/opengl-study-13/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-10 01:30:00 +0900",
    





    "snippet": "목표  폴리곤에 텍스쳐 씌워보기(1장, 여러 장)1. 텍스쳐 한 장 사용이미지 준비  프로젝트 디렉토리 내에 Images 폴더를 만들고 PNG 이미지 파일을 준비한다.소스코드 작성  위치 : VertexAttribPointer ~ Main Loop 사이[1] 이미지 로드int imageWidth = 0;int imageHeight = 0;unsigned char* image = SOIL_load_image(&quot;Images/MoonCat.png&quot;,    &amp;amp;imageWidth, &amp;amp;ima..."
  },
  
  {
    "title": "Custom Mouse Events (성능 향상된 마우스 이벤트 처리)",
    "url": "/posts/unity-toy-custom-mouse-events/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin, mouse",
    "date": "2021-02-08 21:54:00 +0900",
    





    "snippet": "구현 동기유니티 모노비헤이비어는 OnMouse로 시작하는 이벤트 메소드들을 작성하여 사용할 수 있다.이 이벤트 메소드들은 레이캐스트 기반으로 동작하며, 해당 마우스 동작이 발생하면 메소드가 호출된다.하지만 여러가지 단점들이 있다.  마우스 좌클릭에 대해서만 동작한다.  이벤트 메소드 작성 시, 비워놓거나 해당 이벤트가 발생하지 않는 상황에도 성능을 소모한다.  컴포넌트를 비활성화하거나, 심지어 게임오브젝트를 비활성화해도 성능을 소모한다.  마우스가 닿은 정확한 위치를 알 수 없다.  대상을 레이어로 필터링할 수 없다.이런 단점..."
  },
  
  {
    "title": "OpenGL 공부 - 12 - New Beginning 3",
    "url": "/posts/opengl-study-12/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-08 16:12:00 +0900",
    





    "snippet": "목표  기본 렌더링 세팅  기본 도형 렌더링공부 내용테스트를 위해 렌더링 옵션들 설정// main.cpp - in main()glEnable(GL_DEPTH_TEST);glEnable(GL_CULL_FACE);glCullFace(GL_BACK);glFrontFace(GL_CCW); // 시계 반대 방향으로 구성된 폴리곤을 전면으로 설정// 픽셀 블렌딩 연산 지정glEnable(GL_BLEND);glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);// GL_LINE : 폴리곤을 선으로 그리기..."
  },
  
  {
    "title": "OpenGL 공부 - 11 - New Beginning 2",
    "url": "/posts/opengl-study-11/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-07 16:12:00 +0900",
    





    "snippet": "목표  프로그램 및 쉐이더 객체 생성  파일에 쉐이더 작성, 불러와 컴파일공부 내용Source Codevertex_core.glsl#version 440layout (location = 0) in vec3 vertex_position;layout (location = 1) in vec3 vertex_color;layout (location = 2) in vec3 vertex_texcoord;out vec3 vs_position;out vec3 vs_color;out vec2 vs_texcoord;void main(){    v..."
  },
  
  {
    "title": "OpenGL 공부 - 10 - New Beginning",
    "url": "/posts/opengl-study-10/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-06 15:20:00 +0900",
    





    "snippet": "목표  다른 강좌로 새롭게 시작  GLM, SOIL2 설치새로운 시작새로운 강좌를 선택한 김에 기존의 파일들을 날려버리고 구조 변경공부 내용GLM ?  OpenGL Mathematics, 수학 라이브러리.  http://glm.g-truc.net/0.9.8/index.html 에서 받을 수 있다.      이제는 익숙하게 Dependencies 폴더에 넣고 GLM 포함경로 설정    libs.h에 아래처럼 추가#include &amp;lt;GLM/glm.hpp&amp;gt;#include &amp;lt;GLM/vec2.hpp&..."
  },
  
  {
    "title": "유니티 반투명, 스텐실 개념 익히기",
    "url": "/posts/unity-transparent-stencil/",
    "categories": "Unity Shader, Shader Study",
    "tags": "unity, csharp, shader, graphics, transparent, alpha, stencil",
    "date": "2021-02-06 01:29:00 +0900",
    





    "snippet": "목차  1. 불투명과 반투명  2. 알파 블렌딩, 알파 소팅  3. 알파 테스트  4. 커스텀 알파 블렌딩  5. 파티클 쉐이더 만들어보기  6. 깨끗한 알파 블렌딩 쉐이더 만들기  7. ZTest와 ZWrite  8. 알파 블렌딩 쉐이더에서 발생하는 문제점들  9. 스텐실  10. References불투명과 반투명불투명(Opaque)과 반투명(Transparent) 오브젝트는 그려지는 타이밍도, 그리기 위한 고려사항도 다르다.유니티에서는 오브젝트를 렌더링하는 순서를 쉐이더와 마테리얼의 렌더 큐(Render Queue)를 통해..."
  },
  
  {
    "title": "유니티 쉐이더 모음",
    "url": "/posts/unity-shader-compilation/",
    "categories": "Unity Shader, Shader Study",
    "tags": "unity, csharp, shader, graphics, transparent, stencil",
    "date": "2021-02-06 01:25:00 +0900",
    





    "snippet": "Render Depth  단순히 뎁스만 색상으로 보여주는 쉐이더Shader &quot;Render Depth&quot;{    Properties    {        _Multiplier(&quot;Multiplier&quot;, Float) = 50    }    SubShader    {        Tags { &quot;RenderType&quot; = &quot;Opaque&quot; }        Pass         {            CGPROGRAM            #pragma vertex ver..."
  },
  
  {
    "title": "OpenGL 공부 - 09 - uniform, VAO",
    "url": "/posts/opengl-study-09/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-05 15:20:00 +0900",
    





    "snippet": "목표  uniform 변수, VAO에 대한 이해 및 사용1. uniformuniform이란?  OpenGL에서 쉐이더로 전달하는 글로벌 변수쉐이더에서 uniform 변수 선언 및 사용#shader fragment#version 330 corelayout(location = 0) out vec4 color;uniform vec4 u_Color;void main(){	color = u_Color;};  uniform 변수는 기본적으로 u_를 붙여 네이밍한다.OpenGL에서 uniform 변수 선언 및 전달      glGetUni..."
  },
  
  {
    "title": "유니티 스크립트 최적화",
    "url": "/posts/unity-opt-script-optimization/",
    "categories": "Unity, Unity Optimization",
    "tags": "unity, csharp, optimize, optimization, performance",
    "date": "2021-02-04 19:30:00 +0900",
    





    "snippet": "목차  1. GetComponent(), Find() 메소드 사용 줄이기  2. 비어있는 유니티 이벤트 메소드 방치하지 않기  3. StartCoroutine() 자주 호출하지 않기  4. 코루틴의 yield 캐싱하기  5. 참조 캐싱하기  6. 빌드 이후 Debug.Log() 사용하지 않기  7. Transform 변경은 한번에  8. ScriptableObject 활용하기  9. 오브젝트 풀링 사용하기  10. 필요하지 않은 경우, 리턴하지 않기  11. 필요하지 않은 경우, new로 생성하지 않기  12. 구조체 사용하기..."
  },
  
  {
    "title": "유니티 프로파일링을 통한 최적화",
    "url": "/posts/unity-opt-profiling/",
    "categories": "Unity, Unity Optimization",
    "tags": "unity, csharp, profiling, optimization",
    "date": "2021-02-04 19:30:00 +0900",
    





    "snippet": "목차  1. Note  2. Tools  3. Unity Profiler          Custom Profiler Tags      CPU &amp;amp; GPU Boundary      CPU Boundary      GPU Boundary        4. Memory Profiler  5. ReferencesNote  프로파일링은 1차적으로 에디터에서 수행하지만, 타겟 디바이스에서 실제로 실행하며 진행하는 프로파일링이 가장 중요하다.  [Edit - Project Settings - Quliaty - Other]에서..."
  },
  
  {
    "title": "유니티 에디터 프로파일러",
    "url": "/posts/unity-opt-profiler-window/",
    "categories": "Unity, Unity Optimization",
    "tags": "unity, csharp, profiling",
    "date": "2021-02-04 17:50:00 +0900",
    





    "snippet": "목차  1. Unity Profiler  2. CPU Usage          Timeline View      Hierarchy View      Show Related Objects      Call Stack      Show Calls      Deep Profile        3. GPU Usage  4. Rendering  5. MemoryUnity Profiler[Window] - [Analysis] - [Profiler]를 통해 프로파일러 윈도우를 열 수 있다.CPU, GPU(Rendering), Memory..."
  },
  
  {
    "title": "C++ Smart Debugging",
    "url": "/posts/memo-cpp-smart-debugging/",
    "categories": "Memo, C++ Memo",
    "tags": "cpp",
    "date": "2021-02-04 16:56:00 +0900",
    





    "snippet": "NoteC++에는 미리 정의된 동적 매크로가 있다.__FILE__  해당 위치의 소스파일 경로를 문자열로 가져온다.__LINE__  해당 위치의 줄 번호를 정수로 가져온다.그리고 매크로의 매개변수를 무조건 스트링으로 변환하여 가져올 수 있는 방법이 존재한다.#define MACRO(x) #x  x에 위치한 코드를 문자열로 변환하여 가져온다.이를 이용하면 해당 소스코드와 실행 위치 정보를 간단히 출력할 수 있다.#include &amp;lt;iostream&amp;gt;using namespace std;#define ShowC..."
  },
  
  {
    "title": "OpenGL 공부 - 08 - Debugging",
    "url": "/posts/opengl-study-08/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-04 15:45:00 +0900",
    





    "snippet": "목표  OpenGL 내에서 디버깅하기공부 내용  OpenGL 내에서 에러가 발생하거나 코드를 잘못 작성한 경우, 친절한 에러 메시지보다는 그저 검은 화면을 볼 가능성이 높다.  그래서 디버깅을 하려면, OpenGL에서 제공하는 몇몇 메소드와 매크로를 활용해야 한다.      glGetError          에러가 발생한 경우 에러 플래그를 리턴한다.                  return GLenum      에러 플래그 - GL_NO_ERROR - GL_INVALID_ENUM - GL_INVALID_VALUE - GL..."
  },
  
  {
    "title": "OpenGL 공부 - 07 - Index Buffer",
    "url": "/posts/opengl-study-07/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-03 16:32:00 +0900",
    





    "snippet": "목표  인덱스 버퍼의 사용과 이해공부 내용삼각형 그리기  삼각형을 하나 그리려면, 버텍스 3개가 필요하다.float positions[6] ={    -0.5f, -0.5f,     0.0f,  0.5f,     0.5f, -0.5f,};  GPU는 전달받은 버텍스들을 순서대로 확인하여 3개씩 짝지어서 하나의 폴리곤을 그려준다.  이 때, 3개의 버텍스가 순서대로 시계 반대 방향으로 위치해야 폴리곤의 전면이 그려진다.사각형 그리기  사각형을 하나 그리려면 삼각형이 2개 필요하므로, 결국 버텍스 6개가 필요하다.      그런데..."
  },
  
  {
    "title": "인스펙터에 오토 프로퍼티 표시하기",
    "url": "/posts/unity-memo-show-property-on-inspector/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp, property",
    "date": "2021-02-02 17:08:00 +0900",
    





    "snippet": "Memopublic GameObject Property1 =&amp;gt; Field1;private GameObject Field1;이렇게 다른 필드와 연결된 프로퍼티라면public GameObject Property1 =&amp;gt; field1;[SerializeField]private GameObject field1;대상 필드에 [SerializeField]를 붙여서 인스펙터에 표시할 수 있다.하지만[SerializeField]public GameObject Property2 { get; private set; }이런..."
  },
  
  {
    "title": "OpenGL 공부 - 06 - Shader File",
    "url": "/posts/opengl-study-06/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-02 14:21:00 +0900",
    





    "snippet": "목표  쉐이더를 파일로 분리하여, 파일로부터 읽어와 사용하기공부 내용쉐이더 파일 작성하기  솔루션 디렉터리 - [Resources/Shaders] 폴더 생성  Shaders 폴더 내에 [Basic.shader] 파일 생성  속성 - 디버깅 - 작업 디렉터리에 $(ProjectDir)가 포함되어 있으므로 상대경로에서 불러오기 가능  기존의 쉐이더 코드를 옮겨와 약간 수정하여 내용 작성#shader vertex#version 330 corelayout(location = 0) in vec4 position;void main(){ ..."
  },
  
  {
    "title": "Vertex/Fragment Shader Bible [예정]",
    "url": "/posts/unity-vertex-fragment-shader-bible/",
    "categories": "Unity Shader, Shader Study",
    "tags": "unity, csharp, shader",
    "date": "2021-02-02 01:00:00 +0900",
    





    "snippet": "목차  Vertex/Fragment Shader 구성  TODO  https://docs.unity3d.com/Manual/SL-VertexFragmentShaderExamples.html          노말맵 적용법      큐브맵 적용법      오클루전맵 적용법      Triplanar 적용법      라이팅 계산법(디퓨즈, 앰비언트)      Shadow Receive, Cast      Fog        Multiple Lights          https://github.com/shantanubhadoria/..."
  },
  
  {
    "title": "Surface Shader Bible [작성 중]",
    "url": "/posts/unity-surface-shader-bible/",
    "categories": "Unity Shader, Shader Study",
    "tags": "unity, csharp, shader",
    "date": "2021-02-02 01:00:00 +0900",
    





    "snippet": "목차Surface Shader 기본 구성Shader &quot;Custom/SurfaceShader01&quot;{    Properties    {        _Color (&quot;Color&quot;, Color) = (1,1,1,1)        _MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; {}    }    SubShader    {        Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }        LO..."
  },
  
  {
    "title": "멀티패스 쉐이더 코드 깔끔하게 작성하기",
    "url": "/posts/unity-smart-multipass-code/",
    "categories": "Unity Shader, Shader Study",
    "tags": "unity, csharp, shader",
    "date": "2021-02-02 00:00:00 +0900",
    





    "snippet": "Shader &quot;A/B&quot;{    Properties    {        _MainTex (&quot;Texture&quot;, 2D) = &quot;black&quot; {}    }    CGINCLUDE    #include &quot;UnityCG.cginc&quot;    struct appdata    {        float4 vertex : POSITION;        float2 uv : TEXCOORD0;    };    struct v2f    {        float4 pos:SV_P..."
  },
  
  {
    "title": "C++ 스택 메모리 동적 할당",
    "url": "/posts/memo-cpp-stack-memory-allocation/",
    "categories": "Memo, C++ Memo",
    "tags": "cpp",
    "date": "2021-02-01 18:45:00 +0900",
    





    "snippet": "Memo      _alloca          스택에 메모리를 동적으로 할당해준다.      함수의 리턴으로 전달하면 안된다.      블록이 종료되면 자동으로 할당 해제된다.      공간 할당 불가능한 경우 Stack Overflow 에러가 발생할 수 있으니 주의      예외가 발생한 경우 구조적 예외처리(SEH)로 받아야 함                  size_t size      할당할 배열 크기(길이 * sizeof(타입))              return void*      할당된 배열의 주소(타입 캐스팅..."
  },
  
  {
    "title": "OpenGL 공부 - 05 - Shader",
    "url": "/posts/opengl-study-05/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-02-01 17:42:00 +0900",
    





    "snippet": "목표  OpenGL의 쉐이더에 대한 이해  간단한 vertex, fragment 쉐이더 작성, 컴파일 및 실행OpenGL의 쉐이더      Vertex&amp;amp;Fragment Shader          OpenGL에서 거의 90%의 비중을 차지            Vertex Shader          하나의 정점 당 한 번씩 실행된다.      layout을 통해 정점 속성의 위치를 입력받는다.      입력 : 정점 데이터      출력 : 클립 스페이스의 정점 데이터            Fragment Shad..."
  },
  
  {
    "title": "UI 헤더 드래그 앤 드롭으로 옮기기",
    "url": "/posts/unity-memo-ui-drag-and-drop/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp, ui, memo, drag, drop",
    "date": "2021-02-01 03:00:00 +0900",
    





    "snippet": "기능  UI의 헤더(윗부분)를 따로 구성했을 때, 헤더를 드래그 했을 때만 옮기기사용법  헤더 UI는 UI의 자식으로 구성한다.  PopupUIHeader 스크립트를 헤더 UI의 컴포넌트로 넣어준다.  이동 대상 UI를 인스펙터에서 Target UI에 넣는다. (지정하지 않는 경우, 부모로 자동 초기화)using UnityEngine;using UnityEngine.EventSystems;/// &amp;lt;summary&amp;gt; 헤더 드래그 앤 드롭에 의한 UI 이동 &amp;lt;/summary&amp;gt;publ..."
  },
  
  {
    "title": "팝업 UI 관리 시스템 구현하기",
    "url": "/posts/popup-ui-management-system/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp, ui, stack",
    "date": "2021-01-31 20:23:00 +0900",
    





    "snippet": "게임의 UI  온라인 PC게임을 예로 들었을 때, 다양한 형태의 UI들이 존재한다.  화면 예시 : Smilegate RPG ‘LostARK’1. 전체화면 UI  크기가 화면 전체에 해당하는 UI  예 : 상점, 캐시 샵2. 고정형 UI  고정된 위치에 항상 존재하는 UI  예 : 하단 바, 퀵슬롯, 미니맵, 채팅창3. 추적형 UI  게임 내 요소들(캐릭터, 몬스터, 건물 등)의 위치를 실시간으로 추적하여 따라다니는 UI  예 : 체력 바, 이름, 말풍선4. 안내형 UI  화면 한켠에 잠시 나타났다가 사라지는 형태의 UI  게..."
  },
  
  {
    "title": "OpenGL 공부 - 04 - VAO, VBO, Attributes",
    "url": "/posts/opengl-study-04/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-01-31 13:31:00 +0900",
    





    "snippet": "목표  Vertex Attributes, Layout, VBO, VAO에 대한 이해Attributes, VAO, VBO  버텍스 버퍼에는 버텍스 좌표, 텍스쳐 좌표, 노멀 벡터 등 여러 데이터가 float 값으로 들어갈 수 있다.  하지만 그 자체로는 그저 메모리에 올라가는 값일 뿐이기 때문에 각각의 데이터가 어떤 역할을 하고, 길이는 얼마나 갖고 있고, 시작 위치는 어디인지 OpenGL에 알려줘야 한다.      VAO(Vertex Array Object)          하나 이상의 VBO를 담을 수 있는 객체      개..."
  },
  
  {
    "title": "입력 바인딩 시스템 만들기",
    "url": "/posts/input-binding-system/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp, input, binding",
    "date": "2021-01-30 16:18:00 +0900",
    





    "snippet": "목표  에디터 및 인게임에서 언제든 기능에 연결된 사용자 마우스, 키보드 바인딩을 변경할 수 있는 기능 구현  전체 입력 바인딩을 직렬화하여 저장하고 불러올 수 있는 기능 구현유니티의 입력 시스템  유니티에는 2가지 Input System이 있다.  첫 번째는 Input.Get~ 꼴의 메소드를 이용해 이번 프레임에 해당 입력이 있었는지 검사하는 레거시 시스템      두 번째는 2019년 소개된 New Input System.    New Input System을 사용하려면          패키지 매니저에서 Input Syst..."
  },
  
  {
    "title": "OpenGL 공부 - 03 - Vertex, VBO",
    "url": "/posts/opengl-study-03/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-01-29 22:07:00 +0900",
    





    "snippet": "목표  버텍스, 버텍스 버퍼에 대한 이해렌더링 파이프라인 요약      Vertex Shader          입력 : 정점 목록      정점들을 오브젝트 스페이스에서 MVP 변환을 통해 클립 스페이스까지 변환한다.            Shape Assembly          정점을 조립하여 렌더링을 할 수 있는 최소 단위(Primitive : 점, 선, 삼각형 등)로 만든다.            Geometry Shader          입력 : 프리미티브 목록      프리미티브 당 한 번씩 수행한다.      프리..."
  },
  
  {
    "title": "스크립트 템플릿(Script Templates)",
    "url": "/posts/unity-memo-script-templates/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp, script, templates",
    "date": "2021-01-29 16:55:00 +0900",
    





    "snippet": "개념  Project - 우클릭 - Create를 통해 만드는 스크립트 또는 텍스트의 템플릿을 미리 지정하는 기능  스크립트 템플릿의 저장 경로 :C:\\Program Files\\유니티 버전\\Editor\\Data\\Resources\\ScriptTemplates  각각의 유니티 버전마다 따로 저장된다.  한가지 팁은, 스크립트 템플릿에 한 글자라도 애초에 한글이 작성되어 있지 않으면 나중에 한글 주석이라도 작성했을 때 인코딩이 깨져버릴 수 있으니 스크립트 템플릿 내에 아주 짧은 한글 주석을 적어 놓는게 좋다는 것규칙  각각의 템플릿..."
  },
  
  {
    "title": "OpenGL 공부 - 02 - 초기 세팅",
    "url": "/posts/opengl-study-02/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-01-28 22:09:00 +0900",
    





    "snippet": "목표  GLEW 설치 및 적용GLEW 설치  GLEW : OpenGL Extension Wrangler Library  http://glew.sourceforge.net      Binary 다운로드    프로젝트의 Dependency 폴더 내로 GLEW 폴더 복사          glew-2.1.0 폴더를 통째로 가져와서 GLEW로 이름을 변경해준다.        GLEW/doc/index.html - Usage 탭에 들어가면 초기 사용법이 있다.참조 추가  헤더          프로젝트 속성 - C/C++ - 일반 - 추가..."
  },
  
  {
    "title": "C# 파일 입출력",
    "url": "/posts/memo-cs-fileio/",
    "categories": "Memo, Csharp Memo",
    "tags": "csharp, file, io",
    "date": "2021-01-28 21:10:00 +0900",
    





    "snippet": "간단 정리파일에 쓰려면  대상이 string, string[], byte[] 타입 중 하나여야 한다.  파일의 전체 경로(&quot;폴더경로\\파일명.확장자&quot;)가 필요하다.한 파일에 대한 연속 입출력 횟수에 따라  한번에 읽거나 쓰려면 File.Read(), File.Write() 메소드를 사용한다.  여러 번에 걸쳐 읽거나 쓰려면 스트림 객체를 사용한다.Namespaceusing System.IO;Path// \\ 대신 /를 써도 \\로 자동 변환string   filePath = @&quot;C:\\folder\\fileN..."
  },
  
  {
    "title": "OpenGL 공부 - 01 - 시작",
    "url": "/posts/opengl-study-01/",
    "categories": "OpenGL, OpenGL Study",
    "tags": "graphics, opengl",
    "date": "2021-01-28 00:10:00 +0900",
    





    "snippet": "목표  OpenGL 기초 세팅OpenGL?      OpenGL 자체는 API가 아닌, 각종 OpenGL 라이브러리를 개발하기 위해 Khronos Group이 개발 및 유지 관리하는 설명서이다.        OpenGL은 각 함수의 출력과 수행 방법을 정의한다.        실제로 OpenGL 라이브러리를 개발하는 사람들은 일반적으로 그래픽카드 제조업체이다.        OpenGL은 기본적으로 C언어로 작성되었으며, 각종 확장 라이브러리는 C++로 작성된 경우가 많다.  OpenGL 라이브러리 종류GL(Graphics Lib..."
  },
  
  {
    "title": "Unlit 쉐이더그래프로 만드는 Stylized Lit 쉐이더",
    "url": "/posts/unlit-stylized-lit-shadergraph/",
    "categories": "Unity Shader, URP Shader Study",
    "tags": "unity, csharp, shader, shadergraph",
    "date": "2021-01-27 22:00:00 +0900",
    





    "snippet": "동기  유나이트 서울 2020의 위 세션을 보고, 쉐이더그래프만을 이용해 비슷하게 만들어 봐야겠다고 생각했다.목표  URP 쉐이더그래프 중 Unlit 그래프를 이용해 직접 Stylized Lit 쉐이더 만들기1. 서브그래프 준비  영상에서 보면, SmoothStep과 비슷한 연산을 더 저렴하게 할 수 있게 해주는 LinearStep을 다룬다.  LinearStep을 함수화하여 자주 사용하는 코드가 나오기에, 서브그래프로 만들어주었다.  그런데 실제로 이 세션의 코드를 보면 LinearStep 내에 threshold, smoot..."
  },
  
  {
    "title": "Frame Rate Checker",
    "url": "/posts/unity-toy-frame-rate-checker/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2021-01-24 17:00:00 +0900",
    





    "snippet": "Note  실제 FPS 값을 실시간, 최근 N개의 평균, 최소, 최댓값으로 확인할 수 있다.  게임 진행 동안 텍스트의 위치, 색상, 크기, GUI 표시 상태를 실시간으로 변경할 수 있다.PreviewDownload  FrameRateChecker.zipSource Code   .  using System;using System.Collections;using System.Collections.Generic;using UnityEngine;// 날짜 : 2021-01-24 PM 4:11:02// 작성자 : Ritonamespa..."
  },
  
  {
    "title": "잡 시스템(Job System)",
    "url": "/posts/job-system/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp, job, burst",
    "date": "2021-01-24 13:15:00 +0900",
    





    "snippet": "개념  유니티에서 안전한 멀티스레딩을 구현하는 시스템  스레드를 별도로 생성하지 않으며, 유니티의 워커스레드에 작업을 지시할 수 있게 한다.  잡 대기열에 잡을 배치하면 워커 스레드가 잡 대기열에서 항목을 가져와 실행한다.  Native Container를 이용해 잡의 수행 결과를 메인 스레드와 공유한다.  버스트 컴파일러를 이용하여 추가적인 성능 향상을 기대할 수 있다.장점  다수의 작은 작업들을 처리하기에 좋으며, 속도가 빠르다.  스레드를 추가로 만들고 관리하지 않아도 되므로 메모리를 절약할 수 있다.  유니티 콘솔을 이..."
  },
  
  {
    "title": "전장의 안개(Fog of War)",
    "url": "/posts/fog-of-war/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp",
    "date": "2021-01-20 21:00:00 +0900",
    





    "snippet": "목차  1. 개념  2. 구현 방법  3. 타일맵을 이용한 구현  4. 구현 결과  5. 프로파일링, 최적화  6. Reference개념  맵과 크기가 동일한 RGBA(0, 0, 0, a)의 텍스쳐를 이용해 지정한 유닛들의 주변시야를 표현한다.  지정한 유닛이 현재 위치한 원형 범위 내 영역들은 a = 0,  지정한 유닛이 한 번이라도 위치했던 영역들은 a = 0.5~0.8,  지정한 유닛이 한 번도 방문하지 않은 영역은 a = 1로 표현한다.[스타크래프트2 게임 플레이 화면]구현 방법[1] 카메라와 지상 사이에 검정색 Pla..."
  },
  
  {
    "title": "레이 마칭(Ray Marching)",
    "url": "/posts/ray-marching/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp",
    "date": "2021-01-19 23:15:00 +0900",
    





    "snippet": "레이 마칭이란?      모델의 정점 데이터를 이용하는 기존의 3D 렌더링 방식과는 달리, 레이를 전진시켜(Ray Marching) 카메라로부터 픽셀마다 가장 가까운 오브젝트 표면까지의 거리를 알아내고, 이를 활용해 오브젝트를 그려내는 기법        레이 마칭의 모든 오브젝트들은 거리 함수(SDF : Signed Distance Function)로 표면의 정보가 계산된다.        SDF의 기초적인 예시 : 구체(Sphere)  // point : 거리를 계산할 기준 좌표// center : Sphere의 중심 좌표//..."
  },
  
  {
    "title": "Pixelater (픽셀화 렌더링)",
    "url": "/posts/unity-toy-pixelater/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2021-01-19 22:56:00 +0900",
    





    "snippet": "Note  렌더 텍스쳐의 해상도를 강제로 변경하여 화면을 픽셀화시킨다.  스크립트를 카메라에 부착하여 사용한다.PreviewDownload  Pixelater.zipSource Code   .  using System;using System.Collections;using System.Collections.Generic;using UnityEngine;// 날짜 : 2021-01-19 PM 5:01:57// 작성자 : Ritonamespace Rito{    [ExecuteInEditMode]    public class Pi..."
  },
  
  {
    "title": "AfterImage(Motion Trail, 잔상 효과)",
    "url": "/posts/unity-toy-afterImage/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin, afterimage, motiontrail",
    "date": "2021-01-18 22:56:00 +0900",
    





    "snippet": "Note  게임오브젝트가 지나간 자리에 잔상을 생성한다.  하위 게임오브젝트에도 렌더러가 있는 경우, 잔상을 함께 생성할 수 있다.How To Use  대상 게임오브젝트에 Mesh Renderer가 존재하는 경우, MeshAfterImage 스크립트를 부착한다.  Skinned Mesh Renderer가 존재하는 경우, SkinnedMeshAfterImage 스크립트를 부착한다.      After Image Material 필드에 동봉된 AfterImage 마테리얼을 지정한다.    After Image Gradient 옵션..."
  },
  
  {
    "title": "Custom Attributes (커스텀 애트리뷰트 모음)",
    "url": "/posts/unity-toy-custom-attributes/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, custom, attribute",
    "date": "2021-01-17 22:18:00 +0900",
    





    "snippet": "목차  1. MemoBox  2. BoxHeader  3. MethodButton  4. AutoInject  5. Required  6. LayerDropdown, TagDropdown  7. Readonly  8. ProgressBar  9. Label  10. SpaceTop      11. SpaceBottom    Download  Source CodeMemoBox  필드의 상단에 상자 및 메모를 표시한다.            매개변수      설명                  Contents      메모에 적을 ..."
  },
  
  {
    "title": "Unlit 쉐이더그래프로 만드는 Custom Lit 쉐이더",
    "url": "/posts/urp-unlit-custom-lit/",
    "categories": "Unity Shader, URP Shader Study",
    "tags": "unity, csharp, shader, shadergraph",
    "date": "2021-01-16 22:14:00 +0900",
    





    "snippet": "목표  URP 쉐이더그래프 중 Unlit 그래프를 이용해 직접 Lit 쉐이더 만들기1. Diffuse 구현  커스텀 함수를 이용하여 메인라이트의 방향, 색상, 감쇠를 얻어낸다.Custom_Mainlight.hlslvoid MainLight_half(float3 WorldPos, out half3 Direction, out half3 Color, out half DistanceAtten, out half ShadowAtten){    #if SHADERGRAPH_PREVIEW        Direction = half3(0.5,..."
  },
  
  {
    "title": "비헤이비어 트리(Behavior Tree)",
    "url": "/posts/behavior-tree/",
    "categories": "Unity, Unity Study",
    "tags": "unity, csharp",
    "date": "2021-01-05 00:26:00 +0900",
    





    "snippet": "개념  FSM (Finite State Machine)의 단점을 보완하기 위해 만들어진 기법  FSM에서는 상태 전이 조건을 모두 각각의 상태에서 검사하지만, BT에서는 상태 동작 뿐만 아니라 전이 조건도 노드로 관리한다.  노드 그래프를 통해 시각화하거나 params, 빌더 패턴 등을 활용하여 스크립트 내에서도 가독성 좋게 구성할 수 있다.  기본적으로 Leaf, Decorator, Composite 노드를 기반으로 하며, 구현은 많이 다를 수 있다.          Leaf : 동작을 수행하는 노드. 대표적으로 Action..."
  },
  
  {
    "title": "유용한 정보, 링크 모음",
    "url": "/posts/unity-memo-useful-links/",
    "categories": "Unity, Unity Memo",
    "tags": "unity, csharp",
    "date": "2021-01-01 01:01:01 +0900",
    





    "snippet": "유니티, 쉐이더 튜토리얼  https://catlikecoding.com/unity/tutorials/레거시 파이프라인과 SRP  https://drive.google.com/file/d/1eR39KY_n_wuWF5S_zClCECE3ynmSfs-h/view"
  },
  
  {
    "title": "Rainy Window Shader",
    "url": "/posts/unity-shader-script-rainy-window/",
    "categories": "Unity Shader, Shader Scripts",
    "tags": "unity, csharp, shader, shaderlab",
    "date": "2020-12-01 22:00:00 +0900",
    





    "snippet": "Summary  비내리는 유리창 쉐이더PreviewSource Code   Source Code  Shader &quot;Custom/RainyWindow&quot;{    Properties    {        [HideInInspector] _MainTex(&quot;Texture&quot;, 2D) = &quot;white&quot; {}        _SizeX(&quot;Size X&quot;, float) = 1        _SizeY(&quot;Size Y&quot;, float) = 1        [Spac..."
  },
  
  {
    "title": "Lighting Models",
    "url": "/posts/lighting-models/",
    "categories": "Unity Shader, Shader Study",
    "tags": "unity, csharp, shader, graphics",
    "date": "2020-11-16 17:14:00 +0900",
    





    "snippet": "Vectors  L (Light) : 정점에서 광원을 향하는 방향의 벡터  N (Normal) : 정점의 노멀 벡터  V (View) : 정점에서 카메라를 향하는 방향의 벡터  R (Reflect) : 노멀벡터를 법선으로 하여 계산한 L의 반사 벡터 ( 2N(NdL)-L )      H (Half) : 블린퐁에서 사용, L와 V의 중간 벡터 ( normalize(L + V) )    NdL = dot(N, L) : 기본 램버트 공식  NdV = dot(N, V) : 림라이트에서 사용  RdV = dot(R, V) : 퐁 스페큘..."
  },
  
  {
    "title": "Outline Object",
    "url": "/posts/unity-urp-sg-outline-object/",
    "categories": "Unity Shader, URP Shader Graph",
    "tags": "unity, csharp, urp, shadergraph",
    "date": "2020-10-08 00:00:00 +0900",
    





    "snippet": "Summary      CameraDepthNormal 텍스쳐를 이용하여 개별 오브젝트마다 아웃라인을 적용한다.        URP Asset의 Depth Texture에 체크해야 한다.        MSAA 2x 이상 사용해야 한다.  PreviewOptions            프로퍼티      설명                  Main Texture      메인 텍스쳐              Outline Color      아웃라인 색상              Outline Thickness      아웃라인 두께..."
  },
  
  {
    "title": "Toon(Cel)",
    "url": "/posts/unity-urp-sg-toon-cel/",
    "categories": "Unity Shader, URP Shader Graph",
    "tags": "unity, csharp, urp, shadergraph",
    "date": "2020-09-30 00:00:00 +0900",
    





    "snippet": "Summary  셀 셰이딩을 통한 카툰 라이팅 표현PreviewOptions            프로퍼티      설명                  Main Texture      메인 텍스쳐              Apply Main Light Color      메인 라이트의 색상 적용 여부 설정              Cel Count      셀 셰이딩 분할 개수              Threshold      셀 셰이딩 기준점 설정              Shadow Color      그림자 색상         ..."
  },
  
  {
    "title": "Singleton MonoBehavior (상속으로 간단히 싱글톤 적용하기)",
    "url": "/posts/unity-toy-singleton-monobehavior/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2020-07-08 15:30:00 +0900",
    





    "snippet": "Note  단순한 상속만으로 모노비헤이비어 클래스를 싱글톤으로 만들어주는 클래스How To Use  클래스명이 Apple일 때 예시로, 다음과 같이 상속받아 사용한다.public class Apple : Rito.SingletonMonoBehavior&amp;lt;Apple&amp;gt;{    // Awake 메소드는 반드시 이렇게 작성해야 한다.    protected override void Awake()    {        base.Awake();        // .. 기타 코드    }}Preview  게임 시작 ..."
  },
  
  {
    "title": "Unity Editor-only Debug (에디터 전용 디버그 클래스)",
    "url": "/posts/unity-toy-editor-only-debug/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2020-07-06 15:00:00 +0900",
    





    "snippet": "Note  유니티엔진의 콘솔 디버그는 빌드 이후에도 작동하여, 성능을 많이 소모할 수 있다.  이를 방지할 수 있게 유니티 에디터에서만 작동하도록 래핑된 Debug 클래스How To Use  스크립트 상단에 다음과 같이 작성한다.using Debug = Rito.Debug;Download  Debug_UnityEditorConditional.zipSource Code  https://github.com/rito15/Unity_Toys   .  using System;using UnityEngine;using System.Dia..."
  },
  
  {
    "title": "Getcomponent Attributes",
    "url": "/posts/unity-toy-getcomponent-attributes/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2020-04-12 23:30:00 +0900",
    





    "snippet": "Note      메소드로만 사용하던 GetComponent(), Find() 기능들을 필드/프로퍼티 애트리뷰트로 간편하게 사용할 수 있다.    리플렉션과 커스텀 애트리뷰트를 활용하여 제작하였다.  Component를 상속받는 타입의 필드/프로퍼티에 사용할 수 있다.  대상 멤버의 접근지정자에 관계 없이 모두 동작한다.  본 애트리뷰트들을 통한 컴포넌트 할당 기능은 Awake() 및 OnEnable() 이후, Start() 이전에 동작한다.  씬 이동, 재시작 시에도 올바르게 동작한다.  Find() 종류의 애트리뷰트들은 게..."
  },
  
  {
    "title": "Save Transform During Play",
    "url": "/posts/unity-toy-save-transform-during-play/",
    "categories": "Unity, Unity Toys",
    "tags": "unity, csharp, plugin",
    "date": "2020-04-11 18:10:00 +0900",
    





    "snippet": "Note      기본적으로, 플레이 모드에서 트랜스폼의 위치, 회전, 크기를 변경하여도플레이 모드가 종료되면 변경사항이 저장되지 않는다.        이 컴포넌트를 간단히 추가하기만 하면 플레이 모드를 종료해도트랜스폼의 변경사항이 저장되도록 할 수 있다.  How to Use      원하는 게임오브젝트에 SaveTransformDuringPlay 컴포넌트를 추가하고, On에 체크한다.        플레이 모드에서 On, 각각의 Space 옵션을 수정해도 수정사항이 적용된다.        인스펙터에서 Position Spac..."
  }
  
]





# 해시테이블 구현 원리
---

- Key를 주면 Hash Function에 집어넣어서 Index를 만든다. (배열 크기로 나머지 연산)

- 그 Index로 배열(버킷, Bucket)을 참조한다.

- 배열의 해당 위치에 Value를 저장한다.

- 탐색할 때도 같은 방식을 이용한다.

- 일단 중요한건 Hash Function의 성능(일단 `object.GetHashCode()` 사용?)

<br>



# 토막 상식 - 해시를 이용한 자료구조들
---

## [1] Set(HashSet)

- 저장할 Data를 Hash Function에 집어넣는다.

- 얻은 Index 위치의 배열 공간에 Data를 그대로 저장한다.

- Data의 중복을 허용하지 않는다. (중복을 허용하고 개수를 카운팅할 수도 있을듯)

- Data의 존재 유무, 중복 확인을 목적으로 사용한다.

<br>

## [2] Hash Table

- O(1)로 데이터를 참조하기 위해 사용된다.

<br>



# 인덱스 충돌 처리
---

- Hash Function의 결과로 중복 Index가 발생하는 경우, 이를 처리하는 것이 중요하다.

<br>

## [1] Separate Chaining 방식
- Linked List를 이용하여, 해당 Key 뒤에 주렁주렁 매달아 놓는다.

- 배열의 크기를 확장하지 않고, 데이터를 계속해서 넣을 수 있다.(장점은 아님)

<br>

## [2] Open Addressing
- 추가적인 메모리를 사용하는 Chaining 방식과 달리, 현재 남아 있는 배열 공간을 활용한다.

### [2-1] Linear Probing
- 현재 배열의 인덱스로부터 고정된 크기만큼 이동하며 차례대로 비어있는 공간을 찾아, 그 곳에 데이터를 저장한다.

### [2-2] Quadratic Probing
- Linear Probing과 유사하지만, 인덱스를 이동할 때 처음에는 2^0, 다음에는 2^1, 2^2, ...씩 이동하며 빈 공간을 찾는다.

### [2-3] Double Hashing Probing
- 해시된 값을 다시 Hash Function에 집어넣어서 또 계산하여 새로운 인덱스를 계산한다.
- Hash Function의 성능에 크게 좌우되며, 보통은 다른 Probing 방식에 비해 성능 소모가 크다.

<br>



# 삭제 처리
---

- Probing으로 만드는 경우에, 1..2..3 이렇게 Probing으로 연결되었는데 도중에 2가 사라져버리면 3을 탐색할 때 2에서 빈공간을 탐색하게 되므로 3이 없다고 판단할 수 있다.

- 따라서 이처럼 2를 제거해도 2가 사라진 자리에 더미 노드를 넣어서 탐색이 이어질 수 있게 해야 한다.

- 그런데 더미 노드가 쌓이면 손해이므로, 언젠가 더미 노드를 싹 지우고 해시를 싹 리빌딩하는 과정이 필요하다.

- 해시 리빌딩을 위해서는 KeyValuePair 들을 따로 모아 저장해놓아야 할듯

<br>



# 확장과 재구성
---

- Chaining이든, Probing이든 데이터가 쌓일수록 언젠가는 배열을 확장해줘야 탐색 비용을 줄일 수 있다.

- 배열을 확장하면 모든 데이터를 다시 Hash Function에 넣고 해시를 재계산해줘야 한다.

- 배열의 확장이 너무 잦거나 규모가 크면 확장으로 인한 성능 소모가 크고, 확장을 너무 안하면 참조의 성능 소모가 커지기 때문에 적절한 타협이 필요하다.

<br>



# References
---
- <https://bcho.tistory.com/1072>
- <https://mangkyu.tistory.com/102>




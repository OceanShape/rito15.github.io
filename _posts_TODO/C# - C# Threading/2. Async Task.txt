

# 비동기 작업 : async-await
---

`async`, `await` 키워드를 이용해 이루어지는 비동기 작업은

기존의 멀티 스레딩과는 다른 방식으로 이루어진다.

<br>

## 특징

- `async-await`로 실행 시킨 작업은 새로운 스레드를 생성하지 않고, 해당 스레드 내에서 이루어진다.

- 메소드에서 `await`로 대기하려면, 해당 메소드의 리턴 타입 앞에 `async` 키워드를 작성한다.

- `await Task.Delay(n)`와 같이 `await`를 이용한 대기는 해당 스레드를 블록시키지 않는다.

- 비동기 작업은 해당 스레드가 `Thread.Sleep(n)` 등으로 블록된 상태에서도 개별적으로 동작한다.

- 비동기 작업을 기다리고, 끝날 경우 값을 리턴받을 수 있다.

<br>

## 대기할 수 없는 작업

- `async void` 타입은 비동기로 시작되고, 의도적으로 대기할 수 없다.

```cs
private async void TaskAsync()
{
    for (int i = 0; i < 100; i++)
    {
        await Task.Delay(500);
        Console.WriteLine($"Task : {i}");
    }
}

private void MainMethod()
{
    TaskAsync();
    Thread.Sleep(10_000);
}
```

<br>

## 대기할 수 있는 작업

- `async Task` 타입은 비동기로 시작되며 `async void`와 마찬가지로 작업의 결과를 저장하지는 않는다.

- 작업을 의도적으로 대기할 수 있다.

```cs
private async Task TaskAwaitable(int n)
{
    for (int i = 0; i < n; i++)
    {
        await Task.Delay(100);
        Console.WriteLine($"Task : {i}");
    }
}

private void MainMethod()
{
    // 체인으로 대기
    TaskAwaitable(10).Wait();

    // 객체로 받아 대기
    Task t = TaskAwaitable(10);
    t.Wait();
}
```

<br>

## 값을 리턴하는 작업

- 값을 리턴하는 비동기 메소드는 `Task<리턴타입>` 꼴로 리턴 타입을 지정한다.

- 비동기 메소드의 결과를 `.Result`와 같이 참조하려고 하는 경우, 결과를 얻을 때까지 대기하여 해당 지점에서 흐름이 일시 중단된다.

```cs
private async Task<int> TaskAsyncAndReturn()
{
    int sum = 0;
    for (int i = 0; i < 10; i++)
    {
        await Task.Delay(100);
        sum += i;
    }
    return sum;
}

private void MainMethod()
{
    Task<int> task = TaskAsyncAndReturn();
    Console.WriteLine(task.Result); // 결과를 얻을 때까지 대기
    Console.WriteLine("End");
}
```

<br>

- `.Wait()` 메소드를 통해 의도적으로 결과를 기다리며 흐름을 중단시킬 수도 있다.

```cs
private void MainMethod()
{
    Task<int> task = TaskAsyncAndReturn();
    task.Wait(); // 결과를 얻을 때까지 대기

    // -> 결과를 .Result로 참조하는 대신, .Wait()를 통해 대기 가능

    Console.WriteLine("End");
}
```

<br>

- `.Wait()` 이전에 다른 작업 또한 실행시켰다면, 해당 작업도 병렬적으로 수행된다.

```cs
private async Task<int> TaskAsyncAndReturn(int n)
{
    int sum = 0;
    for (int i = 0; i < n; i++)
    {
        await Task.Delay(100);
        sum += i;
    }
    return sum;
}

// 동시에 여러 작업을 실행시키는 경우
private void MainMethod()
{
    Task<int> task1 = TaskAsyncAndReturn(10);  // 작업 1 시작
    Task<int> task2 = TaskAsyncAndReturn(20);  // 작업 2 시작

    // 작업1, 작업2 실행 중

    task1.Wait();                    // 작업 1 대기
    Console.WriteLine("End 1");

    // 작업 2 실행 중

    Console.WriteLine(task2.Result); // 작업 2 대기
    Console.WriteLine("End 2");
}

// 한 번에 하나의 작업씩 실행시키는 경우
private void MainMethod2()
{
    Task<int> task1 = TaskAsyncAndReturn(10);  // 작업 1 시작

    task1.Wait();                              // 작업 1 대기

    // 작업1 실행 중

    Console.WriteLine("End 1");

    Task<int> task2 = TaskAsyncAndReturn(20);  // 작업 2 시작

    // 작업 2 실행 중

    Console.WriteLine(task2.Result);           // 작업 2 대기
    Console.WriteLine("End 2");
}
```

<br>

## 작업의 연계



<br>

## await를 통한 또 다른 작업의 대기


---
title: 유니티 오브젝트 풀(Object Pool) 구현하기
author: Rito15
date: 2021-08-000000000000000000000000000000000 00:55:00 +09:00 변경!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
categories: [Unity, Unity Study]
tags: [unity, csharp]
math: true
mermaid: true
---

# 목표
---
- 오브젝트 풀링 구현하기

<br>


# 개념
---

게임오브젝트를 생성, 파괴하는 것은 순간적으로 큰 성능 소모 및 프레임 저하를 발생시킬 수 있다.

따라서 생성, 파괴 대신 활성화, 비활성화 방식을 사용하면 순간적인 프레임 저하를 방지할 수 있다.

이를 오브젝트 풀링 기법이라고 하며, 동일한 여러 개의 오브젝트를 하나의 풀(예 : 리스트, 스택, 큐)에  미리 담아 관리한다.

파괴 대신 비활성화하여 풀에 저장하고, 생성 대신 풀에서 꺼내어 활성화하는 방식을 사용한다.

<br>

풀 내의 오브젝트는 파괴되지 않고 메모리에 계속 남아있기 때문에, 

CPU 성능 소모를 줄이고 메모리 사용량을 더 늘리는 기법이라고 할 수 있다.

<br>


# 참고사항
---

- 오브젝트 풀링의 대상이 되는 오브젝트 내에 생성되는 순간 발생해야 하는 이벤트가 있을 경우, 활성화 순간에 발생하도록 변경해주어야 한다.<br>
  예시 - `Awake()`, `Start()` -> `OnEnable()`로 이동

- 게임오브젝트 파괴(`Destroy(Object)`)를 사용하던 코드는 모두 오브젝트 풀에 의한 비활성화로 변경해야 한다.

- 자주 사용되지 않는 오브젝트가 계속 풀에 남아있으면 불필요하게 메모리를 소모하므로, 때때로 잘 판단하여 제거해줄 필요가 있다.

- `List<T>`, `Stack<T>`, `Queue<T>` 모두 성능은 크게 차이 없지만, `Stack<T>`이 그나마 가장 낫다고 한다.
  - <https://forum.unity.com/threads/object-pool-performance.453524/>

<br>

# 설계
---

## **Pooling**

오브젝트 풀링의 개념은 단순하다.

게임오브젝트를 파괴하는 대신 비활성화하여 풀에 넣고,

생성하는 대신 풀에서 꺼내어 활성화하면 된다.

따라서 동일한 게임오브젝트 여러 개를 풀링하려면 하나의 풀로 간단히 구현할 수 있다.

풀을 스택으로 구현한다고 할 때, 스택에 단순히 `GameObejct`를 담는다면

풀은 `Stack<GameObject>` 타입이 된다.

<br>

## **다중 풀링**

서로 다른 게임오브젝트들을 풀링하려면 조금 더 복잡해진다.

우선 각각의 풀을 하나의 컨테이너에서 관리해야 한다.

그리고 컨테이너 내의 풀에 접근할 때마다 선형 탐색, 이진 탐색과 같은 방법을 사용하는 것은 비효율적이며,

해시 테이블 형태의 컨테이너를 사용하는 것이 좋다.

`C#`에서는 `Dictionary<,>`를 사용하면 된다.

따라서 `Dictionary<KeyType, Stack<GameObject>>` 형태로 다중 풀링 컨테이너를 구현한다.

<br>

## **샘플 오브젝트**

동일한 게임오브젝트를 복제하여 다수를 풀에 넣어 놓기 위해서는

복제의 대상이 될 샘플 게임오브젝트가 하나씩 필요하다.

`Key`를 이용해 풀을 관리하는 것처럼,

샘플 오브젝트 역시 `Key`를 통해 참조할 수 있도록

`Dictionary<KeyType, GameObject>`와 같은 형태로 관리한다.

그리고 샘플 오브젝트는 반드시 파괴되지 않도록 보장해줘야 한다.

<br>

## **Key 선택**

다중 풀링에서 각각의 풀에 접근하기 위해서는 `Key`가 필요하다.

그리고 우선 `Key`를 어떻게 정할 것인지, 타입은 무엇으로 할지 결정해야 한다.

사실 가장 간편하면서도 좋은 선택이 될 수 있는 것은 게임오브젝트의 이름 또는 태그를 사용하는 것이다.

항상 동일하게 유지될 샘플 오브젝트의 이름을 `Key`로 사용하고,

샘플로부터 복제하여 풀에 넣는 오브젝트들도 동일한 이름을 사용하게 한다.

이렇게 되면 풀에 다시 집어넣을 때,

복제된 오브젝트로부터 번거로운 방식으로 `Key`를 알아내는 과정 없이

곧바로 해당 오브젝트의 이름을 `Key`로 사용하여 알맞은 풀을 참조하여

곧장 풀에 다시 회수할 수 있다는 이점이 있다.

<br>

그런데 현재 유니티에서 이 방식은 치명적인 단점이 있다.

게임오브젝트의 이름과 태그는 각각 `.name`, `.tag` 프로퍼티로 참조할 수 있는데

이 프로퍼티들을 참조할 때마다 스트링이 동적으로 생성되어,

결국 `GC`의 수집 대상이 된다는 점이다.

이렇게 되면 풀링을 통한 활성화/비활성화를 수행할 때마다 `GC` 호출이 계속해서 발생하게 되므로

풀링에 의한 성능 향상이 잦은 `GC` 호출로 인해 말짱 도루묵이 될 수 있다.

<br>

## **GC 문제 해결을 위한 두 가지 방법**

위의 문제가 발생하는 근본 원인은 다음과 같다.

키를 통해 참조한 풀에서 복제된 오브젝트를 꺼내어 활성화하는 것은 아무런 문제가 없지만,

복제된 오브젝트를 다시 집어넣을 때, 해당 오브젝트로부터 `Key`를 알아내는 과정이 문제가 된다.

이를 해결하기 위해서 두 가지 방안이 있다.

<br>

### **1) 컴포넌트를 추가로 사용한다**

복제된 오브젝트에 `Key`의 정보를 갖고 있는 컴포넌트를 추가한다.

그러면 복제된 오브젝트를 다시 풀에 넣을 때 이 컴포넌트의 `Key`를 직접 참조하여

풀에 넣어주면 해결된다.

대신, 간단히 `GameObject`로 풀링 대상을 참조하던 모든 코드에서

이 컴포넌트의 타입을 참조하도록 해주어야 하며

외부에서 복제된 컴포넌트를 다시 풀에 넣으려고 할 때도

반드시 이 컴포넌트를 참조해야만 한다.

<br>

### **2) 메소드 핸들을 사용한다**

풀에서 오브젝트를 꺼내는 메소드를 `Spawn(key)`라고 할 때,

이 메소드가 해당 오브젝트를 다시 풀에 집어넣는 메소드 핸들(델리게이트)을 리턴하면 된다.

그럼 `1)`처럼 컴포넌트를 추가로 사용할 필요가 없다는 장점이 있다.

대신 메소드 핸들이 없으면 동적으로 다시 풀에 집어넣을 방법이 없다는 단점이 존재한다.

<br>

### **Key 타입 결정**

이제 위의 두 가지 방법 중 하나를 선택하여 문제를 해결할 수 있다.

그리고 `Key`의 타입을 원하는 대로 결정할 수 있는데,

`string` 타입을 우선 생각해볼 수 있다.

문자열을 `Key`로 사용하면 직관적이라는 것이 가장 큰 장점이다.

하지만 스크립팅 시 오탈자가 발생하면 치명적일 수 있다는 단점이 있고

혹여나 동적으로 스트링을 생성하면 그대로 `GC`의 먹이가 된다.

<br>

그 다음으로는 숫자 타입이 있다.

`int`와 같은 숫자 타입을 사용하게 되면

풀링 대상이 미리 정해져 있는 경우

```cs
const int BulletKeyA = 101;
const int BulletKeyB = 102;
```

이렇게 미리 상수를 정의하여 참조할 수도 있고

동적으로 풀에 추가된다고 해도, 키가 중복되지 않도록 키 관리 매니저를 만들어서

키를 차례로 발급하여 사용할 수도 있다.

<br>

마지막으로 사용자 정의 `enum`을 생각해볼 수 있는데,

이는 오로지 모든 풀링 오브젝트가 컴파일 타임에 결정된 경우에 한해 사용한다.

하나의 `enum`으로 모든 풀링 오브젝트의 키 정보를 관리할 수 있고

스크립팅 시 문자열과는 다르게 오탈자를 걱정하지 않아도 되므로

미리 풀링 오브젝트를 모두 결정하는 경우라면 굉장히 편리한 방법이라고 할 수 있다.

<br>

# 컴포넌트 기반으로 구현하기
---




<br>

# 메소드 핸들 기반으로 구현하기




<br>

# PoolObject 클래스
---

## **역할**

- 오브젝트 풀링의 대상이 될 각각의 게임오브젝트에 컴포넌트로 사용된다.

- 각각의 풀로 구분될 `Key`를 부여받고, 저장한다.<br>
  (동일 `Key`는 하나의 풀 내에서 함께 관리된다.)

- 게임오브젝트 생성, 파괴, 활성화, 비활성화 등의 API를 구현하여 제공한다.

<br>

## **[1] 필드**

### **static ushort nextUniqueID**
- `CreateUniqueID()` 호출 시 제공할 다음 ID 값

### **ushort id**
- 오브젝트가 갖는 고유 ID 값

<br>

## **[2] 메소드**

### **static ushort CreateUniqueID()**
- 새로운 고유 ID를 생성하여 리턴한다.




<br>

# ObjectPoolManager 클래스
---

## **[1] 필드**

### **Dictionary<ushort, PoolObject> sampleDict**
- 

### **Dictionary<string, Stack<PoolObject>> poolDict**
- 


<br>

## **[2] 메소드**

### **ushort Register(GameObject go)**
- 게임오브젝트를 복제하여 새롭게 풀에 등록하고 ID를 리턴한다.

### **void Prepare(ushort id, int count)**
- 해당 `id`의 오브젝트를 `count` 개수만큼 미리 생성하여 스택에 담아놓는다.

### **Spawn(ushort id)**
- `id`에 해당하는 게임오브젝트를 풀에서 꺼내며 활성화한다.
- 풀에 여유가 없을 경우, 새로 생성한다.

### **Despawn(PoolObject obj)**
- 대상 오브젝트를 비활성화하여 풀에 넣는다.
- `PoolObject`가 기억하는 자신의 ID에 해당되는 풀에 알아서 들어간다.

<br>

# Source Code
---
- <https://github.com/rito15/UnityStudy2>


# Download
---
- 




# 목표
---
- 디스어셈블러로 C# 코드 열어봤을 때 띠용하지 않기

<br>

# 대상
---

- Intel Assembly (AT&T 문법과는 다르다)

<br>

# 문법
---

```
// 피연산자 하나
[opcode] [operand]

// 피연산자 둘
[opcode] [operand1], [operand2]

// 주석
; 주석주석
```

<br>

## 예시(C# 디스어셈블리)

```
// 32비트 주소 2874424의 값을 1 증가
inc dword ptr ds:[2874424h]

// EDX 레지스터의 값을 EBP 레지스터의 32비트 주소 3C 위치로 이동
mov dword ptr [ebp-3Ch], edx
```

<br>

- operand가 `[]`로 묶여있다면 해당 값을 주소가 가리키는 메모리 위치를 의미한다..

- 예시 :

|Operand|Address|Value|
|---|---|---|
|eax|0x000040|32|
|edx|0x000048|42|

이 상태에서

```
mov [eax], edx
```

명령은

`eax`가 갖고 있는 값을 `edx`가 갖고 있는 `42`로 바꾸라는 것이 아니고,

`eax`의 값인 `32`를 주소로 갖는 메모리 위치의 값을 `42`로 바꾸라는 의미이다.

<br>

# 접두사에 따른 레지스터 크기
---

- `E` : 32bit (예 : EAX, EBX, ECX, EDX)
- `R` : 64bit (예 : RAX, RBX, RCX, RDX)

<br>

# 접미사
---

- `h` : 16진수 값
- `b` : 2진수 값

<br>

# 레지스터
---


TODO : 디스어셈블러로 씨샵 코드 다 까보고 나오는 레지스터 싹다 정리


## **EAX***
- Extended Accumulator Register
- 기본 산술(사칙) 연산 레지스터
- 연산 결과가 EAX에 저장된다.

## **EBX**
- Extended Base Register
- 

## **EDX***
- Extended Data Register
- 기본 연산 레지스터
- 연산 결과가 EDX에 저장되지 않는다.

## **ECX**
- Extended Counter Register
- 

## **ESP***
- 

## **EBP***
- 

## **EIP***
- 

## **SFP(Stack Frame Pointer)***
- 


<br>

# 명령어
---

## `nop`
- 아무것도 하지 말라는 뜻

<br>

## `mov`, lea`
- mov는 operand2의 값을 operand1에 넣는다.
- lea는 operand2의 주소값을 operand1(레지스터만 가능)에 넣는다.

```
mov eax esi; -> 
lea 
```


<br>

# References
---
- <https://sunrinjuntae.tistory.com/24>
- <https://iceb1u3.tistory.com/entry/2장-레지스터와-어셈블리어-정리>
- <https://velog.io/@hidaehyunlee/libasm-어셈블리-프로그램-구조와-x64-레지스터-이해하기>
- <https://sewcode.tistory.com/10>
- <https://coding-factory.tistory.com/651>
- <https://velog.io/@kjh3865/movandlea>

- <https://www.youtube.com/watch?v=yf7yFJHTif8>
# 목표
---
- 디스어셈블러로 C# 코드 열어봤을 때 띠용하지 않기

<br>



# 대상
---

- Intel Assembly (AT&T 문법과는 다르다)

<br>



# 어셈블리 연산 특징
---

메모리 간의 연산을 수행할 때, 반드시 레지스터를 거쳐간다.

예를 들어 메모리 **0x24** 위치의 값을 **0x9A**에 옮기려면

우선 **0x24**에서 `rax`로 옮기고, `rax`에서 **0x9A**로 옮기는 식이다.

<br>



# 문법
---

## **단항 연산(Unary Operation)**

```
[opcode] [operand]
```


## **이항 연산(Binary Operation)**

- `operand2`를 `operand1`에 `opcode` 한다.

```
[opcode] [operand1], [operand2]
```


## **주석(Comment)**

```
; 주석주석
```

<br>



# 자료형
---

## **BYTE**
- `8` bit (1byte)

## **WORD**
- CPU의 기본 처리 단위
- `16` bit (2byte)

## **DWORD**
- Double Word
- `32` bit (4byte)

## **QWORD**
- Quadruple Word
- `64` bit (8byte)

## **부호 있는 자료형**
- SBYTE (8 bit)
- SWORD (16 bit)
- SDWORD (32 bit)
- SQWORD (64 bit)

<br>



# 대괄호 연산자
---

```
mov eax, ebp
```

위의 명령어는 `ebp` 레지스터가 갖고 있는 값을 `eax` 레지스터에 넣으라는 의미다.

<br>


```
mov eax, [ebp]
```

이렇게 레지스터 또는 숫자를 대괄호가 감싸는 경우가 있는데,

대괄호는 마치 C계열 언어의 포인터 역참조 연산자(`*`)처럼 동작한다.

해당 레지스터에 저장된 값을 주솟값으로 하는 메모리 위치의 값을 참조하라는 뜻이다.

위 명령어에서 만약 `ebp` 레지스터 내에 `0x48` 값이 있었다면

메모리의 `0x48` 주소에 위치한 값을 `eax`에 넣으라는 의미가 된다.

<br>

```
mov eax, [
```

<br>


```
mov eax, [ebp+30h]
```

이렇게 대괄호 내에 연산식이 포함된 경우는, 연산의 결과값이 가리키는 메모리 위치의 값을 참조하라는 뜻이다.

따라서 위의 명령어는 `ebp + 0x30`, 즉 `0x48 + 0x30 = 0x78` 메모리 위치의 값을 `eax`에 넣으라는 의미가 된다.

<br>



# 숫자 리터럴 접미사
---

- `h` : 16진수 값
- `b` : 2진수 값

<br>



# 접두사에 따른 레지스터 크기
---

- 없음 : 16 bit (예 : AX, BX, CX, DX)
- `E` : 32 bit (예 : EAX, EBX, ECX, EDX)
- `R` : 64 bit (예 : RAX, RBX, RCX, RDX)

<br>

## **Note**
같은 이름의 `E` 레지스터는 `R` 레지스터의 하위(상대 주소 0부터 시작) 4바이트(32비트)를 의미한다.

예를 들어 `EAX`는 `RAX`의 하위 4바이트를 참조한다.

<br>



# 레지스터 종류
---

## **[1] 범용 레지스터**

### **AX**
- Accumulator
- 기본 산술(사칙) 연산 레지스터
- 함수의 리턴 값이나 연산 결과가 저장된다.

### **BX**
- Base Address
- 배열의 주소를 저장한다.

### **CX**
- Counter
- 반복문에서 반복 횟수를 기록한다.

### **DX**
- Data
- 기본 연산 레지스터
- AX의 보조 레지스터
- 연산 결과가 EDX에 저장되지 않는다.

<br>

## **[2] 인덱스 레지스터**

### **SI**
- Source Index
- 데이터 이동 시 원본 데이터의 주소를 저장한다.

### **DI**
- Destination Index
- 데이터 이동 시 목적지 주소를 저장한다.

<br>

## **[3] 포인터 레지스터**

### **BP**
- Base Pointer
- 현재 스텍 프레임의 시작 주소를 저장한다.

### **SP**
- Stack Pointer
- 현재 스택 프레임의 종료 주소를 저장한다.

### **IP**
- Instruction Pointer
- 수행할 명령어의 주소를 저장한다.

### **SFP**
- Stack Frame Pointer
- 

<br>



# 명령어 - 단항
---

## **nop**
- 아무것도 하지 말라는 뜻

<br>

## **push**
- 스택에 값을 넣는다.

<br>



# 명령어 - 이항
---

## **mov**
- operand2의 값을 복사하여 operand1에 넣는다.

<br>

## **lea**
- operand2의 주소값을 복사하여 operand1(레지스터만 가능)에 넣는다.

```
mov     qword ptr [rbp+28h],rax
mov     rdx,qword ptr [rbp+30h]  
lea     rcx,[rdx+8]
```

위의 예제를 해석하면 다음과 같다.

> rax의 값을 [rbp + 0x28 (40)] 메모리 위치에 넣는다.
> [rbp + 0x30] 


<br>

# References
---
- <https://sunrinjuntae.tistory.com/24>
- <https://iceb1u3.tistory.com/entry/2장-레지스터와-어셈블리어-정리>
- <https://velog.io/@hidaehyunlee/libasm-어셈블리-프로그램-구조와-x64-레지스터-이해하기>
- <https://sewcode.tistory.com/10>
- <https://coding-factory.tistory.com/651>
- <https://velog.io/@kjh3865/movandlea>
- <https://blog.kimtae.xyz/9>

- <https://to-paz.tistory.com/99>
- <https://5kyc1ad.tistory.com/32>

- <https://www.youtube.com/watch?v=yf7yFJHTif8>
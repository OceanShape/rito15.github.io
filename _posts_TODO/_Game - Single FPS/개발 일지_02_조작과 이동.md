
# Note
---

주요 코드만 작성하고 나머지 생략

빠른 개발을 위해 중요한 내용 위주로 작성

<br>


# 1. 플레이어 캐릭터 기본 조작
---

WASD로 이동, Space로 점프, 마우스 좌우 움직임으로 회전한다.

그리고 마우스 상하 움직임으로 카메라 릭을 회전시킨다.

Left Alt 키를 누르면 마우스 표시/해제를 할 수 있으며,

마우스 커서가 표시된 상태에서는 조작할 수 없다.

이동, 회전의 경우에는 Update() 내에서 입력받으며 각각의 플래그를 true로 만든다.

예를 들어 현재 프레임에서 이동 플래그가 true일 경우,

이어지는 물리 프레임에서 FixedUpdate() 내에서 이동시킨다.

점프도 마찬가지로 Update()에서 플래그를 설정하되,

FixedUpdate()에서 점프를 한 번 수행하면 플래그를 해제해야 한다.

입력은 철저히 Update()에서 받고, 물리 관련 기능은 FixedUpdate()에서 구현하는 것이 핵심.

<br>

```cs
/* PlayerController class */

private void Update()
{
    deltaTime = Time.deltaTime;

    HandleCusorLockInputs();

    if (!isCusorLocked)
    {
        isMoving = isRotating = false;
        return;
    }

    HandleMovementInputs();
    HandleRotationInputs();
    HandleJumpInputs();
    RotateCameraRig();
}

private void HandleCusorLockInputs()
{
    if (Input.GetKeyDown(cursorLockKey))
    {
        isCusorLocked    = !isCusorLocked;
        Cursor.visible   = !isCusorLocked;
        Cursor.lockState = isCusorLocked ? CursorLockMode.Locked : CursorLockMode.None;
    }
}
private void HandleMovementInputs()
{
    moveDir.x = Input.GetAxisRaw("Horizontal");
    moveDir.z = Input.GetAxisRaw("Vertical");

    isMoving = moveDir.x != 0f || moveDir.z != 0f;
    if (isMoving)
    {
        worldMoveDir = transform.TransformDirection(moveDir.normalized);
    }
}
private void HandleRotationInputs()
{
    hRot = Input.GetAxis("Mouse X");
    isRotating = hRot != 0f;
}
private void HandleJumpInputs()
{
    if (Input.GetKeyDown(jumpKey))
        isJumpRequired = true;
}
private void RotateCameraRig()
{
    float vRot = -Input.GetAxis("Mouse Y") * rotateSpeed * deltaTime;
    Quaternion q = Quaternion.Euler(vRot, 0f, 0f);
    cameraRig.rotation *= q;
}
```

<br>


# 2. 물리 기반 이동, 회전 구현하기
---

Update()에서 설정한 플래그, 조립된 이동 및 회전 값을 이용해

FixedUpdate()에서 각각의 기능을 수행하도록 구현한다.

```cs
private void FixedUpdate()
{
    fixedDeltaTime = Time.fixedDeltaTime;

    PhysicsMove();
    PhysicsRotate();
}

private void PhysicsMove()
{
    if (!isMoving) return;

    Vector3 moveOffset = worldMoveDir * (moveSpeed * fixedDeltaTime);
    rb.MovePosition(rb.position + moveOffset);
}

private void PhysicsRotate()
{
    if (!isRotating) return;

    float eulerRotY = hRot * rotateSpeed * fixedDeltaTime;
    Quaternion nextRot = Quaternion.Euler(0f, eulerRotY, 0f);
    rb.MoveRotation(nextRot * rb.rotation);
}
```

<br>


# 3. 점프 및 지면 판정
---

레이캐스트 또는 스피어캐스트를 통해 지면에 닿아 있는지 여부를 판정한다.

캐릭터가 캡슐 콜라이더를 사용하므로 스피어 캐스트를 통해 -Y 방향으로 지면을 판정한다.

그리고 지면에 닿아 있는 경우에만 점프가 가능하도록 한다.

```cs
private void FixedUpdate()
{
    fixedDeltaTime = Time.fixedDeltaTime;

    CheckGroundState();
    
    PhysicsMove();
    PhysicsRotate();
    PhysicsJump();
}

private void CheckGroundState() // SphereCast
{
    const float SphereRadius = 0.5f;
    const float RayBeginOffset = 1f;
    float rayDist = RayBeginOffset + groundThreshold;

    Vector3 ro = rb.position + new Vector3(0f, RayBeginOffset, 0f);
    Vector3 rd = Vector3.down;
    Ray ray = new Ray(ro, rd);

    isGrounded = Physics.SphereCast(ray, SphereRadius, rayDist, Layers.Ground);
}

private void PhysicsJump()
{
    if (!isJumpRequired) return;
    if (!isGrounded)
    {
        isJumpRequired = false;
        return;
    }

    rb.AddForce(new Vector3(0f, jumpForce, 0f), ForceMode.VelocityChange);
    isJumpRequired = false;
}
```


<br>


# 4. 전방 판정을 통해 벽에 달라 붙는 현상 해결하기
---



```cs
private void FixedUpdate()
{
    fixedDeltaTime = Time.fixedDeltaTime;

    CheckGroundState();
    CheckForward();
    
    PhysicsMove();
    PhysicsRotate();
    PhysicsJump();
}

private void CheckForward()
{
    if (!isMoving) return;

    /* [아이디어]
    * - 진행 방향 접촉면의 노멀 벡터가 World +Y 벡터와 수직이면 이동 벡터의 노멀 방향 성분 제거
    */

    float radius = capsule.radius;
    float dist = forwardThreshold * moveSpeed;

    // 1. Cast Bot
    Vector3 originOffset = worldMoveDir * (dist * 0.5f);
    Vector3 capsuleCastOriginTop = CapsuleTopCenter - originOffset;
    Vector3 capsuleCastOriginBot = CapsuleBotCenter - originOffset;

    if (Physics.CapsuleCast(capsuleCastOriginTop, capsuleCastOriginBot, radius, worldMoveDir, out RaycastHit hit, dist, Layers.Mask.Ground))
    {
        Vector3 normal = hit.normal;

        // 깎아지른 절벽이 아닌 경우, 해당X
        if (Mathf.Abs(Vector3.Dot(normal, transform.up)) > 0.1f)
            return;

        // 노멀 방향 기저 성분 제거
        worldMoveDir -= Vector3.Project(worldMoveDir, normal);

        Debug.DrawRay(rb.position + Vector3.up * 0.5f, worldMoveDir, Color.blue, fixedDeltaTime);
        Debug.Log("Forward Hit");
    }
}
```


발견된 문제점 : 벽 하나가 아니라 벽이 두 개 이상 겹친 코너에 돌진하면 그대로 허공에서 정지


<br>


# 5. 지면을 타고 이동하기
---
- 계단 타고 내려올 때 허공에 떠오르지 않고 자연스럽게
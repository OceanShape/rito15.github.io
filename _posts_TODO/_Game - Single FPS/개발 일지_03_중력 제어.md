
# 1. 중력 직접 제어하기
---

발 딛는 곳이면 어디든 그 노멀 역방향으로 중력을 적용할 예정이므로,

리지드바디의 `useGravity`를 `false`로 해준다.

그럼 이제부터

1. 중력 가속도를 직접 설정하고
2. 현재 속도를 필드에 기억시키며
3. 속도를 바탕으로 직접 리지드바디를 움직여야 한다.

<br>

'발 딛는 곳의 노멀 역방향'이라고 표현했지만, 약간의 편법을 사용한다.

중력은 항상 `-transform.up` 방향으로 적용하고,

캐릭터의 회전을 변경하면 적용되는 중력도 함께 변화하도록 한다.

<br>

중력을 직접 제어하게 되었으므로, 점프 역시 수동으로 속도를 변경하도록 한다.

어차피 기존 리지드바디에서 점프 시 사용하던 방법과 동일하다.

<br>

작업 상의 편의, 그리고 기능 독립을 위해 XZ평면 이동 벡터와 Y축 속도를 분리한다.

그리고 WASD 입력에 대해 XZ 이동 벡터를 초기화하고,

점프 및 중력에 의해 Y축 속도를 초기화한다.

그리고 최종적으로 이동 벡터를 조립하여 리지드바디를 이동시킨다.

<br>

```cs
[SF] private Vector3 localUpDir;   // 로컬 상단 벡터
[SF] private Vector3 gravityDir;   // 중력 방향(로컬 하단 벡터)
[SF] private Vector3 finalMoveOffset; // 최종 물리 이동 벡터

private void FixedUpdate()
{
    InitFieldValues();

    CheckGround();
    CheckForwardWall();
    AdjustMovementY();

    PhysicallyMoveCharacter();
    PhysicallyRotateCharacter();
    RotateCameraRig();
    PhysicsJump();

    ApplyFinalPhysicsMovement();
}

private void InitFieldValues()
{
    fixedDeltaTime = Time.fixedDeltaTime;
    localUpDir = transform.up;
    gravityDir = -localUpDir;
}

private void AdjustMovementY()
{
    if (isGrounded)
    {
        verticalVelocity = 0f;
    }
    else
    {
        ApplyGravity();
    }
}

private void ApplyGravity()
{
    // 중력에 따라 Y축 속도 가감
    verticalVelocity -= gravityForce * fixedDeltaTime;
}

private void PhysicsJump()
{
    if (!isJumpRequired) return;
    if (!isGrounded)
    {
        isJumpRequired = false;
        return;
    }

    //rb.AddForce(new Vector3(0f, jumpForce, 0f), ForceMode.VelocityChange);
    verticalVelocity = jumpSpeed; // 점프
    isJumpRequired = false;
}

/// <summary> 최종 이동 벡터 조립 및 리지드바디 이동 </summary>
private void ApplyFinalPhysicsMovement()
{
    finalMoveOffset =
        horizontalMoveOffset
        + localUpDir * (verticalMoveOffset + (verticalVelocity * fixedDeltaTime));

    rb.velocity = Vector3.zero;
    rb.MovePosition(rb.position + finalMoveOffset);
}
```

<br>

# 2. 지면 감지 코드 변경 및 Y축 연속 충돌 감지
---

기존의 코드에서는 캡슐의 반지름만큼 Sphere Cast의 반지름을 설정하였다.

하지만 이에 따라 캡슐의 옆면에 벽이 닿아도 인식되는 버그가 있으므로,

캡슐의 반지름보다 살짝 작은 구체를 캐스트하여 지면을 감지하도록 한다.

<br>

그리고 지면까지의 거리를 필드로 저장하고 있다가

중력에 따라 현재 Y축 속도를 조절하는 `ApplyGravity()` 메소드에서 사용하여,

아주 높은 곳에서 빠르게 떨어져도 지면에 정확히 착지할 수 있도록

Y축 방향의 Continuous Collision Detection을 구현한다.

<br>

```cs
[SF] private float groundDistance; // 현재 높이에서 지면까지의 거리

private void CheckGround() // SphereCast
{
    const float RayDist = 1000f;
    const float RayBeginOffset = 0.5f;
    float radius = capsule.radius * 0.98f;
    float originOffset = radius + RayBeginOffset;

    Vector3 rd = gravityDir;
    Vector3 ro = rb.position - rd * originOffset;
    Ray ray = new Ray(ro, rd);

    if (Physics.SphereCast(ray, radius, out var hit, RayDist, Layers.Mask.Ground))
    {
        groundDistance = hit.distance - RayBeginOffset;
        isGrounded = groundDistance < groundThreshold;
    }
    else
    {
        groundDistance = RayDist;
        isGrounded = false;
    }
}

private void ApplyGravity()
{
    // 1. 중력에 따라 Y축 속도 가감
    verticalVelocity -= gravityForce * fixedDeltaTime;

    // 이동 거리 시물레이션
    float moveDelta = -verticalVelocity * fixedDeltaTime;

    // 2. 지면을 뚫고 내려갈 예정인 경우, 지면에 정확히 안착하도록 Y축 속도 조정
    if (groundDistance < moveDelta)
    {
        verticalVelocity = -groundDistance / fixedDeltaTime;
    }
}
```

<br>


# 4. 지면을 타고 이동하기
---
- 계단/지면 타고 내려올 때 허공에 떠오르지 않고 자연스럽게 지면에 밀착하여 내려오기

// - 이동 속도를 유지해야 함(따라서 이동 벡터를 회전시키는 방향으로?)
// - 경사에 따라 이동속도 변경할지 결정

// - 좀비 아포칼립스는 전부 각진 건물이고, 터레인 없는데 이거 굳이 필요 없을듯?
// - 그래도 일단 구현하고 [전방 벽 밀착] + [커스텀 중력] + [중력 CCD]와 세트로
// - '간단한 물리 기반 이동' 포스팅

# 5. 건물 딛고 올라가기
---



